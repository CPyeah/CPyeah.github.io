<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ElasticSearch学习及原理浅析</title>
    <url>/2021/05/27/ElasticSearch%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ElasticSearch学习及原理浅析"><a href="#ElasticSearch学习及原理浅析" class="headerlink" title="ElasticSearch学习及原理浅析"></a>ElasticSearch学习及原理浅析</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章我们一起来学习一下最最流行的搜索引擎 - <code>ElasticSearch</code><br>我们将学习到：</p>
<ul>
<li>ES集群、节点类型、分片</li>
<li>服务发现机制</li>
<li>选举机制</li>
<li>Docker搭建集群环境</li>
<li>基础API操作</li>
<li>ES的数据结构及文件系统</li>
<li>存储文档的过程</li>
<li>索引及搜索</li>
</ul>
<span id="more"></span>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16448952278198.jpg"><br>重点特性有以下几条：</p>
<ul>
<li>存储、管理数据（文档）</li>
<li>快速搜索数据</li>
<li>对于多种数据格式的高效索引</li>
<li>分布式支持高扩展性</li>
<li>弹性伸缩支持高可用性</li>
<li>TA的好搭档-Kibana</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="集群概述"><a href="#集群概述" class="headerlink" title="集群概述"></a>集群概述</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16448956295920.jpg"></p>
<p>单节点服务往往能干的很少，而且容错很低，特别是在大量数据的情况之下，所以为了提高服务的整体的高可用、高扩展性，一个服务往往都是一个集群。</p>
<p>而在ES的集群中，由若干个不同角色的节点组成（ES进程），一个集群有且只有一个master节点。</p>
<p>ES中的数据是由索引（Index）管理的，每一个索引相当于数据库中的表。</p>
<p>索引通过分片的方式，把数据横向分为若干分片，放在不同的节点上，进行分布式的存储。类似于数据库的分表操作。</p>
<p>分片可以设置副本，防止在宕机下的数据丢失。</p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li>master # 主节点</li>
<li>data # 通用数据节点</li>
<li>data_content # 数据目录节点，数据不常变化</li>
<li>data_hot # 热点数据节点，数据的生命周期</li>
<li>data_warm # 中温数据节点</li>
<li>data_cold # 冷数据节点</li>
<li>data_frozen # 封存数据节点</li>
<li>ingest # 数据摄入节点， 只用于执行预处理管道</li>
<li>ml # 机器学习节点</li>
<li>remote_cluster_client # 远程集群节点</li>
<li>transform # 转换节点<ul>
<li>转换节点会进行一种特殊操作，通过特定聚集语句计算，然后将结果写到新的索引中。如果需要使用远成集群数据，请务必在转换节点中添加remote_cluster_client；转换节点设置方法</li>
</ul>
</li>
</ul>
<h4 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h4><ol>
<li>一个集群的简单配置，需要确保有<code>mater</code>节点和<code>data</code>节点。</li>
<li>如果生产环境，且有机器学习（machine learning）任务或转换（transform）任务（<strong>CPU密集型</strong>），建议将候选的主节点（Master-eligible node）与数据节点（<code>data node</code>）、机器学习节点（<code>machine learning node</code>）和转换节点（<code>transforming node</code>）分开是很有必要的。</li>
<li>每个节点都默认为协调节点（Coordinating node），如果<code>node.roles</code>设置为<code>[]</code>那么该节点将只执行协调节点功能。</li>
</ol>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16448967886435.jpg"></p>
<blockquote>
<p>数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。</p>
</blockquote>
<ul>
<li>提升总体数据的存储量（通过分布式）</li>
<li>提升数据可用性（通过副本）</li>
<li>数据管理的复杂度会提升</li>
</ul>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449078323130.jpg"></p>
<p>假如有三个节点，那么他们应该达成共识，并全部都知道这个集群是个什么样子的。 图中是个反例。</p>
<h4 id="7-x之前之后的实现不同"><a href="#7-x之前之后的实现不同" class="headerlink" title="7.x之前之后的实现不同"></a>7.x之前之后的实现不同</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449067746885.jpg"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449077934455.jpg"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449069256031.jpg"></p>
<ul>
<li>类gossip算法</li>
<li>与种子节点互相交换信息</li>
<li>达到最终的共识</li>
</ul>
<h3 id="选举选主"><a href="#选举选主" class="headerlink" title="选举选主"></a>选举选主</h3><h4 id="选举-Bully（7-x之前）"><a href="#选举-Bully（7-x之前）" class="headerlink" title="选举-Bully（7.x之前）"></a>选举-Bully（7.x之前）</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449089276566.jpg"></p>
<ol>
<li>节点1向节点，节点3发送选举，并且带上自己的序号1</li>
<li>节点2，3接收到消息之后，进行序号比较，发觉自己的序号更大，向节点1返回应答消息Answer (Alive) Message，告知节点1被踢出选主序列</li>
<li>节点2向节点3发送选举请求，节点3找不到更高序号的节点发送选举请求了</li>
<li>节点3向节点2返回应答消息，节点3收不到其他节点的应答消息了</li>
<li>节点3被认为是leader，向其他节点发送Coordinator Message，选举成功的请求，将自己是master节点广播到节点1，节点2</li>
</ol>
<h4 id="选举-类Raft（7-x之后）"><a href="#选举-类Raft（7-x之后）" class="headerlink" title="选举-类Raft（7.x之后）"></a>选举-类Raft（7.x之后）</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449090661855.jpg"><br>举例来说，如果node1，node2，node3进行选主</p>
<ul>
<li>如果node1当选leader，</li>
<li>但是node2发来了投票要求，那么node1无条件退出leader状态，node2选为主节点</li>
<li>但是node3也发来了投票要求，那么node2退出leader状态，node3当选主节点。<br>保证最后当选的leader为主leader</li>
</ul>
<p>相比于Raft算法，Es的选主算法有如下不同</p>
<ol>
<li>初始为 Candidate状态</li>
<li>允许多次投票，也就是每个有投票资格的节点可以投多票</li>
<li>候选人可以有投票的机会</li>
<li>可能会产生多个主节点</li>
</ol>
<h2 id="本地docker搭环境"><a href="#本地docker搭环境" class="headerlink" title="本地docker搭环境"></a>本地docker搭环境</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">cerebro:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lmenezes/cerebro:0.9.4</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cerebro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-Dhosts.0.host=http://es01:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ELASTICSEARCH_URL:</span> <span class="string">http://es01:9200</span></span><br><span class="line">      <span class="attr">ELASTICSEARCH_HOSTS:</span> <span class="string">http://es01:9200</span></span><br><span class="line">      <span class="attr">LOGGING_VERBOSE:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5601:5601&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p><code>docker-compose up</code></p>
<ul>
<li>es: <a href="http://localhost:9200/">http://localhost:9200/</a></li>
<li>kinaba: <a href="http://localhost:5601/">http://localhost:5601/</a></li>
<li>cerebro: <a href="http://localhost:9000/">http://localhost:9000/</a></li>
</ul>
<h2 id="API操作"><a href="#API操作" class="headerlink" title="API操作"></a>API操作</h2><ul>
<li><p>创建索引</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT books</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;number_of_shards&quot; : 4,</span><br><span class="line">        &quot;number_of_replicas&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">            &quot;properties&quot; : &#123;</span><br><span class="line">                &quot;name&quot; : &#123; &quot;type&quot; : &quot;text&quot; &#125;,</span><br><span class="line">                &quot;price&quot; : &#123;&quot;type&quot; : &quot;double&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>新增数据</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT books/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot; : &quot; Effective Java&quot;,</span><br><span class="line">    &quot;price&quot; : 52.00,</span><br><span class="line">    &quot;message&quot; : &quot;本书介绍了在Java编程中78条极具实用价值的经验规则&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT books/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot; : &quot;Effective C&quot;,</span><br><span class="line">    &quot;price&quot; : 58.5,</span><br><span class="line">    &quot;message&quot; : &quot;An Introduction to Professional C Programming&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT books/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot; : &quot;Thinking in Java&quot;,</span><br><span class="line">    &quot;price&quot; : 66.5,</span><br><span class="line">    &quot;message&quot; : &quot;Thinking in Java should be read cover to cover by every Java programmer, then kept close at hand for frequent reference. &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询数据</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br></pre></td></tr></table></figure></li>
<li><p>搜索</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /books/_search?q=name:java</span><br><span class="line"></span><br><span class="line">GET /books/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;message&quot;: &quot;java&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ES的数据结构及文件系统"><a href="#ES的数据结构及文件系统" class="headerlink" title="ES的数据结构及文件系统"></a>ES的数据结构及文件系统</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449122545087.jpg"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/index/SegmentInfos.html">Segments File</a></td>
<td>segments_N</td>
<td>存储关于提交点的信息commit point</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat.html">Segment Info</a></td>
<td>.si</td>
<td>segment的元信息</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50CompoundFormat.html">Compound File</a></td>
<td>.cfs, .cfe</td>
<td>一些“虚拟”信息，少量的数据会存在这</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.html">Fields</a></td>
<td>.fnm</td>
<td>字段的信息</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50StoredFieldsFormat.html">Field Index</a></td>
<td>.fdx</td>
<td>字段索引的信息</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50StoredFieldsFormat.html">Field Data</a></td>
<td>.fdt</td>
<td>存储文档字段数据</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50PostingsFormat.html">Term Dictionary</a></td>
<td>.tim</td>
<td>术语词典</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50PostingsFormat.html">Term Index</a></td>
<td>.tip</td>
<td>术语索引</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.html">Live Documents</a></td>
<td>.liv</td>
<td>文档存活的信息</td>
</tr>
</tbody></table>
<h2 id="存储文档的过程"><a href="#存储文档的过程" class="headerlink" title="存储文档的过程"></a>存储文档的过程</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449123445377.jpg"></p>
<ol>
<li>master节点接收请求</li>
<li>通过对_id的hash（或者路由）来盘点存储到哪一个分片</li>
<li>对应的分片本地存储数据</li>
<li>再同步给副本分片</li>
</ol>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449134143491.jpg"></p>
<ol>
<li>写入请求会将索引（Index）存放到内存区域，叫做 Index Buffer。此时的索引文件暂时是不能被ES搜索到的。</li>
<li>默认情况下 ES 每秒执行一次 Refresh 操作，将 Index Buffer 中的 index 写入到 Filesystem 中，这个也是一片内存区域。</li>
<li>ES 每次 refresh 都会生成一个 Segment，定期对 Segment 进行合并（Merge）操作，也就是将多个小 Segment 合并成一个 Segment</li>
<li>在合并完成后，会将新的 Segment 文件 Flush 写入磁盘。此时 ES 会创建一个 Commit Point 文件，该文件用来标识被 Flush 到磁盘上的 Segment。旧的 Segment 以及合并之前的小 Segment  会被从中移除</li>
</ol>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449134603831.jpg"></p>
<ol>
<li>在 ES 处理用户请求时追加 Translog，追加的内容就是对ES的请求操作。此时会根据配置同步或者异步的方式将操作记录追加信息保存到磁盘中</li>
</ol>
<h2 id="搜索（重点）"><a href="#搜索（重点）" class="headerlink" title="搜索（重点）"></a>搜索（重点）</h2><h3 id="常见索引结构"><a href="#常见索引结构" class="headerlink" title="常见索引结构"></a>常见索引结构</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449758531230.png"></p>
<h3 id="倒排索引结构"><a href="#倒排索引结构" class="headerlink" title="倒排索引结构"></a>倒排索引结构</h3><h4 id="比如我们现在有一个这样的表"><a href="#比如我们现在有一个这样的表" class="headerlink" title="比如我们现在有一个这样的表"></a>比如我们现在有一个这样的表</h4><table>
<thead>
<tr>
<th>id</th>
<th>Text</th>
<th>其他字段。。。</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alan Alice</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Alan</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>Alan</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Alan Brad</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>Alice</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Alan</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>Alan</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>Alan Alice</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>Brad</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>Brad</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="我们现在需要查询包含Alan的所有数据"><a href="#我们现在需要查询包含Alan的所有数据" class="headerlink" title="我们现在需要查询包含Alan的所有数据"></a>我们现在需要查询包含<code>Alan</code>的所有数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> text <span class="keyword">like</span> <span class="string">&#x27;%Alan%&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在Mysql中，这样的查询需要全表扫描，速度慢</p>
<h4 id="而在ES中"><a href="#而在ES中" class="headerlink" title="而在ES中"></a>而在ES中</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449760553786.png"></p>
<ul>
<li>通过分词，将这些关键词（<code>Term</code>）提前提取出来</li>
<li>这些关键词的集合就叫做<code>Term Dictionary</code></li>
<li>每一个关键词，都有一个对应文档的列表<code>Posting List</code></li>
<li>通过FST算法，构建一个Term的索引<code>Term dict index</code></li>
</ul>
<ol>
<li>Terms Dictionary 存储 Term 的索引文件叫做 Terms Index，存储的格式是 .tip</li>
<li>Terms Dictionary 的文件存储格式为 .tim，存储了Term和对应的Postings List指针。</li>
<li>Postings List 被拆成三个文件存储：</li>
<li>.doc后缀文件：记录 Postings 的 docId 信息和 Term 的词频</li>
<li>.pay后缀文件：记录 Payload 信息和偏移量信息</li>
<li>.pos后缀文件：记录位置信息</li>
</ol>
<h4 id="通过ID查找之SkipList"><a href="#通过ID查找之SkipList" class="headerlink" title="通过ID查找之SkipList"></a>通过ID查找之SkipList</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449777126594.png"></p>
<ul>
<li>如果我们要查询id&#x3D;12的文档</li>
<li>正常链表通过遍历，一个一个查询，时间复杂度是 O(n)</li>
<li>跳跃表是通过跳跃分层， 时间复杂度可以达到 O(log n)<ul>
<li>第一层， 0～15</li>
<li>第二层， 8～15</li>
<li>第三层， 12</li>
</ul>
</li>
</ul>
<h3 id="搜索数据-BKDTree"><a href="#搜索数据-BKDTree" class="headerlink" title="搜索数据-BKDTree"></a>搜索数据-BKDTree</h3><p>对于索引一些多维数据，比如 坐标，使用的是BKD-Tree来索引<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449785200616.jpg"></p>
<ul>
<li>如图上的点，我们是怎么给他们做2D平面划分的。</li>
<li>我们需要一个鉴别器<code>discriminator</code></li>
<li>简单的鉴别器就是对层级取模<ul>
<li><code>discriminator = level % N</code></li>
</ul>
</li>
<li>会得到下面的树形结构<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449787811410.jpg"></li>
<li>多维的就是 x y z 一次类推</li>
<li>构建BKD树，就可以更好的根据多维数据来查询对应的文档了</li>
</ul>
<h2 id="ES的优化"><a href="#ES的优化" class="headerlink" title="ES的优化"></a>ES的优化</h2><h2 id="ES相关问题"><a href="#ES相关问题" class="headerlink" title="ES相关问题"></a>ES相关问题</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index.html">官方文档（7.x)</a></li>
<li><a href="https://github.com/elastic/elasticsearch">Github</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Elasticsearch">维基百科</a></li>
<li><a href="https://alibaba-cloud.medium.com/elasticsearch-distributed-consistency-principles-analysis-1-node-b512e2b839f8">Elasticsearch Distributed Consistency Principles Analysis (1) — Node</a></li>
<li><a href="https://juejin.cn/post/7038828692671299620">ES集群中各节点角色功能简介</a></li>
<li><a href="https://mincong.io/2020/08/22/discovery-in-elasticsearch/">Discovery in Elasticsearch</a></li>
<li><a href="https://yemilice.com/2021/06/16/elasticsearch-%E6%96%B0%E8%80%81%E9%80%89%E4%B8%BB%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/">ElasticSearch-新老选主算法对比</a></li>
<li><a href="https://blog.csdn.net/weixin_43902449/article/details/112449240">Elasticsearch数据结构存储流程</a></li>
<li><a href="https://elasticsearch.cn/question/5173">elasticsearch 每个shard对应的文件含义</a></li>
<li><a href="https://www.elastic.co/cn/blog/found-dive-into-elasticsearch-storage#lucene-index-files">A Dive into the Elasticsearch Storage</a></li>
<li><a href="https://mp.weixin.qq.com/s/wms9j22YcHfb8V9CBR65zQ">Elasticsearch写入原理，一看便知！</a></li>
<li><a href="https://yemilice.com/2021/05/14/elasticsearch%E6%A3%80%E7%B4%A2%E7%9A%84%E6%A0%B8%E5%BF%83-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E8%A7%A3%E8%AF%BB/">ElasticSearch检索的核心-倒排索引解读</a></li>
<li><a href="https://yemilice.com/2021/09/09/%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84elasicsaerch%E7%B4%A2%E5%BC%95/">设计高可用的ElasicSearch索引</a></li>
<li><a href="https://medium.com/swlh/bkd-trees-used-in-elasticsearch-40e8afd2a1a4">BKD 树，用于 Elasticsearch</a></li>
</ul>
]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务原理</title>
    <url>/2021/08/25/MySQL%E4%BA%8B%E7%89%A9%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>什么是事务？！</p>
<p>一句话来说，事务是一次操作的<code>逻辑单位</code>。要不全部成功，要不全部失败。</p>
<p>它主要是用来保证<code>数据一致性</code>的问题。</p>
<span id="more"></span>

<p>比如去银行转账的操作，原来账户的扣款，和目标账户的加款。<br>这两个操作要放在一个事务里面，要不一起成功，要不一起失败。</p>
<p>如果在事务中间，发生问题，需要把已经执行了的操作<code>回滚</code>，以保证数据准确。</p>
<h2 id="事务的常见命令"><a href="#事务的常见命令" class="headerlink" title="事务的常见命令"></a>事务的常见命令</h2><ul>
<li>START TRANSACTION：开始一个事务</li>
<li>COMMIT：事务顺利完成时，提交事务</li>
<li>ROLLBACK：事务发生了异常，回滚</li>
</ul>
<p>比如我们有一张customer表，执行一下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lisi&#x27;</span>;</span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<p>再查询表，会得到：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/Prom8Z.png"><br>表示一个事务完成、提交。</p>
<p>我们再执行下面操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;wangwu&#x27;</span>;</span><br><span class="line"><span class="keyword">rollback</span> ;</span><br></pre></td></tr></table></figure>

<p>再查询customer表，会发现wangwu并没有被添加到表中，表中还只有两条记录。</p>
<ul>
<li>建立保存点：SAVEPOINT 保存点名称</li>
<li>删除保存点：RELEASE SAVEPOINT 保存点名称</li>
<li>回滚到特定保存点：ROLLBACK TO SAVEPOINT 保存点名称</li>
</ul>
<p>我们接着再执行下面点语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;zhao liu&#x27;</span>;</span><br><span class="line"><span class="keyword">savepoint</span> my_point;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;qian qi&#x27;</span>;</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> <span class="keyword">savepoint</span> my_point;</span><br></pre></td></tr></table></figure>

<p>我们查询到到结果是：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/gIvWTx.png"><br><code>zhao liu</code> 成功入库了，而 <code>qian qi</code> 被回滚掉了。</p>
<p><code>savepoint</code> 保存点，可以让我们实现部分回滚。</p>
<h2 id="Transaction-四大特性：-ACID"><a href="#Transaction-四大特性：-ACID" class="headerlink" title="Transaction 四大特性： ACID"></a>Transaction 四大特性： ACID</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/NfuAJQ.png"></p>
<p>一个事务有下列四个重要到特性，简称ACID</p>
<ul>
<li>A：Atomicity 原子性。 事务里面到操作，不可分割，要不一起成功，要不一起失败。</li>
<li>C：Consistency 一致性。在事务的前后，系统的整体数据保持一致。比如说银行转账。</li>
<li>I：Isolation 隔离性。 事务之间，相互隔离，互不干扰。</li>
<li>D：Durability 永久性。 一旦数据修改完成，永久有效。</li>
</ul>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/9qUodw.png"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/xJ1VeA.png"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/jez6I1.png"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/vXbP4p.png"></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>介绍完了ACID，我们再来重点说说ACID其中的I(Isolation)。</p>
<p>我们都知道，事务之间是隔离的<br>但是如何处理多个事务之间操作和读取同一个数据的结果，<br>我们需要仔细考虑。</p>
<p>事务隔离级别是在多个事务同时进行更改和执行查询时，<br>调整<code>性能</code>和结果的<code>可靠性</code>、<code>一致性</code>和<code>可再现性</code>之间的平衡的设置。</p>
<p>MySQL（InnoDB）提供四种事务隔离级别：</p>
<ul>
<li>read uncommitted 读未提交</li>
<li>read committed   读已提交</li>
<li>repeatable read  可重复读（MySQL默认隔离级别）</li>
<li>serializable     串行</li>
</ul>
<p>我们可以参考<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">官方文档</a></p>
<h3 id="事务隔离级别的设置"><a href="#事务隔离级别的设置" class="headerlink" title="事务隔离级别的设置"></a>事务隔离级别的设置</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置全局的事务隔离级别</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION LEVEL [REPEATABLE READ <span class="operator">|</span> READ COMMITTED <span class="operator">|</span> READ UNCOMMITTED <span class="operator">|</span> SERIALIZABLE];</span><br><span class="line"># 设置当前Session的隔离级别</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL [REPEATABLE READ <span class="operator">|</span> READ COMMITTED <span class="operator">|</span> READ UNCOMMITTED <span class="operator">|</span> SERIALIZABLE];</span><br><span class="line"># 查看当前事务隔离级别</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_ISOLATION;</span><br></pre></td></tr></table></figure>

<p>我们先做一下前置的准备，<br>开启两个Session，<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/Lf8Nzf.png"></p>
<p>并查看一下当前的事务隔离级别<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/3zaxpJ.png"></p>
<p>接下来，我们一个一个看：</p>
<h3 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h3><p>未提交读，指的就是一个事务读到了另外一个事务未提交的数据。</p>
<p>这样会导致脏读。</p>
<p>我们来实验一下：</p>
<p>我们先设置两个Session的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>

<p>查看下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/WNJBVz.png"></p>
<p>我们现在数据库当中有两条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer;</span><br></pre></td></tr></table></figure>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/trxTdG.png"></p>
<p>我们在Session A中开启一个事务，并修改一条记录，但是不提交。</p>
<p>再在Session B 中查询，看会得到怎样的结果。</p>
<p>我们现在Session A 中执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"># <span class="number">1</span>、开启事务</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们在Session B 中看下结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"># <span class="number">3</span>、查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此时Session A中的事务还没有提交，也就是说有回滚的可能。<br>但在Session B中查看数据， 客户名称已经从 <code>zhangsan</code> 变成了 <code>zhangsan2</code>。</p>
<p>如果Session A再进行了回滚，rollback。 这样Session B就读出了一个不存在的数据，就是脏读。</p>
<p>这是非常不安全的一种隔离级别。</p>
<h3 id="已提交读（READ-COMMITTED）"><a href="#已提交读（READ-COMMITTED）" class="headerlink" title="已提交读（READ COMMITTED）"></a>已提交读（READ COMMITTED）</h3><p>已提交读，就是读到的数据都是另外的事务已经提交过了的数据。<br>可以解决脏读的问题。</p>
<p>我们先修改下事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_ISOLATION;</span><br></pre></td></tr></table></figure>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/5fAmh8.png"></p>
<p>我们在SessionA中修改数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"># <span class="number">1</span>、开启事务</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在Session B 中查看数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"># <span class="number">3</span>、查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/YMiybO.png"><br>我们可以看到，客户名称还是<code>zhangsan</code>，没有变成<code>张飞</code>。</p>
<p>我们这个时候再把Session A中的事务提交</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"># <span class="number">1</span>、开启事务</span><br><span class="line"># <span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据</span><br><span class="line"># <span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、提交事务</span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<p>再次在Session B 中查看数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"># <span class="number">3</span>、查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/wY9JUG.png"><br>我们可以看到，客户名称已经变成了 <code>张飞</code>。</p>
<p>如果session A的事务回滚的话，我们在Session B中看到的结果还会是 <code>zhangsan</code><br>这样，我们就成功解决了脏读的问题了。</p>
<p>但是如果我们在同一个事务中，读取数据，可能会查询到不同的结果。<br>我们按照数字的顺序，执行以下SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>、开启事务，并查看数据</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 张飞</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 关羽</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 刘备</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据（自动提交事务）</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、修改数据（自动提交事务）</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;刘备&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Session B 在同一个事务中，同样的查询语句，得出的结果是不一样的。<br>这种现象我们称之为<code>不可重复读</code>。</p>
<h3 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h3><p>有些场景，我们需要在一个事务中，查询到到数据保持一致，不管外部事务如何改变。</p>
<p>这个时候，就需要我们满足<code>可重复读</code>。</p>
<p>我们直接看效果：</p>
<p>首先修改事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_ISOLATION;</span><br></pre></td></tr></table></figure>

<p>再按照下列SQL的顺序，执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>、开启事务，并查看数据</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 刘备</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 刘备</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 刘备</span></span><br><span class="line"></span><br><span class="line"># <span class="number">6</span>、提交当前事务，在查看数据</span><br><span class="line"><span class="keyword">commit</span> ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 张飞</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据（自动提交事务）</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、修改数据（自动提交事务）</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在Session B 中，每一次查询的结果都是一样的，<br>不管实际的数据怎样的变化，即使数据已经被SessionA所改变，且已提交。</p>
<p>但是这种隔离级别同样有这自己缺陷，它会发生幻读。</p>
<p>我们看下面的场景：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span>、开启事务，并查看数据</span><br><span class="line"># session B</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>、开启事务，并查看数据</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>; <span class="comment">-- null</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、插入指定ID的数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>; <span class="comment">-- null</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">values</span> (<span class="number">10</span>, <span class="string">&#x27;吕布&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">values</span> (<span class="number">10</span>, <span class="string">&#x27;小吕布&#x27;</span>); <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，SessionB在一个事务中，想要插入一条ID为10的用户。<br>重要的是，要第一步查询，已经确定了ID为10的用户并不存在。</p>
<p>但是在事务的过程中，Session A 插入了一条ID为10的客户，并成功提交事务。</p>
<p>等再回到Session B， 再想插入一条ID为10的客户，就报错了<code>Duplicate entry &#39;10&#39; for key &#39;customer.PRIMARY&#39;</code>。</p>
<p>其实，在Session B的操作中，逻辑都是没问题的。但是还是发生了幻读，导致了系统异常。</p>
<p>解决办法是，在Session B中，我们这样写select语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br></pre></td></tr></table></figure>

<p>在 select 语句后面， 添加一个<code>for update</code>，可以把<code>ID=10</code>给加上一个锁，<br>SessionA， 再想干扰，添加数据的时候，就会拿不到锁，而只能等待SessionB的事务完成，并释放锁。</p>
<p>所以保证了SessionB的原子性，杜绝的幻读。</p>
<h3 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h3><p>串行化，这种隔离级别，可以杜绝所有的干扰，包括（脏读、不可重复读、幻读）。</p>
<p>在此级别下，我们便不需要对 SELECT 操作显式加锁，InnoDB会自动加锁，事务安全，但性能很低。</p>
<p>非常不推荐使用。</p>
<h2 id="InnoDB的事务实现（MVCC）"><a href="#InnoDB的事务实现（MVCC）" class="headerlink" title="InnoDB的事务实现（MVCC）"></a>InnoDB的事务实现（MVCC）</h2><p>MVCC，多版本并发控制。<br>顾名思义，他会记录数据变更的版本（像git一样），形成一个版本链。</p>
<p>在通过对这个版本链中不同版本的处理，来实现事务，和事务隔离级别。</p>
<h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>在数据库行数据的结构中，除了我们存储的字段外，还有两个必不可少的隐藏字段：</p>
<p>当前事务ID(<code>trx_id)</code> 和 上个版本数据的引用(<code>roll_pointer</code>)。</p>
<p>直接上代码，我们用Java来模拟MVCC。</p>
<p>完整代码，请查看<a href="https://github.com/CPyeah/java-projets/tree/master/java-mvcc/src/main/java">这里</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Row</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前操作的事务id</span></span><br><span class="line">	<span class="keyword">private</span> Integer trx_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 历史记录的地址</span></span><br><span class="line">	<span class="keyword">private</span> Row&lt;T&gt; roll_pointer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主键ID</span></span><br><span class="line">	<span class="keyword">private</span> Integer primaryId;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其他数据</span></span><br><span class="line">	<span class="keyword">private</span> T otherData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 行锁</span></span><br><span class="line">	<span class="keyword">private</span> ReentrantLock rowLock;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以通过roll_pointer来找到所有的历史版本，可以实现回滚操作，也可以选择指定的版本来展示。</p>
<p>我们再看一下事务操作的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionController</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前活跃的事务列表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; m_ids = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 全局事务ID</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">globeTransactionID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取事务ID</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getNextTransactionId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> globeTransactionID.getAndAdd(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，加行锁</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">update</span><span class="params">(Row&lt;T&gt; newRow, Transaction transaction,</span></span><br><span class="line"><span class="params">			HashMap&lt;Integer, Row&lt;T&gt;&gt; tableData)</span> &#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">primaryId</span> <span class="operator">=</span> newRow.getPrimaryId();</span><br><span class="line">		Row&lt;T&gt; oldRow = tableData.get(primaryId);</span><br><span class="line">		<span class="keyword">if</span> (oldRow == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Data does not exist&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			newRow.setTrx_id(transaction.getTransactionId());</span><br><span class="line">			newRow.setRoll_pointer(oldRow); <span class="comment">// 更新版本链</span></span><br><span class="line">			tableData.put(primaryId, newRow);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newRow.getOtherData();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启一个事务</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">transactionId</span> <span class="operator">=</span> getNextTransactionId();</span><br><span class="line"></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">		transaction.setTransactionId(transactionId);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 把当前的事务ID，存放到活跃事务列表中</span></span><br><span class="line">		m_ids.add(transactionId);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> transaction;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 事务提交</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(Transaction transaction)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (transaction.getLock() != <span class="literal">null</span>) &#123;</span><br><span class="line">			transaction.getLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在活跃事务列表中，移除事务ID</span></span><br><span class="line">		m_ids.remove(transaction.getTransactionId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中几个关键点：</p>
<ul>
<li>全局事务ID ： 全局唯一，递增</li>
<li>当前活跃的事务列表： 这里维护所有的未提交的事务的ID，</li>
<li>开启一个事务： 生成一个事务ID，并把这个事务，维护到活跃事务列表中</li>
<li>更新数据： 新数据赋予事务ID，新数据可以引用到上个版本的老数据，加行锁</li>
<li>提交事务： 解锁，把活跃事务列表中的删除当前事务</li>
</ul>
<p>我们接下来看下事务是怎么运转的：</p>
<p>我们设计一个这样的测试：</p>
<p>完整代码请看<a href="https://github.com/CPyeah/java-projets/tree/master/java-mvcc/src/test/java">这里</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransactionControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@BeforeAll</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		Row&lt;Customer&gt; row = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;刘备&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Customer.tableData.put(row.getPrimaryId(), row);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开启事务A</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">transaction_A</span> <span class="operator">=</span> TransactionController.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开启事务B</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">transaction_B</span> <span class="operator">=</span> TransactionController.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">		Row&lt;Customer&gt; 关羽 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;关羽&quot;</span>);</span><br><span class="line">		TransactionController.update(关羽, transaction_A, Customer.tableData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">		Row&lt;Customer&gt; 张飞 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">		TransactionController.update(张飞, transaction_A, Customer.tableData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 事务A提交，并释放锁</span></span><br><span class="line">		TransactionController.commit(transaction_A);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">		Row&lt;Customer&gt; 赵云 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;赵云&quot;</span>);</span><br><span class="line">		TransactionController.update(赵云, transaction_B, Customer.tableData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">		Row&lt;Customer&gt; 诸葛亮 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;诸葛亮&quot;</span>);</span><br><span class="line">		TransactionController.update(诸葛亮, transaction_B, Customer.tableData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//commit</span></span><br><span class="line">		TransactionController.commit(transaction_B);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打印undo日志链表</span></span><br><span class="line">		printData(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">// 1-诸葛亮(200) -&gt; 1-赵云(200) -&gt; 1-张飞(100) -&gt; 1-关羽(100) -&gt; 1-刘备(null)</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printData</span><span class="params">(Row&lt;Customer&gt; customerRow)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(toString(customerRow));</span><br><span class="line"></span><br><span class="line">		Row&lt;Customer&gt; currentPointer = customerRow;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (currentPointer.getRoll_pointer() != <span class="literal">null</span>) &#123;</span><br><span class="line">			currentPointer = currentPointer.getRoll_pointer();</span><br><span class="line">			sb.append(<span class="string">&quot; -&gt; &quot;</span>)</span><br><span class="line">					.append(toString(currentPointer));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sb);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">toString</span><span class="params">(Row&lt;Customer&gt; customerRow)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> customerRow.getPrimaryId() + <span class="string">&quot;-&quot;</span> + customerRow.getOtherData().getName()</span><br><span class="line">				+ <span class="string">&quot;(&quot;</span></span><br><span class="line">				+ customerRow.getTrx_id()</span><br><span class="line">				+ <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Row&lt;Customer&gt; <span class="title function_">getCustomerRow</span><span class="params">(Integer id, String name)</span> &#123;</span><br><span class="line">		<span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">		customer.setId(id);</span><br><span class="line">		customer.setName(name);</span><br><span class="line"></span><br><span class="line">		Row&lt;Customer&gt; row = <span class="keyword">new</span> <span class="title class_">Row</span>&lt;&gt;();</span><br><span class="line">		row.setPrimaryId(customer.getId());</span><br><span class="line">		row.setOtherData(customer);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> row;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中使用<code>Customer.tableData</code>来模拟存储数据。</p>
<p>在<code>test1</code>中，我们开启了两个事务，并执行了<code>update</code>操作，最总形成了一个版本链：</p>
<p>效果如图所示：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/O2WJFy.png"></p>
<blockquote>
<p>两个事务不能交叉修改同一个数据，因为在<code>Transaction_A</code>第一次执行<code>update</code>操作的时候，<br>就给这个数据加上了行锁，<code>Transaction_B</code>必须等到<code>Transaction_A</code>提交，释放了锁，<br>才可以进行<code>Transaction_B</code>的<code>update</code>操作。</p>
</blockquote>
<p>得到的数据<code>版本链</code>效果如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/cfz3Lp.png"></p>
<h3 id="隔离级别的实现"><a href="#隔离级别的实现" class="headerlink" title="隔离级别的实现"></a>隔离级别的实现</h3><p>我们知道有四大隔离级别，我们来看下它们是怎样实现的。</p>
<h4 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h4><p>串行化，这种级别下，不管是更新，还是查询，它都会加锁，<br>所以每次查询的数据，肯定是事务已经提交后的数据，<br>而每次更新数据的过程中，数据不会再发生变化。<br>不管是查询，还是更新数据的过程中，版本链都不会更新。</p>
<h4 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ UNCOMMITTED"></a>READ UNCOMMITTED</h4><p>读未提交，它的实现也很简单，每次查看数据的时候，都读取版本链中最新的数据，不管操作这个数据的事务有没有提交。</p>
<h4 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h4><p>读已提交，<br>他会在每次查询的时候，都会生成一个<code>ReadView</code>，<br>它会拿到版本链，会从版本链从上往下搜索，<br>找到已经提交了的，最新的一个版本的数据。</p>
<h4 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h4><p>可重复读<br>它会在当前的事务中，第一次查询的时候，生成一个<code>ReadView</code>，<br>也是从版本链中搜索，找到最新一个已经提交了的事务，<br>但是不同于读已提交的是，这个ReadView只生成一次，<br>以后的每次查询，都会查看这同一个ReadView。<br>从而保证<code>可重复读</code>。</p>
<h3 id="ReadView获取"><a href="#ReadView获取" class="headerlink" title="ReadView获取"></a>ReadView获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取到ReadView</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Row&lt;T&gt; <span class="title function_">readView</span><span class="params">(Row&lt;T&gt; chain)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (chain == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m_ids.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> chain;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该值代表生成readView时m_ids中的最小值</span></span><br><span class="line">	<span class="type">Integer</span> <span class="variable">min_trx_id</span> <span class="operator">=</span> m_ids.get(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (Integer id : m_ids) &#123;</span><br><span class="line">		min_trx_id = Math.min(min_trx_id, id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该值代表生成readView时系统中应该分配给下一个事务的id值</span></span><br><span class="line">	<span class="type">Integer</span> <span class="variable">max_trx_id</span> <span class="operator">=</span> getNextTransactionId();</span><br><span class="line"></span><br><span class="line">	Row&lt;T&gt; pointer = chain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isThisReadView(pointer, min_trx_id, max_trx_id)) &#123;</span><br><span class="line">			<span class="keyword">return</span> pointer;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pointer.getRoll_pointer() != <span class="literal">null</span>) &#123;</span><br><span class="line">			pointer = pointer.getRoll_pointer();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否此版本为ReadView</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isThisReadView</span><span class="params">(Row&lt;T&gt; pointer,</span></span><br><span class="line"><span class="params">		Integer min,</span></span><br><span class="line"><span class="params">		Integer max)</span> &#123;</span><br><span class="line">	<span class="comment">// 如果被访问版本的trx_id属性值小于m_ids列表中最小的事务id，</span></span><br><span class="line">	<span class="comment">// 表明生成该版本的事务在生成ReadView前已经提交，</span></span><br><span class="line">	<span class="comment">// 所以该版本可以被当前事务访问。</span></span><br><span class="line">	<span class="keyword">if</span> (pointer.getTrx_id() &lt; min) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果被访问版本的trx_id属性值大于m_ids列表中最大的事务id，</span></span><br><span class="line">	<span class="comment">// 表明生成该版本的事务在生成ReadView后才生成，</span></span><br><span class="line">	<span class="comment">// 所以该版本不可以被当前事务访问。</span></span><br><span class="line">	<span class="keyword">if</span> (pointer.getTrx_id() &gt; max) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果被访问版本的trx_id属性值在m_ids列表中最大的事务id和最小事务id之间，</span></span><br><span class="line">	<span class="comment">// 那就需要判断一下trx_id属性值是不是在m_ids列表中，</span></span><br><span class="line">	<span class="comment">// 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；</span></span><br><span class="line">	<span class="comment">// 如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</span></span><br><span class="line">	<span class="keyword">if</span> (m_ids.contains(pointer.getTrx_id())) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在test1中，加上查看readView的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启事务A</span></span><br><span class="line">	<span class="type">Transaction</span> <span class="variable">transaction_A</span> <span class="operator">=</span> TransactionController.start();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启事务B</span></span><br><span class="line">	<span class="type">Transaction</span> <span class="variable">transaction_B</span> <span class="operator">=</span> TransactionController.start();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">	Row&lt;Customer&gt; 关羽 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;关羽&quot;</span>);</span><br><span class="line">	TransactionController.update(关羽, transaction_A, Customer.tableData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看readView</span></span><br><span class="line">	Row&lt;Customer&gt; readView = TransactionController.readView(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	System.out.println(toString(readView));<span class="comment">// 1-刘备(0)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">	Row&lt;Customer&gt; 张飞 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">	TransactionController.update(张飞, transaction_A, Customer.tableData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 事务A提交，并释放锁</span></span><br><span class="line">	TransactionController.commit(transaction_A);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看readView</span></span><br><span class="line">	readView = TransactionController.readView(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	System.out.println(toString(readView));<span class="comment">// 1-张飞(100)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">	Row&lt;Customer&gt; 赵云 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;赵云&quot;</span>);</span><br><span class="line">	TransactionController.update(赵云, transaction_B, Customer.tableData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看readView</span></span><br><span class="line">	readView = TransactionController.readView(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	System.out.println(toString(readView)); <span class="comment">//1-张飞(100)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">	Row&lt;Customer&gt; 诸葛亮 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;诸葛亮&quot;</span>);</span><br><span class="line">	TransactionController.update(诸葛亮, transaction_B, Customer.tableData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//commit</span></span><br><span class="line">	TransactionController.commit(transaction_B);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看readView</span></span><br><span class="line">	readView = TransactionController.readView(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	System.out.println(toString(readView)); <span class="comment">// 1-诸葛亮(200)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印undo日志链表</span></span><br><span class="line">	printData(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	<span class="comment">// 1-诸葛亮(200) -&gt; 1-赵云(200) -&gt; 1-张飞(100) -&gt; 1-关羽(100) -&gt; 1-刘备(null)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完整代码请查看<a href="https://github.com/CPyeah/java-projets/blob/master/java-mvcc/src/test/java/TransactionControllerTest.java">这里</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经学习了MySQL事务到相关知识。</p>
<ul>
<li>我们了解到了事务到概念</li>
<li>学习了事务的常见用法</li>
<li>了解了事务的四大特性 ACID</li>
<li>并重点说了事务的隔离特定</li>
<li>实践了不同事务隔离级别下的效果</li>
<li>使用Java代码模拟了MVCC的实现</li>
<li>并通过MVCC，掌握事务隔离级别的实现原理</li>
</ul>
<p>本篇文章，希望大家好好掌握。😊</p>
]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java操作Redis</title>
    <url>/2021/03/25/Java%E6%93%8D%E4%BD%9CRedis/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis是目前最流行的缓存数据库，完全基于内存操作，速度非常快。<br>它是我们互联网公司高性能，高并发的基石。<br>它的功能包括但不限于：提供中央缓存功能，分布式锁，还有特殊数据结构的特殊应用。<br>本篇文章都会一一说到。</p>
<p>接下来我们会：</p>
<ul>
<li>使用Docker搭建redis环境</li>
<li>搭建springboot服务</li>
<li>使用redisson来操作redis</li>
<li>熟悉redis的五大基本数据类型</li>
<li>熟悉使用redis的高级数据结构及其应用</li>
</ul>
<span id="more"></span>

<h2 id="使用Docker搭建redis环境"><a href="#使用Docker搭建redis环境" class="headerlink" title="使用Docker搭建redis环境"></a>使用Docker搭建redis环境</h2><p>使用Docker搭建环境非常方便。 在本地安装好Docker后，使用<code>docker compose</code>可以方便快捷但搭好环境。</p>
<p>只需要创建<code>docker-compose.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.9&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;6379:6379&#x27;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--save</span> <span class="number">20</span> <span class="number">1</span> <span class="string">--loglevel</span> <span class="string">warning</span> <span class="string">--requirepass</span> <span class="string">eYVX7EwVmmxKPCDmwMtyKVge8oLd2t81</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker_volume/redis:/data</span></span><br></pre></td></tr></table></figure>

<p>注意： command里面的password和volumes映射，按照自己需要配置</p>
<p>再使用命令行，cd到yaml的目录下，运行<code>docker-compose up</code>命令。</p>
<p>非常简单。</p>
<p>等启动好了之后，可以用redis工具连接，看下效果。</p>
<h2 id="搭建springboot服务"><a href="#搭建springboot服务" class="headerlink" title="搭建springboot服务"></a>搭建springboot服务</h2><p>IDEA启动等一个Springboot的项目。我这里使用的是gradle。maven当让也可以。</p>
<p>我的引用如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.redisson:redisson-spring-boot-starter:3.15.6&#x27;</span></span><br><span class="line">    implementation <span class="keyword">group</span>: <span class="string">&#x27;de.ruedigermoeller&#x27;</span>, name: <span class="string">&#x27;fst&#x27;</span>, version: <span class="string">&#x27;2.57&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;io.projectreactor:reactor-test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里使用的官方推荐的redis客户端<code>Redisson</code>,相关的依赖是<code>org.redisson:redisson-spring-boot-starter:3.15.6</code>和<code>de.ruedigermoeller&#39;, name: &#39;fst&#39;, version: &#39;2.57</code>。这样我们就可以在我们的代码中使用<code>RedissonClient</code>了。</p>
<blockquote>
<p>干净又卫生</p>
</blockquote>
<h2 id="使用redisson来操作redis"><a href="#使用redisson来操作redis" class="headerlink" title="使用redisson来操作redis"></a>使用redisson来操作redis</h2><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p>因为redis是键值对，大家可以把redis当成一个大的<code>HashMap</code>，所以知道它的所有的key很有必要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keysTest</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">RKeys</span> <span class="variable">keys</span> <span class="operator">=</span> redissonClient.getKeys();</span><br><span class="line">	System.out.println(keys.count());<span class="comment">// org.redisson.client.protocol.RedisCommands.DBSIZE 命令</span></span><br><span class="line">	Iterable&lt;String&gt; keysByPattern = keys</span><br><span class="line">			.getKeysByPattern(<span class="string">&quot;*&quot;</span>); <span class="comment">// org.redisson.client.protocol.RedisCommands.SCAN</span></span><br><span class="line">	keys.getKeysStream()</span><br><span class="line">			.forEach(System.out::println);<span class="comment">// org.redisson.client.protocol.RedisCommands.SCAN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redisson中使用<code>RKeys</code>类来对redis中的keys做封装。</p>
<p>我们可以</p>
<ul>
<li>拿到所有key的数量</li>
<li>把所有的key列出来</li>
<li>按照正则匹配key</li>
</ul>
<p>注意，在redisson中，使用的不是redis提供的<code>keys</code>命令，而是<code>scan</code>命令。原因是因为，redis是单线程服务，如果key的量特别大，一次keys操作会消耗很长时间，整体拖慢服务性能。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>String</code>是redis的最基础的数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">	RBucket&lt;String&gt; hello = redissonClient.getBucket(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	System.out.println(hello.get());<span class="comment">// org.redisson.client.protocol.RedisCommands.GET</span></span><br><span class="line">	hello.set(<span class="string">&quot;world ! &quot;</span>, <span class="number">5</span>,</span><br><span class="line">			TimeUnit.MINUTES);<span class="comment">// org.redisson.client.protocol.RedisCommands.PSETEX</span></span><br><span class="line">	System.out.println(hello.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis中所有的key都是String类型，而一些对象的存储，都是把对象序列化成为字符串进行存储。</p>
<p>string作为redis中的最基础的数据类型，redis做了极致的优化，这个我们后面再说。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是redis中列表的数据结构。说实话，在工作中使用的比较少。可以用来做一个简单的消息队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">	RedissonList&lt;Person&gt; list = (RedissonList) redissonClient.getList(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">	<span class="type">Person</span> <span class="variable">tom</span> <span class="operator">=</span> Person.tom();</span><br><span class="line">	list.add(tom);<span class="comment">// RPUSH</span></span><br><span class="line">	list.addBefore(tom, <span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">	list.readAll(); <span class="comment">// LRANGE</span></span><br><span class="line">	list.fastSet(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">	System.out.println(list.size());</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把redis中的list，在Java中，当成LinkedList操作（插入、删除快；查找慢）。 使用简单方便。</p>
<p>list的底层是一个叫快速列表的数据结构（quick list）。</p>
<p>如果所示，它是由ziplist组成，ziplist是压缩列表，是紧凑的，再用link给串起来。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/image.png"></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash，map，dict，说的都是一个东西，在Java中，我们叫做<code>HashMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span> &#123;</span><br><span class="line">	RedissonMap&lt;String, Object&gt; myMap = (RedissonMap) redissonClient.getMap(<span class="string">&quot;myMap&quot;</span>);</span><br><span class="line">	myMap.put(<span class="string">&quot;Tom&quot;</span>, Person.tom());</span><br><span class="line">	RedissonMap&lt;String, Object&gt; map = (RedissonMap) redissonClient.getMap(<span class="string">&quot;myMap&quot;</span>);</span><br><span class="line">	System.out.println(map.get(<span class="string">&quot;Tom&quot;</span>)); <span class="comment">// HGET</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用和Java无二。 当我们使用Map缓存数据时候，我们可以部分的获取一些字段，不用把整个对象都拿出来。</p>
<p>注意：一整个Map能设置过期删除。Map中单独的key-value是设置不了过期删除的。</p>
<p>和Java中<code>HashMap</code>不同的是，扩容rehash的过程中，redis当中是渐进式的，可能同时出现两个map。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>redis中的set和Java中的HashSet类型。使用方法也类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">	RSet&lt;Object&gt; set = redissonClient.getSet(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">	set.add(<span class="number">1</span>);</span><br><span class="line">	set.add(<span class="number">2</span>);</span><br><span class="line">	set = redissonClient.getSet(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">		System.out.println(o);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工作中使用的也不错，可以计算一些UV。</p>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>sort set，排序集合，redis特色结构。</p>
<p>在set的基础上，给每个value加上了分数，在zset中的值都是按照分数排好序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZSet</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZSet</span><span class="params">()</span> &#123;</span><br><span class="line">	RSortedSet&lt;Object&gt; zset = redissonClient.getSortedSet(<span class="string">&quot;zset&quot;</span>);</span><br><span class="line">	zset.add(<span class="number">1</span>);</span><br><span class="line">	zset.add(<span class="number">2</span>);</span><br><span class="line">	zset.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">	RScoredSortedSet&lt;Object&gt; szset = redissonClient.getScoredSortedSet(<span class="string">&quot;szset&quot;</span>);</span><br><span class="line">	szset.add(<span class="number">11.1</span>, <span class="number">1</span>);<span class="comment">// ZADD</span></span><br><span class="line">	szset.add(<span class="number">1.1</span>, <span class="number">2</span>);</span><br><span class="line">	szset.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zset底层使用的跳跃表（skip list），具体后面再说。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/1653463112036-image.png"></p>
<p>主要的作用是可以做一些排行榜，像微博热搜。</p>
<hr>
<p>这篇文章我们讲到了如果搭建一个redis环境，并使用<code>redisson</code>对redis做一些基本操作。</p>
<p>在下一篇文章中，我们将讲到redis中的一些高级数据结构。</p>
<ul>
<li>位图</li>
<li>布隆过滤器</li>
<li>队列</li>
<li>分布式锁</li>
<li>限流器</li>
<li>HyperLogLog</li>
<li>Geo</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>redisson</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL调优</title>
    <url>/2021/09/11/MySQL%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章，我们将谈到SQL优化的相关知识。</p>
<ul>
<li>我们会讲到如何合理定义数据结构</li>
<li>如何设计高效的索引</li>
<li>如果写出高效的SQL语句</li>
<li>如果发生了慢查询，我们如何分析</li>
<li>如何选择其他的组件来替换MySQL</li>
</ul>
<p>现在，我们开始吧！！</p>
<span id="more"></span>

<h2 id="数据结构的优化"><a href="#数据结构的优化" class="headerlink" title="数据结构的优化"></a>数据结构的优化</h2><h3 id="数据类型的选择"><a href="#数据类型的选择" class="headerlink" title="数据类型的选择"></a>数据类型的选择</h3><h4 id="使用最佳的数据类型"><a href="#使用最佳的数据类型" class="headerlink" title="使用最佳的数据类型"></a>使用最佳的数据类型</h4><p>数据类型越短越好，<br>越小的数据类型，往往意味着更好的效率。</p>
<p>整型的效率会比字符串的性能高<br>使用Date类型来存储时间，比字符串类型的效率来的高。</p>
<h4 id="尽量使用非空"><a href="#尽量使用非空" class="headerlink" title="尽量使用非空"></a>尽量使用非空</h4><p>null会影响到索引效率，查询的返回结果。<br>可会可能引发业务层的空指针。</p>
<p>我们可以给字段设为not null，且设定一个默认值。</p>
<h4 id="可以使用UNSIGNED来修饰数字类型"><a href="#可以使用UNSIGNED来修饰数字类型" class="headerlink" title="可以使用UNSIGNED来修饰数字类型"></a>可以使用UNSIGNED来修饰数字类型</h4><p>无符号数字的存储效率是有符号数组的将近一倍。</p>
<p>比如ID，金额等一些确定是正数的数字类型，<br>我们可以使用UNSIGNED来修饰。</p>
<h3 id="表的设计"><a href="#表的设计" class="headerlink" title="表的设计"></a>表的设计</h3><h4 id="避免宽表"><a href="#避免宽表" class="headerlink" title="避免宽表"></a>避免宽表</h4><p>宽表意味着一条记录有很多字段。<br>我们尽量避免一张表有多于100个字段。</p>
<p>他会在查询的时候，增加性能的负担。<br>尤其是使用alter操作来改变表结构的时候，<br>会非常消耗性能。</p>
<p>我们可以给一张宽表拆分成不同的小表。<br>比如：一张订单表，我们可以拆分成<br>订单主表；订单金额表；订单商品表；订单物流表 等等。</p>
<h4 id="范式-and-反范式"><a href="#范式-and-反范式" class="headerlink" title="范式 and 反范式"></a>范式 and 反范式</h4><p>满足范式的设计，往往会更加精简，<br>但是如果需要查询更多的信息，需要连表查询。</p>
<p>比如说，订单表里面只有买家ID这个字段，<br>在页面上展示的时候，往往是需要展示买家名称，<br>这个时候，就需要连表查询，关联订单表，和客户表，<br>而在我们分布式系统中，更需要单独调用别的中台的接口，来填充信息。</p>
<p>而反范式，就是把一些数据给冗余下来，以提高查询效率。</p>
<p>在高并发，高性能，高数据量的时候，<br>往往都是单表查询，<br>反范式，冗余会使用的更多。<br>冗余可以大大简化我们的SQL，提高我们索引的命中率。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><blockquote>
<p>好的索引，是查询效率提升的关键</p>
</blockquote>
<h3 id="什么时候添加索引"><a href="#什么时候添加索引" class="headerlink" title="什么时候添加索引"></a>什么时候添加索引</h3><p>如果我们表的数据只有十几行甚至几行的时候，<br>我们不要添加索引。<br>因为这个时候，全表扫描的效率往往更好，<br>而索引的维护，还会影响到数据的修改效率。</p>
<p>如果我们的表数据量很多，<br>我们推荐设计合适的索引来提高查询效率。</p>
<p>如果我们的表数据非常非常多，<br>我们考虑使用分区，分表</p>
<h3 id="添加合适的索引"><a href="#添加合适的索引" class="headerlink" title="添加合适的索引"></a>添加合适的索引</h3><p>在查询条件上，<br>在关联字段上，<br>在排序字段上，<br>在分组字段上，<br>可以添加索引。</p>
<p>添加索引的字段值区分度越高越好，比如ID<br>像枚举类型的值不适合设置成索引。</p>
<p>索引不是越多越好，索引会占用空间，索引会影响修改数据的效率。</p>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>根据业务中的查询条件，添加合适的组合索引<br>遵循最左匹配原则</p>
<h3 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> buyer_id <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> buyer_id <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>如果我们在订单表（order）中的买家ID（buyer_id）上建立索引，</p>
<p>上面第一条的SQL会比第二条的执行速度快很多。</p>
<p>因为第一条索引直接走了覆盖索引，而不用回表查询，大大提高效率。</p>
<h3 id="精简索引字段"><a href="#精简索引字段" class="headerlink" title="精简索引字段"></a>精简索引字段</h3><p>如果索引字段太长，且有很多重复的字符，我们可以截取一部分来设成索引。</p>
<p>可以减少索引体积。</p>
<p>比如说email，或者网站地址，或者非常长的ID</p>
<p>把区分度高的部分，截取出来，设成索引。</p>
<h2 id="SQL语句编写的优化"><a href="#SQL语句编写的优化" class="headerlink" title="SQL语句编写的优化"></a>SQL语句编写的优化</h2><h3 id="基础SQL原则"><a href="#基础SQL原则" class="headerlink" title="基础SQL原则"></a>基础SQL原则</h3><ul>
<li>只返回必要的行，避免<code>select *</code>这样的语句。</li>
<li>where条件里面控制范围</li>
<li>limit 控制返回条数</li>
<li>缓存热点数据，使用服务端缓存（redis），避免使用MySQL缓存</li>
<li>查询条件 和 索引相匹配</li>
</ul>
<h3 id="count函数优化"><a href="#count函数优化" class="headerlink" title="count函数优化"></a>count函数优化</h3><p>一般来说，我们尽量使用<code>count(*)</code>，来统计行数，<br>但是还有一种用法，我们可以使用<code>count(column_1)</code>来统计，column_1不为空的记录数。</p>
<p>在column_1不为空的情况下：<br>count(*) &#x3D;&#x3D; count(column_1)</p>
<p>在column_1有null值的情况下：<br>count(*) &gt; column_1</p>
<p>这点需要大家注意区别。</p>
<p>在不需要准确数据的情况下，<br>我们可以使用 explain 来替代 count。</p>
<p>explain会给出一个总数目的估计值，<br>explain只会给出一个查询计划，并不会真正去存储引擎上执行，<br>它的执行效率是高的。</p>
<h3 id="避免深分页"><a href="#避免深分页" class="headerlink" title="避免深分页"></a>避免深分页</h3><p>我们要避免这样的SQL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> limit <span class="number">1000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这样会先把前面的1010条数据都查询出来，在截取后10条记录返回。<br>很营销效率。</p>
<p>在这种情况下，我会推荐使用游标的来查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="string">&#x27;&#x27;</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分解大批量"><a href="#分解大批量" class="headerlink" title="分解大批量"></a>分解大批量</h3><p>如果我们需要清楚历史日志数据，我们可能会这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> log <span class="keyword">where</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果历史数据非常大，这样会非常影响数据库的性能，<br>并会锁住很多记录，占用系统资源。</p>
<p>可能会让很多小而重要的查询发生中断。</p>
<p>我们需要这样做：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> log <span class="keyword">where</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;&#x27;</span> limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>
<p>并在业务代码中，循环删除。</p>
<h2 id="慢查询及其分析"><a href="#慢查询及其分析" class="headerlink" title="慢查询及其分析"></a>慢查询及其分析</h2><p>我们可以开启这个配置</p>
<h3 id="开启慢查询监控"><a href="#开启慢查询监控" class="headerlink" title="开启慢查询监控"></a>开启慢查询监控</h3><h3 id="使用EXPLAIN来分析SQL执行计划"><a href="#使用EXPLAIN来分析SQL执行计划" class="headerlink" title="使用EXPLAIN来分析SQL执行计划"></a>使用EXPLAIN来分析SQL执行计划</h3><h2 id="使用其他的组件来替代MySQL"><a href="#使用其他的组件来替代MySQL" class="headerlink" title="使用其他的组件来替代MySQL"></a>使用其他的组件来替代MySQL</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高级数据结构</title>
    <url>/2021/04/26/Redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章介绍一下高级Redis数据结构，及其用法。</p>
<p>在工作的使用频率很高。</p>
<ul>
<li>分布式锁</li>
<li>队列</li>
<li>位图</li>
<li>布隆过滤器</li>
<li>HyperLogLog</li>
<li>限流器</li>
<li>GeoHash</li>
</ul>
<span id="more"></span>

<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>大家都知道，线程安全在我们的系统当中，非常重要。<br>如果多个线程同时操作一笔订单，很可能造成数据不一致。</p>
<p>而在分布式系统中，<code>synchronized</code>就排不上用场了，需要使用分布式锁来解决线程安全的问题。</p>
<p>而使用redis就是一个很好的选择。</p>
<p>使用<code>Redisson</code>封装的分布式锁，非常简单，功能也相当强大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;my-lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了基础的分布式锁，Redisson还提供了：</p>
<ul>
<li>可重入锁</li>
<li>公平锁</li>
<li>自旋锁</li>
<li>读写锁</li>
<li>锁超时时间</li>
<li>获取锁的时间限制</li>
</ul>
<p>功能强大且使用方便，具体参考<a href="https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers">官方文档</a>。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是我们一种常用的数据结构。也有很多专业的中间件来实现。比如：Kafka，RabbitMQ，RocketMQ。。。<br>而redis也支持消息队列，而且功能还不少。有：</p>
<ul>
<li>简单的消息队列</li>
<li>延迟队列</li>
<li>阻塞队列</li>
<li>消息的多播</li>
</ul>
<p>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用<code>rpush/lpush</code>操作入队列，使用 <code>lpop/rpop</code> 来出队列。</p>
<p>延时队列可以通过 Redis 的 zset(有序列表) 来实现。我们将消息序列化成一个字符串作为 zset 的 value，这个消息的到期处理时间作为 score。</p>
<p>Redisson对此都有很好的支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单队列</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simple</span><span class="params">()</span> &#123;</span><br><span class="line">    RQueue&lt;Object&gt; queue = redissonClient.getQueue(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (poll == <span class="literal">null</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(poll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    RBlockingQueue&lt;Object&gt; queue = redissonClient.getBlockingQueue(<span class="string">&quot;block&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                queue.put(i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 阻塞take</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">poll</span> <span class="operator">=</span> queue.take();</span><br><span class="line">        System.out.println(poll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟队列</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delayQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    RBlockingQueue&lt;Object&gt; blockingQueue = redissonClient.getBlockingQueue(<span class="string">&quot;delayQueue1&quot;</span>);</span><br><span class="line">    RDelayedQueue&lt;Object&gt; delayQueue = redissonClient</span><br><span class="line">            .getDelayedQueue(blockingQueue);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        delayQueue.offerAsync(i, (<span class="number">500</span> - i * <span class="number">10</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blockingQueue = redissonClient.getBlockingQueue(<span class="string">&quot;delayQueue&quot;</span>);</span><br><span class="line">    System.out.println(blockingQueue.size());</span><br><span class="line">    redissonClient.getDelayedQueue(blockingQueue);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; blockingQueue.size(); i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">poll</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">        System.out.println(poll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上都是消息队列的<code>生产者-消费者模式</code>，而消息队列的另外一种模式<code>订阅模式</code>，redis也能实现。</p>
<p>有两种数据结构支持。</p>
<ul>
<li>PubSub</li>
<li>Stream</li>
</ul>
<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>位图完全是为了节约空间而设计的，我们可以把它想象成一个巨大的List，而里面只存放<code>1/0</code>。</p>
<p>比如记录一个用户一年的签到记录，我们可以用位图来记录，签到的就是<code>1</code>，未签到的是<code>0</code>。</p>
<p>使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RBitSet</span> <span class="variable">bitset</span> <span class="operator">=</span> redissonClient.getBitSet(<span class="string">&quot;bitset&quot;</span>);</span><br><span class="line">    bitset.set(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    System.out.println(bitset.get(<span class="number">0</span>));</span><br><span class="line">    System.out.println(bitset.get(<span class="number">1</span>));</span><br><span class="line">    System.out.println(bitset.incrementAndGetInteger(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>我们如何判断一个ID是否在我们的系统里。我们有两种基本的方法来判断：</p>
<ul>
<li>我们把这个ID拿到数据查询一下就知道来</li>
<li>我们把所有的ID保存的一个Set里面，判断这个新的ID在不在这个Set里面</li>
</ul>
<p>但是上面两种方法有一个致命的缺陷：<br>就是在数据量特别大的时候，非常消耗性能，不管是对数据库的IO，还是保存所有的ID。</p>
<p>这个是有个非常精妙的算法 - <code>布隆过滤器</code>。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/HeAOem.png"></p>
<p>它的原理非常简单：<br>底层是一个位图，并且有若干种Hash算法。<br>在新增ID的时候，对每一个ID做多种Hash运算，并在位图中得到若干位置，把对应的位置变成<code>1</code>。<br>而判断一个ID是否在系统中，也对这个ID做同样的Hash运算，得到若干位置，判断位图中的对应位置是否都是<code>1</code>。<br>如果都是<code>1</code>的话，表示大概率可能存在于系统中，如果有一个<code>0</code>，表示肯定不在系统中。</p>
<p>Redisson也做了封装，使用非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    RBloomFilter&lt;String&gt; bloom = redissonClient.getBloomFilter(<span class="string">&quot;bloom&quot;</span>);</span><br><span class="line">    bloom.tryInit(<span class="number">1000</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        bloom.add(<span class="string">&quot;user_id_&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">80</span>; i &lt; <span class="number">120</span>; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> bloom.contains(<span class="string">&quot;user_id_&quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;user_id_&quot;</span> + i + <span class="string">&quot;  -&gt;  &quot;</span> + contains);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog是一个很神奇的数据结构。</p>
<p>我们先来说两个概念： PV 和 UV。<br>PV：简单来说就是流量。只要有一次访问，不管是不是同一个人，就记一个流量。<br>UV：独立访客，单位时间内，一个新的访客，就算一个UV。</p>
<p>在我们的统计中，PV很好统计，来一次访问，PV值就往上加1，顶多需要保持一下自增的原子性。<br>而计算UV，在互联网领域中一个是一个难题。</p>
<p>通常来说我们计算一个网站一天的UV，我们需要把每一个访客的ID给记录下来，计算时去重。<br>这样就导致一个问题，如果访问量非常大，就非常的消耗存储空间。</p>
<p>这个时候，HyperLogLog就能派上用场了。</p>
<p>我们先看下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compareTest</span><span class="params">()</span> &#123;</span><br><span class="line">    RHyperLogLog&lt;String&gt; today = redisson.getHyperLogLog(<span class="string">&quot;UV_&quot;</span> + LocalDate.now());</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;id_&quot;</span> + random.nextInt(<span class="number">500</span>);</span><br><span class="line">        today.add(userId);</span><br><span class="line">        set.add(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;RHyperLogLog: &quot;</span> + today.count());</span><br><span class="line">    System.out.println(<span class="string">&quot;set count: &quot;</span> + set.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的Set方法，和HyperLogLog，两个做一个比较。<br>从结果可以看出，两者的差距非常小，但是HyperLogLog并没有把每一个ID都记录下来，节约了大量存储空间。</p>
<p>HyperLogLog的原理相对复杂，具体可以参考这篇<a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">论文</a>。</p>
<p>这里我来介绍一下它的思想：<br>假设我们有两个网站，需要比较一下他们的UV，看哪个网站的访问率高。<br>假设访问用户的ID使用手机号码表示，如：1xxxxxxxxxx<br>我们不想把每个访客的手机号码都记录下来，因为太浪费存储空间了。<br>我们可以定一个规则，我们只记录当天客户中，手机尾号为<code>0</code>位数最高的手机号码。<br>比如说，第一个网站记录下来的手机号码是：18322333000，末尾有3个0，<br>而第二的网站记录下来的手机号码是：18623000000，末尾有6个0。<br>我们就可以判断出，第二的网站的访问的人数更多。<br>大家体会一下。</p>
<p>HyperLogLog还有一个重要的概念，就是合并。<br>我们可以把连续7天的UV，合并成这一周的UV，并保证准确性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTest</span><span class="params">()</span> &#123;</span><br><span class="line">    RHyperLogLog&lt;String&gt; today = redisson.getHyperLogLog(<span class="string">&quot;UV_&quot;</span> + LocalDate.now());</span><br><span class="line">    RHyperLogLog&lt;String&gt; nextDay = redisson.getHyperLogLog(<span class="string">&quot;UV_&quot;</span> + LocalDate.now().plusDays(<span class="number">1</span>));</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;id_&quot;</span> + random.nextInt(<span class="number">1000</span>);</span><br><span class="line">        today.add(userId);</span><br><span class="line">        set.add(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;id_&quot;</span> + random.nextInt(<span class="number">2000</span>);</span><br><span class="line">        nextDay.add(userId);</span><br><span class="line">        set.add(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    today.mergeWith(nextDay.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;RHyperLogLog: &quot;</span> + today.count());</span><br><span class="line">    System.out.println(<span class="string">&quot;set count: &quot;</span> + set.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限流器"><a href="#限流器" class="headerlink" title="限流器"></a>限流器</h2><p>限流器在我们的生产中非常重要，也很常用。Redis也有封装好的限流器。<br>实现了分布式限流器的功能。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// redisson用了zset来记录请求的信息，这样可以非常巧妙的通过比较score，也就是请求的时间戳，来判断当前请求距离上一个请求有没有超过一个令牌生产周期。</span></span><br><span class="line">    <span class="comment">// 如果超过了，则说明令牌桶中的令牌需要生产，之前用掉了多少个就生产多少个，而之前用掉了多少个令牌的信息也在zset中保存了。</span></span><br><span class="line">    <span class="type">RRateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;limiter_1&quot;</span>);</span><br><span class="line">    <span class="comment">// 1号限流器， 每一秒 允许一个请求</span></span><br><span class="line">    limiter.trySetRate(RateType.PER_CLIENT, <span class="number">1</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 阻塞</span></span><br><span class="line"><span class="comment">//			limiter.acquire(1);</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> limiter.tryAcquire(<span class="number">1</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="comment">// 快速失败</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; failed !&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; -&gt; &quot;</span> + LocalDateTime.now());</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">12000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Redisson真好用！</p>
</blockquote>
<h2 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h2><p>Redis也提供了Geo功能，可以很方便实现附近的人，两坐标之间的距离等功能。<br>它的原理是把经纬度坐标，做Hash，得到一个分数，用zset做存储。<br>Hash算法的原理，是把整个地球当作一个平面，并把这个平面切割成很多很多的小块，并对每个方块做编码。<br>如果两个点所在的方块越接近，表示这两个点越接近。 当然，有一点点误差。<br>使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    RGeo&lt;Object&gt; geo = redissonClient.getGeo(<span class="string">&quot;geo&quot;</span>);</span><br><span class="line">    <span class="type">GeoEntry</span> <span class="variable">juejin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeoEntry</span>(<span class="number">116.48105</span>, <span class="number">39.996794</span>, <span class="string">&quot;juejin&quot;</span>);</span><br><span class="line">    geo.add(juejin);</span><br><span class="line">    geo.add(<span class="number">116.514203</span>, <span class="number">39.905409</span>, <span class="string">&quot;ireader&quot;</span>);</span><br><span class="line">    geo.add(<span class="number">116.489033</span>, <span class="number">40.007669</span>, <span class="string">&quot;meituan&quot;</span>);</span><br><span class="line">    geo.add(<span class="number">116.562108</span>, <span class="number">39.787602</span>, <span class="string">&quot;jd&quot;</span>);</span><br><span class="line">    geo.add(<span class="number">116.334255</span>, <span class="number">40.027400</span>, <span class="string">&quot;xiaomi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两点距离</span></span><br><span class="line">    System.out.println(geo.dist(<span class="string">&quot;meituan&quot;</span>, <span class="string">&quot;jd&quot;</span>, GeoUnit.METERS));</span><br><span class="line">    <span class="comment">// 坐标</span></span><br><span class="line">    System.out.println(geo.pos(<span class="string">&quot;xiaomi&quot;</span>));</span><br><span class="line">    <span class="comment">// hash</span></span><br><span class="line">    System.out.println(geo.hash(<span class="string">&quot;ireader&quot;</span>));</span><br><span class="line">    <span class="comment">// 附近</span></span><br><span class="line">    System.out.println(geo.radiusWithPositionAsync(<span class="string">&quot;jd&quot;</span>, <span class="number">20</span>, GeoUnit.KILOMETERS).get());</span><br><span class="line">    <span class="comment">// 附近</span></span><br><span class="line">    System.out.println(</span><br><span class="line">            geo.radiusWithPositionAsync(<span class="number">116.334255</span>, <span class="number">40.027400</span>, <span class="number">20</span>, GeoUnit.KILOMETERS).get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： 在一个地图应用中，车的数据、餐馆的数据、人的数据可能会有百万千万条，<br>如果使用Redis 的 Geo 数据结构，它们将全部放在一个 zset 集合中。<br>在 Redis 的集群环境中，集合可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成较大的影响，<br>在集群环境中单个 key 对应的数据量不宜超过 1M，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。<br>所以，这里建议 Geo 的数据使用单独的 Redis 实例部署，不使用集群环境。<br>如果数据量过亿甚至更大，就需要对 Geo 数据进行拆分，按国家拆分、按省拆分，按市拆分，在人口特大城市甚至可以按区拆分。<br>这样就可以显著降低单个 zset 集合的大小。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们一起学习了7种高级结构</p>
<ul>
<li>分布式锁</li>
<li>队列</li>
<li>位图</li>
<li>布隆过滤器</li>
<li>HyperLogLog</li>
<li>限流器</li>
<li>GeoHash<br>希望以后大家能在工作中用到。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>redis</tag>
        <tag>redisson</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2021/07/06/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天开启我们的算法系列，争取说简单➕通俗易懂。<br>我们从经典的排序算法开始。学习十大排序算法。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/zoOH3H.png"></p>
<p>排序算法可以分为两大类：基于比较的排序 and 不基于比较的排序。<br>基于比较的排序，是通过元素间的两两比较，来判断大小，继而排序。<br>不基于比较的排序，就是通过各种其他的方法，来让元素排序。</p>
<p>在表格中，上面的7种都是基于比较的排序算法。下3种是不基于比较的排序。</p>
<p>接下来我们一个一个的来仔细看。</p>
<span id="more"></span>

<h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><p>首先，我们来说说最简单的冒泡排序。</p>
<p>大家可以想象一下，在小学的时候，第一节体育课，老师给我们按照身高排成一列。</p>
<p>就是相邻的两个同学比较一下身高，让后把高的放右边，矮的站左边。</p>
<p>冒泡排序就是这样，从左往右遍历，相邻的两个元素进行比较，大的放右边，小的放左边。</p>
<p>这样一次遍历之后，最右边的元素肯定是最大的。</p>
<p>再进行n次遍历，就可以把整个队列排好序了。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015223238449-2146169197.gif"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 两次循环，相邻的两个元素比较，小的往前</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * O(n2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="comment">// 注意边界， 不用到最后一个</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">						SortUtil.swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h2><p>选择排序思路也很简单，我们把队列分成两个部分。</p>
<p>一部分是乱序的，就是我们一开始的样子。</p>
<p>一部分是有序的。</p>
<p>我们先在乱序的队列里面找到一个最小的元素，放到有序的队列里面。</p>
<p>再在乱序的队列里面找一个最小的元素，依次放到有序队列里面。</p>
<p>直到乱序的队列里面一个元素都没有了。</p>
<p>这样，有序的队列就是我们最终的结果。</p>
<p>为了节省空间，我们可以在一个数组里面，存下这两个队列。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015223238449-2146169197.gif"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序， 每次循环找出最小值，往前面换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="type">int</span> minIndex;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				minIndex = i;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">						minIndex = j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				SortUtil.swap(nums, i, minIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h2><p>插入排序也很好理解。</p>
<p>相信大家都打过扑克牌，每次我们一开始摸牌都时候，都是一次插入排序都过程。</p>
<p>同样有两个队列，一个乱序，一个有序。</p>
<p>每次我们从乱序都队列里面拿出一张牌，再插入到有序队列里面合适到地方。</p>
<p>这就是插入排序。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015225645277-1151100000-2.gif"></p>
<p>请看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序， 找到一个元素，向前扫描，前面但往后移动，在合适但地方插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> nums;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 1   3   2</span></span><br><span class="line">			<span class="comment">//     j   i</span></span><br><span class="line">			<span class="comment">// 1   2   3</span></span><br><span class="line">			<span class="comment">// j       i</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">indexValue</span> <span class="operator">=</span> nums[i];</span><br><span class="line">				<span class="comment">// 往左扫描</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">					<span class="comment">// 如果indexValue比较小，j往右移动</span></span><br><span class="line">					<span class="comment">// 同时把 i的值填充进去</span></span><br><span class="line">					<span class="keyword">if</span> (indexValue &lt; nums[j]) &#123;</span><br><span class="line">						nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">						nums[j] = indexValue;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 已经找到比当前小的了， 跳出此轮循环</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><p>希尔排序，顾名思义，它是一个名叫希尔的人发明的，第一个个时间复杂的图片O(n2)排序。</p>
<p>它是插入排序的一个变种，但是它的实现相对复杂。</p>
<p>为了帮助大家理解，我们先看一下<strong>插入排序</strong>的动图。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015225645277-1151100000-2.gif"></p>
<p>大家有没有发现，每一次插入的过程，基本上都要移动好几个元素。大小相似的元素往往相隔的比较远。</p>
<p>为了优化这个过程，希尔选择了先把整个队列按照间隔分组，分别进行插入排序。</p>
<p>然后间隔原来越小，当间隔为1的时候，就是一次正常的插入排序。</p>
<p>这样在前期的准备中，大小相似的元素，相邻的都比较近了，可以提高最终排序的效率。</p>
<p>动图如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20180331170017421-364506073.gif"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序：</span></span><br><span class="line"><span class="comment"> * 1 按照间隔分组（初始间隔一般是数组长度的一半）</span></span><br><span class="line"><span class="comment"> * 2 排序每个组（插入排序法）</span></span><br><span class="line"><span class="comment"> * 3 间隔减小，重新分组（新的间隔一般为原间隔的一般，最后为1）</span></span><br><span class="line"><span class="comment"> * 4 再排序每个组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">interval</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">while</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				insertSortByInterval(nums, interval);</span><br><span class="line">				interval = interval / <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSortByInterval</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> interval)</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interval; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + interval; j &lt; nums.length; j += interval) &#123;</span><br><span class="line">					insertSortByInterval(nums, j, interval);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//  0  x  x  2  x  x  3  x  x  1  x  x</span></span><br><span class="line">		<span class="comment">//                    i        s</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSortByInterval</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex, <span class="type">int</span> interval)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> nums[startIndex];</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex - interval;</span><br><span class="line">			<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; value) &#123;</span><br><span class="line">				nums[i + interval] = nums[i];</span><br><span class="line">				nums[i] = value;</span><br><span class="line">				i -= interval;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h2><p>如果你是程序员的化，归并排序也很好理解。</p>
<p>它主要采用分治的思想，使用递归。 化繁为简。</p>
<p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="keyword">return</span> mergeSort(nums);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 递归方法</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="comment">// 递归出口</span></span><br><span class="line">			<span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> nums;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 分成两个数组</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line">			<span class="type">int</span>[] left = Arrays.copyOfRange(nums, <span class="number">0</span>, m);</span><br><span class="line">			<span class="type">int</span>[] right = Arrays.copyOfRange(nums, m, nums.length);</span><br><span class="line">			<span class="comment">// 对这两个数组做排序</span></span><br><span class="line">			left = mergeSort(left);</span><br><span class="line">			right = mergeSort(right);</span><br><span class="line">			<span class="comment">// 合并这两个排序好的数组</span></span><br><span class="line">			<span class="keyword">return</span> mergeSort(left, right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对两个排序好的数组做合并</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] left, <span class="type">int</span>[] right) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> left.length + right.length;</span><br><span class="line">			<span class="type">int</span>[] merged = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">			<span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">0</span>, rightIndex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">leftValue</span> <span class="operator">=</span> left[leftIndex];</span><br><span class="line">					<span class="type">int</span> <span class="variable">rightValue</span> <span class="operator">=</span> right[rightIndex];</span><br><span class="line">					<span class="keyword">if</span> (leftValue &lt; rightValue) &#123;</span><br><span class="line">						merged[i] = leftValue;</span><br><span class="line">						leftIndex++;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						merged[i] = rightValue;</span><br><span class="line">						rightIndex++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftIndex &gt;= left.length) &#123;</span><br><span class="line">					merged[i] = right[rightIndex];</span><br><span class="line">					rightIndex++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					merged[i] = left[leftIndex];</span><br><span class="line">					leftIndex++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> merged;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>动图如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015230557043-37375010.gif"></p>
<h2 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h2><p>重点！ 重点～ 重点。。。<br>快速排序非常重要‼️</p>
<p>它的思想是：设立一个基准，把小于基准的移动到左边，把大于基准的移动到右边。</p>
<p>在把左边小于基准的子队列，再设立一个基准，再移动，右边同理。</p>
<p>使用递归，直至子队列的长度小于2。</p>
<p>先来个带辅助空间的快速排序的实现，很简单，大家体会下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用List，带辅助空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">		List&lt;Integer&gt; list = quickSort(</span><br><span class="line">				Arrays.stream(nums).boxed().collect(Collectors.toList()));</span><br><span class="line">		<span class="keyword">return</span> list.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 快速排序递归方法</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">quickSort</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">		<span class="comment">// 递归出口</span></span><br><span class="line">		<span class="keyword">if</span> (list.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 随便找一个基准，这里取的是第一个元素</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">pivot</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 辅助空间</span></span><br><span class="line">		List&lt;Integer&gt; low = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; high = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; equal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 结果集合</span></span><br><span class="line">		List&lt;Integer&gt; sorted = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 大于基准的集合；小于基准的集合；等于基准的集合</span></span><br><span class="line">		<span class="keyword">for</span> (Integer item : list) &#123;</span><br><span class="line">			<span class="keyword">if</span> (item.equals(pivot)) &#123;</span><br><span class="line">				equal.add(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item &lt; pivot) &#123;</span><br><span class="line">				low.add(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				high.add(item);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 递归</span></span><br><span class="line">		low = quickSort(low);</span><br><span class="line">		high = quickSort(high);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 合并</span></span><br><span class="line">		sorted.addAll(low);</span><br><span class="line">		sorted.addAll(equal);</span><br><span class="line">		sorted.addAll(high);</span><br><span class="line">		<span class="keyword">return</span> sorted;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不带辅助空间的算法实现起来比较复杂，但是思想一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in-place</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">		sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> nums;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> pivotDivision(nums, left, right);</span><br><span class="line"></span><br><span class="line">		sort(nums, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">		sort(nums, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照基准  左右划分</span></span><br><span class="line">	<span class="comment">// 3  2  6  5  4</span></span><br><span class="line">	<span class="comment">// 3  2  4  6  5</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pivotDivision</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">		<span class="comment">// 默认给最右边的值 为基准</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[right];</span><br><span class="line">		<span class="comment">// 初始化，基准Index</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> left;</span><br><span class="line">		<span class="comment">// 把子数组遍历一遍</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">			<span class="comment">// 如果比 基准小  替换到前面  基准Index++</span></span><br><span class="line">			<span class="keyword">if</span> (nums[i] &lt;= pivot) &#123;</span><br><span class="line">				SortUtil.swap(nums, i, pivotIndex);</span><br><span class="line">				pivotIndex++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 最后再把 基准放到中间来</span></span><br><span class="line">		SortUtil.swap(nums, right, pivotIndex);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pivotIndex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后我们看下动图：<br>黄色的元素是基准<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015230936371-1413523412.gif"></p>
<h2 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h2><p>堆排序，就比较不好想了，它的思路是把数组转换成二叉树。对，没错。</p>
<p>把数组当成一个二叉树。</p>
<p>然后对二叉树进行递归比较，把较大对元素放到根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1. 把数组抽象成二叉树</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * 2. 每个子树做堆化操作，比较根元素和子元素，交换位置，保持根元素最大</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * 3. 循环，保持整棵树的根元素最大</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * 4. 把根元素放到最后</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 7  6  5  2  3  4  1</span></span><br><span class="line">		<span class="comment">//          7</span></span><br><span class="line">		<span class="comment">//         /  \</span></span><br><span class="line">		<span class="comment">//        5    2</span></span><br><span class="line">		<span class="comment">//       / \  /</span></span><br><span class="line">		<span class="comment">//      3  4  1</span></span><br><span class="line">		<span class="comment">//  左边叶子节点的位置 = 根节点的位置 * 2 + 1</span></span><br><span class="line">		<span class="comment">//  右边叶子节点的位置 = 根节点的位置 * 2 + 2</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				<span class="comment">// 堆化</span></span><br><span class="line">				heapify(nums, i);</span><br><span class="line">				<span class="comment">// 此时root已经最大，把root移动到后面</span></span><br><span class="line">				SortUtil.swap(nums, <span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从后往前比较每一个节点</span></span><br><span class="line">		<span class="comment">// 类似一个冒泡的过程，把最大的值给冒上来</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				checkRootValueBeMax(nums, j, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 保证根节点 元素最大  左边节点，第二大   右边节点最小</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkRootValueBeMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> rootIndex, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> rootIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> rootIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (leftIndex &lt; limit &amp;&amp; nums[leftIndex] &gt; nums[rootIndex]) &#123;</span><br><span class="line">				SortUtil.swap(nums, leftIndex, rootIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rightIndex &lt; limit &amp;&amp; nums[rightIndex] &gt; nums[rootIndex]) &#123;</span><br><span class="line">				SortUtil.swap(nums, rightIndex, rootIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (leftIndex &lt; nums.length &amp;&amp;</span><br><span class="line">					rightIndex &lt; nums.length &amp;&amp;</span><br><span class="line">					nums[leftIndex] &gt; nums[rightIndex]) &#123;</span><br><span class="line">				SortUtil.swap(nums, leftIndex, rightIndex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>动图如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015231308699-356134237.gif"></p>
<h2 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h2><p>从这种排序算法开始，后面3种算法，就都是不依靠比较的排序算法了。</p>
<p>计数排序就是其中之一。</p>
<p>计数排序的核心，就是定义一个计数数组，记录每个数出现的次数。</p>
<p>如果有一个待排序的数组如：[ 5, 3, 3, 2, 6, 7, 8, 9, 0, 4 ]，最大值为10。</p>
<p>那么我们的计数数组填充完毕后的样子就是：[ 1, 0, 1, 2, 1, 1, 1, 1, 1, 1 ]</p>
<p>最后再通过计数数组，生成一个排好序的数组作为结果。</p>
<p>大家发现没有，这里面并没有想之前一样，元素之间两两比较大小。</p>
<p>在看下动图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015231740840-6968181.gif"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [ 5, 3, 3, 2, 6, 7, 8, 9, 0, 4 ]   , 10</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums, <span class="type">int</span> maxValue) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 定义计数数组</span></span><br><span class="line">			<span class="type">int</span>[] countingArray = <span class="keyword">new</span> <span class="title class_">int</span>[maxValue];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 把 nums 存放到计数数组中</span></span><br><span class="line">			<span class="comment">// [ 1, 0, 1, 2, 1, 1, 1, 1, 1, 1 ]</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> value : nums) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> countingArray[value];</span><br><span class="line">				countingArray[value] = count + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> <span class="variable">numsIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 再把计数数组中的数据 反哺到nums中</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countingArray.length; i++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> countingArray[i];</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">					nums[numsIndex] = i;</span><br><span class="line">					numsIndex++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h2><p>大家学过了计数排序，有没有发现一个问题，如果数组中元素的大小跨越的过大的化，所需要的计数数组的大小就越大。非常浪费空间。</p>
<p>为了优化这个问题，随之诞生的桶排序可以很好的解决这个问题。</p>
<p>它的数据结构类似与Java中的HashMap，图解如下：</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/uK7jwj.png"></p>
<p>它的思想也是定义一个数组，数组的每一个位置当成一个桶，</p>
<p>但是每一个位置里面可以有很多元素。</p>
<p>再对每一个桶进行排序。</p>
<p>最后，通过这个桶数组，生成一个排好序的数组作为结果。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="comment">// 1、 定义桶</span></span><br><span class="line"><span class="comment">// 2、 按桶，对数组分组</span></span><br><span class="line"><span class="comment">// 3、 对每个桶进行排序</span></span><br><span class="line"><span class="comment">// 4、 组合每个桶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 1、 定义桶</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> nums[<span class="number">0</span>], minValue = nums[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> v : nums) &#123;</span><br><span class="line">				maxValue = Math.max(maxValue, v); <span class="comment">// 47</span></span><br><span class="line">				minValue = Math.min(minValue, v); <span class="comment">// 1</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 桶对数量（不重要，大概就行）</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(nums.length); <span class="comment">// 8</span></span><br><span class="line">			List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">List</span>[bucketCount];</span><br><span class="line">			<span class="comment">// 2、 按桶，对数组分组</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> v : nums) &#123; <span class="comment">// v =15</span></span><br><span class="line">				<span class="comment">// 找到对应对桶，这点要注意</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">bucketIndex</span> <span class="operator">=</span> v * (bucketCount - <span class="number">1</span>) / maxValue;</span><br><span class="line">				List&lt;Integer&gt; bucket = buckets[bucketIndex];</span><br><span class="line">				<span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">					bucket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">					bucket.add(v);</span><br><span class="line">					buckets[bucketIndex] = bucket;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					bucket.add(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3、 对每个桶进行排序</span></span><br><span class="line">			<span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">				Collections.sort(bucket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 4、 组合每个桶</span></span><br><span class="line">			<span class="keyword">return</span> Arrays.stream(buckets).flatMap(Collection::stream)</span><br><span class="line">					.mapToInt(Integer::intValue).toArray();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h2><p>基数排序对于桶排序来说，也是换汤不换药。</p>
<p>同样有一个桶数组，但是这个数组的长度固定，只有10。</p>
<p>通过从低位到最高位的循环，每次循环都做一次桶排序。</p>
<p>最终就会得到一个排序好的数组。</p>
<p>这种算法占用的额外空间更小，也更可控。</p>
<p>动图如下：</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015232453668-1397662527.gif"></p>
<p>思想很简单。</p>
<p>请看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 取得数组中的最大数，并取得位数；</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * arr为原始数组，从最低位开始取每个位组成radix数组；</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//取得数组中的最大数，并取得位数</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> getBiggestDigit(nums);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// i=1表示个位； i=2表示十位 ......</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= digit; i++) &#123;</span><br><span class="line">				<span class="comment">// 每一个位置都过一下桶数组</span></span><br><span class="line">				bucket(nums, i);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// i=1表示个位； i=2表示十位 ......</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bucket</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">			List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">10</span>];</span><br><span class="line">			<span class="comment">// 把数组，放置到桶中</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">				<span class="comment">// 获取对应位数的数值</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> getPosition(n, i);</span><br><span class="line">				List&lt;Integer&gt; list = buckets[pos];</span><br><span class="line">				<span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">					list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">					buckets[pos] = list;</span><br><span class="line">				&#125;</span><br><span class="line">				list.add(n);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 再把桶中到数据，恢复到原数组中</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">				<span class="keyword">if</span> (CollectionUtils.isNotEmpty(bucket)) &#123;</span><br><span class="line">					<span class="keyword">for</span> (Integer v : bucket) &#123;</span><br><span class="line">						nums[index] = v;</span><br><span class="line">						index++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取对应位数的数值</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> digit)</span> &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">			<span class="comment">// 33   2</span></span><br><span class="line">			<span class="keyword">if</span> (s.length() &lt; digit) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> Integer.parseInt(s.substring(s.length() - digit, s.length() - digit + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 取得数组中的最大数，并取得位数</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBiggestDigit</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> String.valueOf(num).length();</span><br><span class="line">				maxDigit = Math.max(maxDigit, d);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> maxDigit;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们的十大排序算法就学习完了。</p>
<p>希望大家都有所收获。</p>
<p>其中最重要的当属 快速排序 了，两种快速排序算法，大家一定要好好掌握。</p>
<p>还有希尔排序，也比较难想，需要大家好好理解。</p>
<p>结束！！！</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java操作ElasticSearch</title>
    <url>/2021/06/11/Java%E6%93%8D%E4%BD%9CElasticSearch/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天我们将使用Java来操作ElasticSearch。<br>我们将：</p>
<ul>
<li>使用Docker搭建ES集群环境</li>
<li>使用SpringBoot搭建Java环境</li>
<li>在Java模型中定义ES的索引</li>
<li>使用两种方式来操作ES（JPA和ElasticSearchTemplate）</li>
</ul>
<span id="more"></span>

<h2 id="搭建集群环境"><a href="#搭建集群环境" class="headerlink" title="搭建集群环境"></a>搭建集群环境</h2><p>今天我们继续使用docker来搭建环境。<br><code>docker-compose.yaml</code>奉上。<br>想必大家都很清楚docker compose的用法了，这里就不再赘述。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>因为这里是集群，除了<code>volumes</code>需要注意之外，还需要注意<code>network</code>需要配置一下。<br>启动完成之后，浏览器访问:<br><a href="http://localhost:9200/">http://localhost:9200</a><br>如果展示：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/image.png"><br>表示ES集群启动成功。</p>
<h2 id="搭建Java环境"><a href="#搭建Java环境" class="headerlink" title="搭建Java环境"></a>搭建Java环境</h2><p>我们创建一个SpringBoot项目。<br>在<code>pom.xml</code>中引入elasticsearch的starter，即可。<br>不过要注意的是，因为ElasticSearch版本迭代很快，我们的版本要对应的上。<br>我们先查看一下ElasticSearch的版本： 7.13.2<br>再看一下<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/">Spring文档</a>，找到对应的SpringData的版本。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/J73lBg.png"><br>在pom中我们添加上引用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>刷新下maven。 再继续在<code>application.properties</code>中配置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.data.elasticsearch.cluster-name</span>=<span class="string">es-docker-cluster</span></span><br><span class="line"><span class="attr">spring.data.elasticsearch.cluster-nodes</span>=<span class="string">localhost:9200</span></span><br></pre></td></tr></table></figure>

<p>即完成环境搭建。</p>
<h2 id="在Java模型中定义ES的索引"><a href="#在Java模型中定义ES的索引" class="headerlink" title="在Java模型中定义ES的索引"></a>在Java模型中定义ES的索引</h2><p>好，接下来来到我们的重头戏，设计ES的索引。<br>在ES中，索引对应类似MySQL中的表，而Mapping，相当于MySQL中的表结构。<br>在一切开始之前，设计一个足够好的表结构尤为重要。可以直接影响到数据库的性能。</p>
<p>直接上结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;product&quot;)</span></span><br><span class="line"><span class="meta">@Setting(shards = 3, replicas = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Text, index = false)</span></span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Keyword, ignoreAbove = 128)</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Text, analyzer = &quot;ik_smart&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">	<span class="keyword">private</span> String brandName;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Long)</span></span><br><span class="line">	<span class="keyword">private</span> Long stock;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Double)</span></span><br><span class="line">	<span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Date, format = &#123;&#125;, pattern = &#123;&quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd&quot;,</span></span><br><span class="line"><span class="meta">			&quot;epoch_millis&quot;&#125;)</span></span><br><span class="line">	<span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Nested)</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Sku&gt; skuList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>我们首先定义了一个商品的Java模型<code>Product</code>，有各种Java类型（String、Long、BigDecimal、LocalDateTime、List）。<br>在类的上面添加<code>Document</code>注解，表示被Spring所管理。<br><code>org.springframework.data.elasticsearch.annotations.Document</code>中还有一些其他的属性。大家可以参考官方文档。</p>
<h3 id="定义Setting"><a href="#定义Setting" class="headerlink" title="定义Setting"></a>定义Setting</h3><p>定义好模型之后，我们再确定好索引的配置，<code>Setting</code>。<br>这里面主要配置，这个索引在ES中的分片数，和副本数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setting(shards = 3, replicas = 2)</span></span><br></pre></td></tr></table></figure>

<p>当然，除了分片数和副本数，还有其他的配置，大家参考官方文档。</p>
<h3 id="定义Mapping"><a href="#定义Mapping" class="headerlink" title="定义Mapping"></a>定义Mapping</h3><p>接下来，就到了定义最重要的Mapping。</p>
<h4 id="确定数据结构"><a href="#确定数据结构" class="headerlink" title="确定数据结构"></a>确定数据结构</h4><p>首先我们要知道，ES有着自己的数据结构，而且种类还很多。如图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/JtmYzS.png"><br>我们需要在每一个Java的数据结构中，对应上ES的数据结构。<br>比如<code>@Field(type = FieldType.Text)</code>表示它在ES中，是一个文本型的数据。<br>而文本型，是要被分词，生成倒排索引的。<br>这里提几点选择策略：</p>
<ul>
<li>文本类型分两种，需要分词，选text，不需要分词，选keyword</li>
<li>如果你未来不确定你到底有多少数据，将类型设置为long是比较合适的</li>
<li>keyword检索比较短的字符会更快，如果字符很大，那么会增加存储和检索成本，可以使用<code>ignoreAbove</code>属性</li>
</ul>
<h4 id="确定是否需要被索引"><a href="#确定是否需要被索引" class="headerlink" title="确定是否需要被索引"></a>确定是否需要被索引</h4><p>默认情况下，索引的字段都是需要被索引的，但是为了节省空间，我们可以把一些字段设置成不建索引。<br>比如ID一类的参数，不想被索引：<code>@Field(type = FieldType.Text, index = false)</code></p>
<h4 id="检索的方式"><a href="#检索的方式" class="headerlink" title="检索的方式"></a>检索的方式</h4><p>我们可以通过分词器，来定义我们的分词方式，比如<br><code>@Field(type = FieldType.Text, analyzer = &quot;ik_smart&quot;, searchAnalyzer = &quot;ik_smart&quot;)</code><br>这样，我们就可以使用中文的倒排索引啦。。。</p>
<h4 id="特殊的类型"><a href="#特殊的类型" class="headerlink" title="特殊的类型"></a>特殊的类型</h4><p>如果我们需要使用时间类型，在Java中，我们使用<code>LocalDateTime</code>,对应ES中是<code>Date</code>类型。<br>但是需要注意的是，我们需要定义格式化的方式，不然大概率时分秒要丢失。<br><code>@Field(type = FieldType.Date, format = &#123;&#125;, pattern = &#123;&quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd&quot;, &quot;epoch_millis&quot;&#125;)</code></p>
<p>嵌套类型，使用<code>Nested</code><br><code>@Field(type = FieldType.Nested)</code></p>
<h2 id="使用两种方式来操作ES"><a href="#使用两种方式来操作ES" class="headerlink" title="使用两种方式来操作ES"></a>使用两种方式来操作ES</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/MHdECp.png"></p>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>首先我们来看看如何来管理ES的索引</p>
<h4 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h4><p>如果使用JPA，我们只需保持默认配置，JPA就会替我们按照我们定义的Map来创建索引。<br>不需要我们操心。</p>
<p>我们可以使用<a href="http://localhost:9200/product/_mapping">http://localhost:9200/product/_mapping</a>来查看对应索引信息。</p>
<h4 id="ElasticsearchRestTemplate"><a href="#ElasticsearchRestTemplate" class="headerlink" title="ElasticsearchRestTemplate"></a>ElasticsearchRestTemplate</h4><p>template对应的Api如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到对应索引的操作引用</span></span><br><span class="line">    <span class="type">IndexOperations</span> <span class="variable">indexOperations</span> <span class="operator">=</span> elasticsearchRestTemplate.indexOps(Product.class);</span><br><span class="line">    <span class="comment">// 查看索引是否存在</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> indexOperations.exists();</span><br><span class="line">    <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">        <span class="comment">// 删除索引（删除操作要慎重）</span></span><br><span class="line">        indexOperations.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建索引</span></span><br><span class="line"><span class="comment">//		indexOperations.create(); //这个没有配置mapping</span></span><br><span class="line">    indexOperations.createWithMapping();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 查看索引的Setting</span></span><br><span class="line">    <span class="type">Settings</span> <span class="variable">settings</span> <span class="operator">=</span> indexOperations.getSettings();</span><br><span class="line">    <span class="comment">// 查看索引的Mapping</span></span><br><span class="line">    Map&lt;String, Object&gt; mapping = indexOperations.getMapping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增删改查操作"><a href="#增删改查操作" class="headerlink" title="增删改查操作"></a>增删改查操作</h3><h4 id="JPA-1"><a href="#JPA-1" class="headerlink" title="JPA"></a>JPA</h4><p>使用JPA非常方便，只需要定义好<code>Repository</code>，就可以方便快捷的操作Document了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;Product, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CURDTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ProductRepository repository;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> repository.save(Product.get());</span><br><span class="line">		Assertions.assertNotNull(product);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMore</span><span class="params">()</span> &#123;</span><br><span class="line">		List&lt;Product&gt; products = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			products.add(Product.get());</span><br><span class="line">		&#125;</span><br><span class="line">		repository.saveAll(products);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listAll</span><span class="params">()</span> &#123;</span><br><span class="line">		Iterable&lt;Product&gt; all = repository.findAll();</span><br><span class="line">		all.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">page</span><span class="params">()</span> &#123;</span><br><span class="line">		Page&lt;Product&gt; page = repository.findAll(Pageable.ofSize(<span class="number">4</span>).withPage(<span class="number">0</span>));</span><br><span class="line">		System.out.println(page);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getById</span><span class="params">()</span> &#123;</span><br><span class="line">		Page&lt;Product&gt; page = repository.findAll(Pageable.ofSize(<span class="number">1</span>).withPage(<span class="number">0</span>));</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> page.getContent().get(<span class="number">0</span>);</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product1</span> <span class="operator">=</span> repository.findById(product.getId()).orElse(<span class="literal">null</span>);</span><br><span class="line">		Assertions.assertNotNull(product1);</span><br><span class="line">		System.out.println(product1);</span><br><span class="line">		Assertions.assertEquals(product.getId(), product1.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">		Page&lt;Product&gt; page = repository.findAll(Pageable.ofSize(<span class="number">1</span>).withPage(<span class="number">0</span>));</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> page.getContent().get(<span class="number">0</span>);</span><br><span class="line">		<span class="type">Product</span> <span class="variable">newProduct</span> <span class="operator">=</span> Product.get();</span><br><span class="line">		newProduct.setId(product.getId());</span><br><span class="line">		<span class="type">Product</span> <span class="variable">save</span> <span class="operator">=</span> repository.save(newProduct);</span><br><span class="line">		Assertions.assertEquals(product.getId(), save.getId());</span><br><span class="line">		Assertions.assertNotEquals(product.getName(), save.getName());</span><br><span class="line">		System.out.println(product);</span><br><span class="line">		System.out.println(save);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">		Page&lt;Product&gt; page = repository.findAll(Pageable.ofSize(<span class="number">1</span>).withPage(<span class="number">0</span>));</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> page.getContent().get(<span class="number">0</span>);</span><br><span class="line">		repository.delete(product);</span><br><span class="line"></span><br><span class="line">		<span class="type">Product</span> <span class="variable">product1</span> <span class="operator">=</span> repository.findById(product.getId()).orElse(<span class="literal">null</span>);</span><br><span class="line">		Assertions.assertNull(product1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA的封装可以让我们无差别的操作任何数据库。 yyds</p>
<h4 id="ElasticsearchRestTemplate-1"><a href="#ElasticsearchRestTemplate-1" class="headerlink" title="ElasticsearchRestTemplate"></a>ElasticsearchRestTemplate</h4><p>使用ElasticsearchRestTemplate操作文档相对麻烦一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CURDTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ElasticsearchRestTemplate elasticsearchRestTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> elasticsearchRestTemplate.save(Product.get());</span><br><span class="line">		Assertions.assertNotNull(product);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMore</span><span class="params">()</span> &#123;</span><br><span class="line">		List&lt;Product&gt; products = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			products.add(Product.get());</span><br><span class="line">		&#125;</span><br><span class="line">		elasticsearchRestTemplate.save(products);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listAll</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> elasticsearchRestTemplate.matchAllQuery();</span><br><span class="line">		SearchHits&lt;Product&gt; search = elasticsearchRestTemplate.search(query, Product.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getById</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> elasticsearchRestTemplate.get(<span class="string">&quot;ID&quot;</span>, Product.class);</span><br><span class="line">		Assertions.assertNotNull(product);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">oldProduct</span> <span class="operator">=</span> elasticsearchRestTemplate.get(<span class="string">&quot;ID&quot;</span>, Product.class);</span><br><span class="line">		Assertions.assertNotNull(oldProduct);</span><br><span class="line"></span><br><span class="line">		<span class="type">Product</span> <span class="variable">newProduct</span> <span class="operator">=</span> Product.get();</span><br><span class="line">		<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> newProduct.toDocument();</span><br><span class="line">		<span class="type">UpdateQuery</span> <span class="variable">updateQuery</span> <span class="operator">=</span> UpdateQuery.builder(<span class="string">&quot;ID&quot;</span>).withDocument(document).build();</span><br><span class="line">		<span class="type">UpdateResponse</span> <span class="variable">product</span> <span class="operator">=</span> elasticsearchRestTemplate</span><br><span class="line">				.update(updateQuery, IndexCoordinates.of(<span class="string">&quot;product&quot;</span>));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> elasticsearchRestTemplate.delete(<span class="string">&quot;ID&quot;</span>, Product.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="JPA-2"><a href="#JPA-2" class="headerlink" title="JPA"></a>JPA</h4><p>JPA的搜索很简单，就把当成一个普通的数据库搜索就行。<br>我们只需要在repository中定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;Product, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">	List&lt;Product&gt; <span class="title function_">findAllByNameContaining</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我没就可以在所有名称中包含莫个字段了。<br>在调用这个方法的时候，可以在控制台看到，本质上是JPA帮我我们发了一个<code>_search</code>的POST请求。<br>其他更复杂的方法，可以参考JPA的文档。</p>
<h4 id="ElasticsearchRestTemplate-2"><a href="#ElasticsearchRestTemplate-2" class="headerlink" title="ElasticsearchRestTemplate"></a>ElasticsearchRestTemplate</h4><p>使用ElasticsearchRestTemplate操作search，也很不错。<br>我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">searchQuery</span> <span class="operator">=</span> Query.findAll();</span><br><span class="line">    <span class="type">IndexCoordinates</span> <span class="variable">indexCoordinates</span> <span class="operator">=</span> IndexCoordinates.of(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">    SearchHits&lt;Product&gt; result = elasticsearchRestTemplate</span><br><span class="line">            .search(searchQuery, Product.class, indexCoordinates);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按名称 搜索</span></span><br><span class="line">    <span class="type">MatchQueryBuilder</span> <span class="variable">matchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.matchQuery(<span class="string">&quot;spuName&quot;</span>, <span class="string">&quot;473&quot;</span>);</span><br><span class="line">    searchQuery = <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>()</span><br><span class="line">            .withQuery(matchQueryBuilder)</span><br><span class="line">            .build();</span><br><span class="line">    result = elasticsearchRestTemplate</span><br><span class="line">            .search(searchQuery, Product.class, indexCoordinates);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按价格搜索</span></span><br><span class="line">    <span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Criteria</span>(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">            .greaterThan(<span class="number">500.0</span>)</span><br><span class="line">            .lessThan(<span class="number">800.0</span>);</span><br><span class="line"></span><br><span class="line">    searchQuery = <span class="keyword">new</span> <span class="title class_">CriteriaQuery</span>(criteria);</span><br><span class="line"></span><br><span class="line">    result = elasticsearchRestTemplate</span><br><span class="line">            .search(searchQuery, Product.class, indexCoordinates);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写有一个好处，就是在返回结果数据的同时，还会返回命中率，这个有时候也是会用到的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经学会了如何把ES操作引入到我们到Java项目中，<br>还知道了如何设计并建立一个索引，<br>还有使用两种方法来操作ES。<br>希望大家都能够在工作当中用上哦！！</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>jpa</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习及原理浅析</title>
    <url>/2021/08/13/MySQL%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从今天开始，我们将学习目前最流行的一个数据库MySQL。</p>
<p>这篇文章，带大家走进Mysql的世界。</p>
<ul>
<li>MySQL的底层结构</li>
<li>MySQL的查询过程</li>
<li>索引结构</li>
<li>MySQL的三种Log</li>
<li>MySQL的存储引擎</li>
</ul>
<span id="more"></span>

<h2 id="MySQL的底层结构"><a href="#MySQL的底层结构" class="headerlink" title="MySQL的底层结构"></a>MySQL的底层结构</h2><p>MySQL我们可以主要分成三层：</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/v3Tr6K.png"></p>
<ol>
<li>客户端连接层。主要负责处理客户端的连接，用户的账号密码校验，权限等功能。</li>
<li>核心服务层。主要功能有缓存，对SQL语句的解析和优化，对底层API的调用。</li>
<li>存储引擎。 对数据对管理，存储，查询，事务，索引等等功能。</li>
</ol>
<h2 id="MySQL的查询过程"><a href="#MySQL的查询过程" class="headerlink" title="MySQL的查询过程"></a>MySQL的查询过程</h2><p>一个SQL的查询过程可以分成六步。 如图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/mkccLn.png"></p>
<ol>
<li>客户端和MySQL建立连接。</li>
<li>查询缓存，如果缓存命中，直接返回。但是不建议使用缓存，命中率低，弊大于利。</li>
<li>解析SQL，生成语法解析树。如果SQL写的有问题，这一步会报错。</li>
<li>查询优化，通过语法树，生成执行计划，计划可能不止一个，优化器会找到成本最小的一个执行计划。</li>
<li>执行计划，查询执行引擎拿到了执行计划，调用对应的存储引擎的接口，来执行查询，得到结果。</li>
<li>返回结果，缓存结果。如果结果集很大（1W条），不会等到全部结果出来再返回，会在第一条结果出来的时候，就开始返回结果。</li>
</ol>
<h2 id="MySQL的三种Log"><a href="#MySQL的三种Log" class="headerlink" title="MySQL的三种Log"></a>MySQL的三种Log</h2><p>MySQL有三种Log，各司其职。分别是binlog、redo log、undo log。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>binlog的主要作用是记录数据库的每一步变化。由MySQL核心服务层控制。</p>
<p>可以让别的服务来监听，实现数据同步。</p>
<p>或者再数据库损坏之后，恢复数据。</p>
<p>数据库的每一次变化，比如某一个表新增了一条数据，就会生成一个对应的binlog。<br>另外的服务监听到了之后，可以做出对应的操作，把数据同步一份。</p>
<p>可以做主备，可以做读写分离。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>首先我们先要了解到一点，磁盘的IO昂贵，数据库再做数据变更的时候，都不会一有变更，就立即更新磁盘数据。</p>
<p>做法都是先在内存中进行操作，等到合适的时候（配置决定），再一次性的刷到磁盘当中。</p>
<p>但是如果数据在内存当中变更了之后，数据库崩溃了，这个时候内存中的数据就会丢失。</p>
<p>MySQL就会有一个redo log来保证上述情况的数据不丢失。</p>
<p>redo log由存储引擎控制。</p>
<p>当MySQL修改数据的做法如下：</p>
<ol>
<li>把对应数据的页，查询出来，并保存到内存中</li>
<li>修改内存中的数据，同时生成redo log（哪一页，修改了那些内容）。原子操作</li>
<li>如果这时MySQL崩溃，可以根据redo log恢复内存中的数据。</li>
<li>如果没有崩溃，会在合适的时候，把内存中的数据落到磁盘上，同时删除对应的redo log。</li>
</ol>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log和事务有关。InnoDB存储引擎特有。</p>
<p>在一个事务中，每一次操作，都会生成一个log，所有的log会组成一个数据链。</p>
<p>可以用来控制回滚，和在不同的事务级别下，所展示的数据的版本。</p>
<p>这就是MVCC，多版本并发控制。我们在事务那一章的时候，还会详细说明。</p>
<h2 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h2><p>MySQL的存储引擎的设计是MySQL的一大特点。<br>它可以让我们灵活的使用不同的存储引擎来应对不同的需求。</p>
<p>我们可以使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENGINE, SUPPORT <span class="keyword">FROM</span> INFORMATION_SCHEMA.ENGINES;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure>

<p>来查询存储引擎列表，和当前MySQL是否支持。</p>
<p>我们可以查看<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">官方文档</a><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/8hRNsc.png"></p>
<p>我们在这里也做一下简单的介绍：</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>我们最常用的存储引擎当属InnoDB。</p>
<p>它支持事务，符合ACID，支持行级锁，<br>支持B树索引，新版版还支持全文索引，<br>使用MVCC多版本并发控制，支持崩溃恢复，<br>还支持外键。</p>
<p>它是我们一般情况下的首选。</p>
<p>在需要事务的场景中，我们更是无脑选择InnoDB。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM它的特点是不支持事务。当时它的优势是结构简单，比InnoDB稍快。</p>
<p>读效率比写更快。适合需要大量读的场景中。</p>
<p>支持B树索引和全文索引。如果小项目不想使用ES的话，可以考虑使用MyISAM做视图。</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>看名字就知道，它的特点是把数据存储在内存中的，<br>所以没有持久化，断电崩溃数据会丢失。</p>
<p>但是就是因为使用的内存，它的速度非常快。可以部分替代Redis的功能。</p>
<h3 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h3><p>如果你需要保存日志信息，存档信息等一些需要快速查询的场景。<br>你可以使用Archive。</p>
<p>它支持数据压缩，不支持事务、索引。</p>
<p>可以部分替代MongoDB的功能。</p>
<h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>CSV的结构很简单，它会生成一个<code>.cvs</code>的文件来存储数据。</p>
<p>我们可以使用Excel来打开它。一般很少使用。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了上述的存储引擎，剩下还有一些存储引擎。<br>比如说：Merge、Federated、Blackhole、NDB、Example<br>具体参考<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">官方文档</a></p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>索引是为了提高查询效率的一种手段。</p>
<p>如果我们的数据一本新华字典的话，索引就是字典的目录。可以大大提高我们查询的效率。</p>
<p>但是索引是有代价的，它会提高修改数据的成本，也需要单独的空间来存放索引数据。</p>
<p>常见的索引结构有以下几种；</p>
<ul>
<li>Hash</li>
<li>B tree</li>
<li>全文索引</li>
</ul>
<p>本文，我们会重点说说B树这种结构。</p>
<h3 id="什么是B树"><a href="#什么是B树" class="headerlink" title="什么是B树"></a>什么是B树</h3><p>B树是一种多叉树，一个根节点下面一般有很多叶子节点，所以B树的高度一般不高。</p>
<p>使用B树存储的数据都是有序的。</p>
<p>如下图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/mwUrxI.png"></p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B树的一种升级版。</p>
<p>它的特点是，只有叶子节点存储数据。非叶子节点只存储索引。</p>
<p>叶子节点（数据节点）同样也是有序的，并且相邻的两个叶子节点使用双向链表连接起来，这样范围查询的效率非常高。</p>
<p>可参考下图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/tu3yvP.png"></p>
<p>MySQL的InnoDB存储引擎使用的就是B+树作为索引结构。</p>
<p>每一个节点的大小固定，迎合一次磁盘IO，大小应该是16KB。</p>
<p>而非叶子上存储的都是索引，所以一个节点上可以存储非常多的索引数据。<br>再通过二分查找，来找到对应的数据地址。</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>在InnoDB存储引擎中，表中的数据都是通过一个B+树来维护的，<br>同时表中所有的数据，都存放在B+树的叶子节点上。</p>
<p>而非聚簇索引，B+树的叶子节点上，存储的都是主键ID。<br>如果需要找到详情的数据信息，需要回表查询，即拿到主键ID，到主B+树（聚簇索引）上再查询。</p>
<h3 id="如何通过索引实现范围查询"><a href="#如何通过索引实现范围查询" class="headerlink" title="如何通过索引实现范围查询"></a>如何通过索引实现范围查询</h3><p>如果我们有一个这样的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询今年以来的订单</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> create_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为了加快查询效率，我们会在<code>create_time</code>字段上添加索引。<br>这样就有了一个按照时间排序好的索引B+树了。</p>
<p>我们的查询会从全表扫面，变成通过索引查询。</p>
<p>我们会先通过索引找到第一create_time为’2021-01-01 00:00:00’的订单索引，</p>
<p>再通过B+树叶子节点间的链表指针，往后扫描，找到满足条件的所有的订单索引。</p>
<p>再拿到满足条件的订单主键ID，去订单主聚簇索引中回表查询详细信息，返回结果。</p>
<h3 id="联合索引、索引下推、覆盖索引"><a href="#联合索引、索引下推、覆盖索引" class="headerlink" title="联合索引、索引下推、覆盖索引"></a>联合索引、索引下推、覆盖索引</h3><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们可以给一个字段添加索引，如上述的订单创建时间。</p>
<p>但是很多情况下的业务复杂，筛选条件众多，我们会为几个字段一起添加一个联合索引。</p>
<p>比如<code>订单的买家</code>、<code>订单创建时间</code>和<code>订单状态</code>可以作为一个联合索引。</p>
<p>这样在应用程序的客户端当中，买家查询自己的订单列表，并按照订单创建时间倒排，并可以通过订单状态做筛选条件。<br>这种情况下的查询效率会很高效。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引下推只会作用在联合索引上。并且会发生在范围查询上。</p>
<p>一句话说明：索引下推会尽量使用索引来判断where条件，而减少回表次数。</p>
<p>还是以订单表为列子，联合索引：客户姓名、订单时间</p>
<p>如果我们要查询：今年以来，姓王的客户的订单</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> create_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span> <span class="keyword">and</span> customer_name <span class="keyword">like</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>而我们都知道，范围查询会中断索引。</p>
<p>如果我们不使用索引下推的话：</p>
<p>我们会在<code>客户姓名、订单时间索引</code>B+树中找出满足客户姓名姓氏的所有订单ID</p>
<p>拿到所有订单ID去主键聚簇索引中回表查询数据，再判断今年以来的订单数据。</p>
<p>这种情况下，回表查询的订单ID会非常多。</p>
<p>而如果我们使用索引下推：</p>
<p>我们会在索引的B+树中，提前查询、筛选中满足姓氏和时间的订单ID。</p>
<p>再回表查询。</p>
<p>这种情况下，回表查询的订单ID是提前筛选好的，会少很多。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>还是上述情况，订单表的联合索引<code>客户姓名、订单时间</code>。有这样的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> create_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span> <span class="keyword">and</span> customer_name <span class="keyword">like</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>SQL语句中的所有的查询条件和返回数据，在联合索引的B+树中都有，</p>
<p>我们只需要通过索引查询出来主键ID，就可以直接返回结果了，不需要再回表查询。</p>
<p>这就是覆盖索引。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次我们探讨了一种目前最流行的关系型数据库MySQL。</p>
<p>带大家了解了下MySQL的基本结构，它的查询过程。</p>
<p>通过三种Log来了解了一些MySQL的内部原理。</p>
<p>还有索引相关的一些内容。</p>
<p>希望大家都有所收获。</p>
<p>我们下次还会讲到MySQL的事务和MySQL调优相关的内容。</p>
]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
