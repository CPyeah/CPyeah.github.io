<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL事务原理</title>
    <url>/2021/08/25/database/MySQL%E4%BA%8B%E7%89%A9%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>什么是事务？！</p>
<p>一句话来说，事务是一次操作的<code>逻辑单位</code>。要不全部成功，要不全部失败。</p>
<p>它主要是用来保证<code>数据一致性</code>的问题。</p>
<span id="more"></span>

<p>比如去银行转账的操作，原来账户的扣款，和目标账户的加款。<br>这两个操作要放在一个事务里面，要不一起成功，要不一起失败。</p>
<p>如果在事务中间，发生问题，需要把已经执行了的操作<code>回滚</code>，以保证数据准确。</p>
<h2 id="事务的常见命令"><a href="#事务的常见命令" class="headerlink" title="事务的常见命令"></a>事务的常见命令</h2><ul>
<li>START TRANSACTION：开始一个事务</li>
<li>COMMIT：事务顺利完成时，提交事务</li>
<li>ROLLBACK：事务发生了异常，回滚</li>
</ul>
<p>比如我们有一张customer表，执行一下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;lisi&#x27;</span>;</span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<p>再查询表，会得到：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/Prom8Z.png"><br>表示一个事务完成、提交。</p>
<p>我们再执行下面操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;wangwu&#x27;</span>;</span><br><span class="line"><span class="keyword">rollback</span> ;</span><br></pre></td></tr></table></figure>

<p>再查询customer表，会发现wangwu并没有被添加到表中，表中还只有两条记录。</p>
<ul>
<li>建立保存点：SAVEPOINT 保存点名称</li>
<li>删除保存点：RELEASE SAVEPOINT 保存点名称</li>
<li>回滚到特定保存点：ROLLBACK TO SAVEPOINT 保存点名称</li>
</ul>
<p>我们接着再执行下面点语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;zhao liu&#x27;</span>;</span><br><span class="line"><span class="keyword">savepoint</span> my_point;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;qian qi&#x27;</span>;</span><br><span class="line"><span class="keyword">rollback</span> <span class="keyword">to</span> <span class="keyword">savepoint</span> my_point;</span><br></pre></td></tr></table></figure>

<p>我们查询到到结果是：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/gIvWTx.png"><br><code>zhao liu</code> 成功入库了，而 <code>qian qi</code> 被回滚掉了。</p>
<p><code>savepoint</code> 保存点，可以让我们实现部分回滚。</p>
<h2 id="Transaction-四大特性：-ACID"><a href="#Transaction-四大特性：-ACID" class="headerlink" title="Transaction 四大特性： ACID"></a>Transaction 四大特性： ACID</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/NfuAJQ.png"></p>
<p>一个事务有下列四个重要到特性，简称ACID</p>
<ul>
<li>A：Atomicity 原子性。 事务里面到操作，不可分割，要不一起成功，要不一起失败。</li>
<li>C：Consistency 一致性。在事务的前后，系统的整体数据保持一致。比如说银行转账。</li>
<li>I：Isolation 隔离性。 事务之间，相互隔离，互不干扰。</li>
<li>D：Durability 永久性。 一旦数据修改完成，永久有效。</li>
</ul>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/9qUodw.png"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/xJ1VeA.png"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/jez6I1.png"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/vXbP4p.png"></p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>介绍完了ACID，我们再来重点说说ACID其中的I(Isolation)。</p>
<p>我们都知道，事务之间是隔离的<br>但是如何处理多个事务之间操作和读取同一个数据的结果，<br>我们需要仔细考虑。</p>
<p>事务隔离级别是在多个事务同时进行更改和执行查询时，<br>调整<code>性能</code>和结果的<code>可靠性</code>、<code>一致性</code>和<code>可再现性</code>之间的平衡的设置。</p>
<p>MySQL（InnoDB）提供四种事务隔离级别：</p>
<ul>
<li>read uncommitted 读未提交</li>
<li>read committed   读已提交</li>
<li>repeatable read  可重复读（MySQL默认隔离级别）</li>
<li>serializable     串行</li>
</ul>
<p>我们可以参考<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">官方文档</a></p>
<h3 id="事务隔离级别的设置"><a href="#事务隔离级别的设置" class="headerlink" title="事务隔离级别的设置"></a>事务隔离级别的设置</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 设置全局的事务隔离级别</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION LEVEL [REPEATABLE READ <span class="operator">|</span> READ COMMITTED <span class="operator">|</span> READ UNCOMMITTED <span class="operator">|</span> SERIALIZABLE];</span><br><span class="line"># 设置当前Session的隔离级别</span><br><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL [REPEATABLE READ <span class="operator">|</span> READ COMMITTED <span class="operator">|</span> READ UNCOMMITTED <span class="operator">|</span> SERIALIZABLE];</span><br><span class="line"># 查看当前事务隔离级别</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_ISOLATION;</span><br></pre></td></tr></table></figure>

<p>我们先做一下前置的准备，<br>开启两个Session，<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/Lf8Nzf.png"></p>
<p>并查看一下当前的事务隔离级别<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/3zaxpJ.png"></p>
<p>接下来，我们一个一个看：</p>
<h3 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h3><p>未提交读，指的就是一个事务读到了另外一个事务未提交的数据。</p>
<p>这样会导致脏读。</p>
<p>我们来实验一下：</p>
<p>我们先设置两个Session的隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</span><br></pre></td></tr></table></figure>

<p>查看下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/WNJBVz.png"></p>
<p>我们现在数据库当中有两条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer;</span><br></pre></td></tr></table></figure>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/trxTdG.png"></p>
<p>我们在Session A中开启一个事务，并修改一条记录，但是不提交。</p>
<p>再在Session B 中查询，看会得到怎样的结果。</p>
<p>我们现在Session A 中执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"># <span class="number">1</span>、开启事务</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;zhangsan2&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们在Session B 中看下结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"># <span class="number">3</span>、查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>此时Session A中的事务还没有提交，也就是说有回滚的可能。<br>但在Session B中查看数据， 客户名称已经从 <code>zhangsan</code> 变成了 <code>zhangsan2</code>。</p>
<p>如果Session A再进行了回滚，rollback。 这样Session B就读出了一个不存在的数据，就是脏读。</p>
<p>这是非常不安全的一种隔离级别。</p>
<h3 id="已提交读（READ-COMMITTED）"><a href="#已提交读（READ-COMMITTED）" class="headerlink" title="已提交读（READ COMMITTED）"></a>已提交读（READ COMMITTED）</h3><p>已提交读，就是读到的数据都是另外的事务已经提交过了的数据。<br>可以解决脏读的问题。</p>
<p>我们先修改下事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_ISOLATION;</span><br></pre></td></tr></table></figure>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/5fAmh8.png"></p>
<p>我们在SessionA中修改数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"># <span class="number">1</span>、开启事务</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在Session B 中查看数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"># <span class="number">3</span>、查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/YMiybO.png"><br>我们可以看到，客户名称还是<code>zhangsan</code>，没有变成<code>张飞</code>。</p>
<p>我们这个时候再把Session A中的事务提交</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"># <span class="number">1</span>、开启事务</span><br><span class="line"># <span class="keyword">start</span> transaction ;</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据</span><br><span class="line"># <span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、提交事务</span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<p>再次在Session B 中查看数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"># <span class="number">3</span>、查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/wY9JUG.png"><br>我们可以看到，客户名称已经变成了 <code>张飞</code>。</p>
<p>如果session A的事务回滚的话，我们在Session B中看到的结果还会是 <code>zhangsan</code><br>这样，我们就成功解决了脏读的问题了。</p>
<p>但是如果我们在同一个事务中，读取数据，可能会查询到不同的结果。<br>我们按照数字的顺序，执行以下SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>、开启事务，并查看数据</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 张飞</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 关羽</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 刘备</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据（自动提交事务）</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、修改数据（自动提交事务）</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;刘备&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，Session B 在同一个事务中，同样的查询语句，得出的结果是不一样的。<br>这种现象我们称之为<code>不可重复读</code>。</p>
<h3 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h3><p>有些场景，我们需要在一个事务中，查询到到数据保持一致，不管外部事务如何改变。</p>
<p>这个时候，就需要我们满足<code>可重复读</code>。</p>
<p>我们直接看效果：</p>
<p>首先修改事务隔离级别：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@transaction</span>_ISOLATION;</span><br></pre></td></tr></table></figure>

<p>再按照下列SQL的顺序，执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session B</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>、开启事务，并查看数据</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 刘备</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 刘备</span></span><br><span class="line"></span><br><span class="line"># <span class="number">5</span>、再次查看数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 刘备</span></span><br><span class="line"></span><br><span class="line"># <span class="number">6</span>、提交当前事务，在查看数据</span><br><span class="line"><span class="keyword">commit</span> ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 张飞</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、修改数据（自动提交事务）</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;关羽&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>、修改数据（自动提交事务）</span><br><span class="line"><span class="keyword">update</span> customer <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，在Session B 中，每一次查询的结果都是一样的，<br>不管实际的数据怎样的变化，即使数据已经被SessionA所改变，且已提交。</p>
<p>但是这种隔离级别同样有这自己缺陷，它会发生幻读。</p>
<p>我们看下面的场景：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span>、开启事务，并查看数据</span><br><span class="line"># session B</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>、开启事务，并查看数据</span><br><span class="line"><span class="keyword">start</span> transaction ;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>; <span class="comment">-- null</span></span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>、插入指定ID的数据</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>; <span class="comment">-- null</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">values</span> (<span class="number">10</span>, <span class="string">&#x27;吕布&#x27;</span>); <span class="comment">-- 失败</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> ;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># session A</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>、插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> customer <span class="keyword">values</span> (<span class="number">10</span>, <span class="string">&#x27;小吕布&#x27;</span>); <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，SessionB在一个事务中，想要插入一条ID为10的用户。<br>重要的是，要第一步查询，已经确定了ID为10的用户并不存在。</p>
<p>但是在事务的过程中，Session A 插入了一条ID为10的客户，并成功提交事务。</p>
<p>等再回到Session B， 再想插入一条ID为10的客户，就报错了<code>Duplicate entry &#39;10&#39; for key &#39;customer.PRIMARY&#39;</code>。</p>
<p>其实，在Session B的操作中，逻辑都是没问题的。但是还是发生了幻读，导致了系统异常。</p>
<p>解决办法是，在Session B中，我们这样写select语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">for</span> <span class="keyword">update</span> ;</span><br></pre></td></tr></table></figure>

<p>在 select 语句后面， 添加一个<code>for update</code>，可以把<code>ID=10</code>给加上一个锁，<br>SessionA， 再想干扰，添加数据的时候，就会拿不到锁，而只能等待SessionB的事务完成，并释放锁。</p>
<p>所以保证了SessionB的原子性，杜绝的幻读。</p>
<h3 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h3><p>串行化，这种隔离级别，可以杜绝所有的干扰，包括（脏读、不可重复读、幻读）。</p>
<p>在此级别下，我们便不需要对 SELECT 操作显式加锁，InnoDB会自动加锁，事务安全，但性能很低。</p>
<p>非常不推荐使用。</p>
<h2 id="InnoDB的事务实现（MVCC）"><a href="#InnoDB的事务实现（MVCC）" class="headerlink" title="InnoDB的事务实现（MVCC）"></a>InnoDB的事务实现（MVCC）</h2><p>MVCC，多版本并发控制。<br>顾名思义，他会记录数据变更的版本（像git一样），形成一个版本链。</p>
<p>在通过对这个版本链中不同版本的处理，来实现事务，和事务隔离级别。</p>
<h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>在数据库行数据的结构中，除了我们存储的字段外，还有两个必不可少的隐藏字段：</p>
<p>当前事务ID(<code>trx_id)</code> 和 上个版本数据的引用(<code>roll_pointer</code>)。</p>
<p>直接上代码，我们用Java来模拟MVCC。</p>
<p>完整代码，请查看<a href="https://github.com/CPyeah/java-projets/tree/master/java-mvcc/src/main/java">这里</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Row</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前操作的事务id</span></span><br><span class="line">	<span class="keyword">private</span> Integer trx_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 历史记录的地址</span></span><br><span class="line">	<span class="keyword">private</span> Row&lt;T&gt; roll_pointer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主键ID</span></span><br><span class="line">	<span class="keyword">private</span> Integer primaryId;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 其他数据</span></span><br><span class="line">	<span class="keyword">private</span> T otherData;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 行锁</span></span><br><span class="line">	<span class="keyword">private</span> ReentrantLock rowLock;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以通过roll_pointer来找到所有的历史版本，可以实现回滚操作，也可以选择指定的版本来展示。</p>
<p>我们再看一下事务操作的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务控制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionController</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 当前活跃的事务列表</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; m_ids = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 全局事务ID</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">globeTransactionID</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取事务ID</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">getNextTransactionId</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> globeTransactionID.getAndAdd(<span class="number">100</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，加行锁</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">update</span><span class="params">(Row&lt;T&gt; newRow, Transaction transaction,</span></span><br><span class="line"><span class="params">			HashMap&lt;Integer, Row&lt;T&gt;&gt; tableData)</span> &#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">primaryId</span> <span class="operator">=</span> newRow.getPrimaryId();</span><br><span class="line">		Row&lt;T&gt; oldRow = tableData.get(primaryId);</span><br><span class="line">		<span class="keyword">if</span> (oldRow == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Data does not exist&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			newRow.setTrx_id(transaction.getTransactionId());</span><br><span class="line">			newRow.setRoll_pointer(oldRow); <span class="comment">// 更新版本链</span></span><br><span class="line">			tableData.put(primaryId, newRow);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> newRow.getOtherData();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启一个事务</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Transaction <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Integer</span> <span class="variable">transactionId</span> <span class="operator">=</span> getNextTransactionId();</span><br><span class="line"></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">transaction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Transaction</span>();</span><br><span class="line">		transaction.setTransactionId(transactionId);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 把当前的事务ID，存放到活跃事务列表中</span></span><br><span class="line">		m_ids.add(transactionId);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> transaction;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 事务提交</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(Transaction transaction)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (transaction.getLock() != <span class="literal">null</span>) &#123;</span><br><span class="line">			transaction.getLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在活跃事务列表中，移除事务ID</span></span><br><span class="line">		m_ids.remove(transaction.getTransactionId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中几个关键点：</p>
<ul>
<li>全局事务ID ： 全局唯一，递增</li>
<li>当前活跃的事务列表： 这里维护所有的未提交的事务的ID，</li>
<li>开启一个事务： 生成一个事务ID，并把这个事务，维护到活跃事务列表中</li>
<li>更新数据： 新数据赋予事务ID，新数据可以引用到上个版本的老数据，加行锁</li>
<li>提交事务： 解锁，把活跃事务列表中的删除当前事务</li>
</ul>
<p>我们接下来看下事务是怎么运转的：</p>
<p>我们设计一个这样的测试：</p>
<p>完整代码请看<a href="https://github.com/CPyeah/java-projets/tree/master/java-mvcc/src/test/java">这里</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeAll;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TransactionControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@BeforeAll</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		Row&lt;Customer&gt; row = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;刘备&quot;</span>);</span><br><span class="line"></span><br><span class="line">		Customer.tableData.put(row.getPrimaryId(), row);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开启事务A</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">transaction_A</span> <span class="operator">=</span> TransactionController.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开启事务B</span></span><br><span class="line">		<span class="type">Transaction</span> <span class="variable">transaction_B</span> <span class="operator">=</span> TransactionController.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">		Row&lt;Customer&gt; 关羽 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;关羽&quot;</span>);</span><br><span class="line">		TransactionController.update(关羽, transaction_A, Customer.tableData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">		Row&lt;Customer&gt; 张飞 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">		TransactionController.update(张飞, transaction_A, Customer.tableData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 事务A提交，并释放锁</span></span><br><span class="line">		TransactionController.commit(transaction_A);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">		Row&lt;Customer&gt; 赵云 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;赵云&quot;</span>);</span><br><span class="line">		TransactionController.update(赵云, transaction_B, Customer.tableData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">		Row&lt;Customer&gt; 诸葛亮 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;诸葛亮&quot;</span>);</span><br><span class="line">		TransactionController.update(诸葛亮, transaction_B, Customer.tableData);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//commit</span></span><br><span class="line">		TransactionController.commit(transaction_B);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 打印undo日志链表</span></span><br><span class="line">		printData(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">		<span class="comment">// 1-诸葛亮(200) -&gt; 1-赵云(200) -&gt; 1-张飞(100) -&gt; 1-关羽(100) -&gt; 1-刘备(null)</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printData</span><span class="params">(Row&lt;Customer&gt; customerRow)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(toString(customerRow));</span><br><span class="line"></span><br><span class="line">		Row&lt;Customer&gt; currentPointer = customerRow;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (currentPointer.getRoll_pointer() != <span class="literal">null</span>) &#123;</span><br><span class="line">			currentPointer = currentPointer.getRoll_pointer();</span><br><span class="line">			sb.append(<span class="string">&quot; -&gt; &quot;</span>)</span><br><span class="line">					.append(toString(currentPointer));</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sb);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> String <span class="title function_">toString</span><span class="params">(Row&lt;Customer&gt; customerRow)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> customerRow.getPrimaryId() + <span class="string">&quot;-&quot;</span> + customerRow.getOtherData().getName()</span><br><span class="line">				+ <span class="string">&quot;(&quot;</span></span><br><span class="line">				+ customerRow.getTrx_id()</span><br><span class="line">				+ <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Row&lt;Customer&gt; <span class="title function_">getCustomerRow</span><span class="params">(Integer id, String name)</span> &#123;</span><br><span class="line">		<span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">		customer.setId(id);</span><br><span class="line">		customer.setName(name);</span><br><span class="line"></span><br><span class="line">		Row&lt;Customer&gt; row = <span class="keyword">new</span> <span class="title class_">Row</span>&lt;&gt;();</span><br><span class="line">		row.setPrimaryId(customer.getId());</span><br><span class="line">		row.setOtherData(customer);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> row;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中使用<code>Customer.tableData</code>来模拟存储数据。</p>
<p>在<code>test1</code>中，我们开启了两个事务，并执行了<code>update</code>操作，最总形成了一个版本链：</p>
<p>效果如图所示：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/O2WJFy.png"></p>
<blockquote>
<p>两个事务不能交叉修改同一个数据，因为在<code>Transaction_A</code>第一次执行<code>update</code>操作的时候，<br>就给这个数据加上了行锁，<code>Transaction_B</code>必须等到<code>Transaction_A</code>提交，释放了锁，<br>才可以进行<code>Transaction_B</code>的<code>update</code>操作。</p>
</blockquote>
<p>得到的数据<code>版本链</code>效果如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/cfz3Lp.png"></p>
<h3 id="隔离级别的实现"><a href="#隔离级别的实现" class="headerlink" title="隔离级别的实现"></a>隔离级别的实现</h3><p>我们知道有四大隔离级别，我们来看下它们是怎样实现的。</p>
<h4 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a>SERIALIZABLE</h4><p>串行化，这种级别下，不管是更新，还是查询，它都会加锁，<br>所以每次查询的数据，肯定是事务已经提交后的数据，<br>而每次更新数据的过程中，数据不会再发生变化。<br>不管是查询，还是更新数据的过程中，版本链都不会更新。</p>
<h4 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ UNCOMMITTED"></a>READ UNCOMMITTED</h4><p>读未提交，它的实现也很简单，每次查看数据的时候，都读取版本链中最新的数据，不管操作这个数据的事务有没有提交。</p>
<h4 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ COMMITTED"></a>READ COMMITTED</h4><p>读已提交，<br>他会在每次查询的时候，都会生成一个<code>ReadView</code>，<br>它会拿到版本链，会从版本链从上往下搜索，<br>找到已经提交了的，最新的一个版本的数据。</p>
<h4 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE READ"></a>REPEATABLE READ</h4><p>可重复读<br>它会在当前的事务中，第一次查询的时候，生成一个<code>ReadView</code>，<br>也是从版本链中搜索，找到最新一个已经提交了的事务，<br>但是不同于读已提交的是，这个ReadView只生成一次，<br>以后的每次查询，都会查看这同一个ReadView。<br>从而保证<code>可重复读</code>。</p>
<h3 id="ReadView获取"><a href="#ReadView获取" class="headerlink" title="ReadView获取"></a>ReadView获取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取到ReadView</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Row&lt;T&gt; <span class="title function_">readView</span><span class="params">(Row&lt;T&gt; chain)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (chain == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m_ids.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">return</span> chain;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该值代表生成readView时m_ids中的最小值</span></span><br><span class="line">	<span class="type">Integer</span> <span class="variable">min_trx_id</span> <span class="operator">=</span> m_ids.get(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (Integer id : m_ids) &#123;</span><br><span class="line">		min_trx_id = Math.min(min_trx_id, id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该值代表生成readView时系统中应该分配给下一个事务的id值</span></span><br><span class="line">	<span class="type">Integer</span> <span class="variable">max_trx_id</span> <span class="operator">=</span> getNextTransactionId();</span><br><span class="line"></span><br><span class="line">	Row&lt;T&gt; pointer = chain;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isThisReadView(pointer, min_trx_id, max_trx_id)) &#123;</span><br><span class="line">			<span class="keyword">return</span> pointer;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pointer.getRoll_pointer() != <span class="literal">null</span>) &#123;</span><br><span class="line">			pointer = pointer.getRoll_pointer();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否此版本为ReadView</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">isThisReadView</span><span class="params">(Row&lt;T&gt; pointer,</span></span><br><span class="line"><span class="params">		Integer min,</span></span><br><span class="line"><span class="params">		Integer max)</span> &#123;</span><br><span class="line">	<span class="comment">// 如果被访问版本的trx_id属性值小于m_ids列表中最小的事务id，</span></span><br><span class="line">	<span class="comment">// 表明生成该版本的事务在生成ReadView前已经提交，</span></span><br><span class="line">	<span class="comment">// 所以该版本可以被当前事务访问。</span></span><br><span class="line">	<span class="keyword">if</span> (pointer.getTrx_id() &lt; min) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果被访问版本的trx_id属性值大于m_ids列表中最大的事务id，</span></span><br><span class="line">	<span class="comment">// 表明生成该版本的事务在生成ReadView后才生成，</span></span><br><span class="line">	<span class="comment">// 所以该版本不可以被当前事务访问。</span></span><br><span class="line">	<span class="keyword">if</span> (pointer.getTrx_id() &gt; max) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果被访问版本的trx_id属性值在m_ids列表中最大的事务id和最小事务id之间，</span></span><br><span class="line">	<span class="comment">// 那就需要判断一下trx_id属性值是不是在m_ids列表中，</span></span><br><span class="line">	<span class="comment">// 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；</span></span><br><span class="line">	<span class="comment">// 如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</span></span><br><span class="line">	<span class="keyword">if</span> (m_ids.contains(pointer.getTrx_id())) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们在test1中，加上查看readView的效果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启事务A</span></span><br><span class="line">	<span class="type">Transaction</span> <span class="variable">transaction_A</span> <span class="operator">=</span> TransactionController.start();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 开启事务B</span></span><br><span class="line">	<span class="type">Transaction</span> <span class="variable">transaction_B</span> <span class="operator">=</span> TransactionController.start();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">	Row&lt;Customer&gt; 关羽 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;关羽&quot;</span>);</span><br><span class="line">	TransactionController.update(关羽, transaction_A, Customer.tableData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看readView</span></span><br><span class="line">	Row&lt;Customer&gt; readView = TransactionController.readView(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	System.out.println(toString(readView));<span class="comment">// 1-刘备(0)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">	Row&lt;Customer&gt; 张飞 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">	TransactionController.update(张飞, transaction_A, Customer.tableData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 事务A提交，并释放锁</span></span><br><span class="line">	TransactionController.commit(transaction_A);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看readView</span></span><br><span class="line">	readView = TransactionController.readView(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	System.out.println(toString(readView));<span class="comment">// 1-张飞(100)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">	Row&lt;Customer&gt; 赵云 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;赵云&quot;</span>);</span><br><span class="line">	TransactionController.update(赵云, transaction_B, Customer.tableData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看readView</span></span><br><span class="line">	readView = TransactionController.readView(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	System.out.println(toString(readView)); <span class="comment">//1-张飞(100)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据，同时会加上行锁</span></span><br><span class="line">	Row&lt;Customer&gt; 诸葛亮 = getCustomerRow(<span class="number">1</span>, <span class="string">&quot;诸葛亮&quot;</span>);</span><br><span class="line">	TransactionController.update(诸葛亮, transaction_B, Customer.tableData);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//commit</span></span><br><span class="line">	TransactionController.commit(transaction_B);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看readView</span></span><br><span class="line">	readView = TransactionController.readView(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	System.out.println(toString(readView)); <span class="comment">// 1-诸葛亮(200)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印undo日志链表</span></span><br><span class="line">	printData(Customer.tableData.get(<span class="number">1</span>));</span><br><span class="line">	<span class="comment">// 1-诸葛亮(200) -&gt; 1-赵云(200) -&gt; 1-张飞(100) -&gt; 1-关羽(100) -&gt; 1-刘备(null)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完整代码请查看<a href="https://github.com/CPyeah/java-projets/blob/master/java-mvcc/src/test/java/TransactionControllerTest.java">这里</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经学习了MySQL事务到相关知识。</p>
<ul>
<li>我们了解到了事务到概念</li>
<li>学习了事务的常见用法</li>
<li>了解了事务的四大特性 ACID</li>
<li>并重点说了事务的隔离特定</li>
<li>实践了不同事务隔离级别下的效果</li>
<li>使用Java代码模拟了MVCC的实现</li>
<li>并通过MVCC，掌握事务隔离级别的实现原理</li>
</ul>
<p>本篇文章，希望大家好好掌握。😊</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL调优</title>
    <url>/2021/09/11/database/MySQL%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章，我们将谈到SQL优化的相关知识。</p>
<ul>
<li>我们会讲到如何合理定义数据结构</li>
<li>如何设计高效的索引</li>
<li>如果写出高效的SQL语句</li>
<li>如果发生了慢查询，我们如何分析</li>
<li>如何选择其他的组件来替换MySQL</li>
</ul>
<p>现在，我们开始吧！！</p>
<span id="more"></span>

<h2 id="数据结构的优化"><a href="#数据结构的优化" class="headerlink" title="数据结构的优化"></a>数据结构的优化</h2><h3 id="数据类型的选择"><a href="#数据类型的选择" class="headerlink" title="数据类型的选择"></a>数据类型的选择</h3><h4 id="使用最佳的数据类型"><a href="#使用最佳的数据类型" class="headerlink" title="使用最佳的数据类型"></a>使用最佳的数据类型</h4><p>数据类型越短越好，<br>越小的数据类型，往往意味着更好的效率。</p>
<p>整型的效率会比字符串的性能高<br>使用Date类型来存储时间，比字符串类型的效率来的高。</p>
<h4 id="尽量使用非空"><a href="#尽量使用非空" class="headerlink" title="尽量使用非空"></a>尽量使用非空</h4><p>null会影响到索引效率，查询的返回结果。<br>可会可能引发业务层的空指针。</p>
<p>我们可以给字段设为not null，且设定一个默认值。</p>
<h4 id="可以使用UNSIGNED来修饰数字类型"><a href="#可以使用UNSIGNED来修饰数字类型" class="headerlink" title="可以使用UNSIGNED来修饰数字类型"></a>可以使用UNSIGNED来修饰数字类型</h4><p>无符号数字的存储效率是有符号数组的将近一倍。</p>
<p>比如ID，金额等一些确定是正数的数字类型，<br>我们可以使用UNSIGNED来修饰。</p>
<h3 id="表的设计"><a href="#表的设计" class="headerlink" title="表的设计"></a>表的设计</h3><h4 id="避免宽表"><a href="#避免宽表" class="headerlink" title="避免宽表"></a>避免宽表</h4><p>宽表意味着一条记录有很多字段。<br>我们尽量避免一张表有多于100个字段。</p>
<p>他会在查询的时候，增加性能的负担。<br>尤其是使用alter操作来改变表结构的时候，<br>会非常消耗性能。</p>
<p>我们可以给一张宽表拆分成不同的小表。<br>比如：一张订单表，我们可以拆分成<br>订单主表；订单金额表；订单商品表；订单物流表 等等。</p>
<h4 id="范式-and-反范式"><a href="#范式-and-反范式" class="headerlink" title="范式 and 反范式"></a>范式 and 反范式</h4><p>满足范式的设计，往往会更加精简，<br>但是如果需要查询更多的信息，需要连表查询。</p>
<p>比如说，订单表里面只有买家ID这个字段，<br>在页面上展示的时候，往往是需要展示买家名称，<br>这个时候，就需要连表查询，关联订单表，和客户表，<br>而在我们分布式系统中，更需要单独调用别的中台的接口，来填充信息。</p>
<p>而反范式，就是把一些数据给冗余下来，以提高查询效率。</p>
<p>在高并发，高性能，高数据量的时候，<br>往往都是单表查询，<br>反范式，冗余会使用的更多。<br>冗余可以大大简化我们的SQL，提高我们索引的命中率。</p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><blockquote>
<p>好的索引，是查询效率提升的关键</p>
</blockquote>
<h3 id="什么时候添加索引"><a href="#什么时候添加索引" class="headerlink" title="什么时候添加索引"></a>什么时候添加索引</h3><p>如果我们表的数据只有十几行甚至几行的时候，<br>我们不要添加索引。<br>因为这个时候，全表扫描的效率往往更好，<br>而索引的维护，还会影响到数据的修改效率。</p>
<p>如果我们的表数据量很多，<br>我们推荐设计合适的索引来提高查询效率。</p>
<p>如果我们的表数据非常非常多，<br>我们考虑使用分区，分表</p>
<h3 id="添加合适的索引"><a href="#添加合适的索引" class="headerlink" title="添加合适的索引"></a>添加合适的索引</h3><p>在查询条件上，<br>在关联字段上，<br>在排序字段上，<br>在分组字段上，<br>可以添加索引。</p>
<p>添加索引的字段值区分度越高越好，比如ID<br>像枚举类型的值不适合设置成索引。</p>
<p>索引不是越多越好，索引会占用空间，索引会影响修改数据的效率。</p>
<h3 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h3><p>根据业务中的查询条件，添加合适的组合索引<br>遵循最左匹配原则</p>
<h3 id="使用覆盖索引"><a href="#使用覆盖索引" class="headerlink" title="使用覆盖索引"></a>使用覆盖索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> buyer_id <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> buyer_id <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们在订单表（order）中的买家ID（buyer_id）上建立索引，</p>
<p>上面第一条的SQL会比第二条的执行速度快很多。</p>
<p>因为第一条索引直接走了覆盖索引，而不用回表查询，大大提高效率。</p>
<h3 id="精简索引字段"><a href="#精简索引字段" class="headerlink" title="精简索引字段"></a>精简索引字段</h3><p>如果索引字段太长，且有很多重复的字符，我们可以截取一部分来设成索引。</p>
<p>可以减少索引体积。</p>
<p>比如说email，或者网站地址，或者非常长的ID</p>
<p>把区分度高的部分，截取出来，设成索引。</p>
<h2 id="SQL语句编写的优化"><a href="#SQL语句编写的优化" class="headerlink" title="SQL语句编写的优化"></a>SQL语句编写的优化</h2><h3 id="基础SQL原则"><a href="#基础SQL原则" class="headerlink" title="基础SQL原则"></a>基础SQL原则</h3><ul>
<li>只返回必要的行，避免<code>select *</code>这样的语句。</li>
<li>where条件里面控制范围</li>
<li>limit 控制返回条数</li>
<li>缓存热点数据，使用服务端缓存（redis），避免使用MySQL缓存</li>
<li>查询条件 和 索引相匹配</li>
</ul>
<h3 id="count函数优化"><a href="#count函数优化" class="headerlink" title="count函数优化"></a>count函数优化</h3><p>一般来说，我们尽量使用<code>count(*)</code>，来统计行数，<br>但是还有一种用法，我们可以使用<code>count(column_1)</code>来统计，column_1不为空的记录数。</p>
<p>在column_1不为空的情况下：<br>count(*) &#x3D;&#x3D; count(column_1)</p>
<p>在column_1有null值的情况下：<br>count(*) &gt; column_1</p>
<p>这点需要大家注意区别。</p>
<p>在不需要准确数据的情况下，<br>我们可以使用 explain 来替代 count。</p>
<p>explain会给出一个总数目的估计值，<br>explain只会给出一个查询计划，并不会真正去存储引擎上执行，<br>它的执行效率是高的。</p>
<h3 id="避免深分页"><a href="#避免深分页" class="headerlink" title="避免深分页"></a>避免深分页</h3><p>我们要避免这样的SQL。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> limit <span class="number">1000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这样会先把前面的1010条数据都查询出来，在截取后10条记录返回。<br>很营销效率。</p>
<p>在这种情况下，我会推荐使用游标的来查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="string">&#x27;&#x27;</span> limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="分解大批量"><a href="#分解大批量" class="headerlink" title="分解大批量"></a>分解大批量</h3><p>如果我们需要清楚历史日志数据，我们可能会这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> log <span class="keyword">where</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果历史数据非常大，这样会非常影响数据库的性能，<br>并会锁住很多记录，占用系统资源。</p>
<p>可能会让很多小而重要的查询发生中断。</p>
<p>我们需要这样做：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> log <span class="keyword">where</span> create_time <span class="operator">&lt;</span> <span class="string">&#x27;&#x27;</span> limit <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>并在业务代码中，循环删除。</p>
<h2 id="慢查询及其分析"><a href="#慢查询及其分析" class="headerlink" title="慢查询及其分析"></a>慢查询及其分析</h2><h3 id="开启慢查询监控"><a href="#开启慢查询监控" class="headerlink" title="开启慢查询监控"></a>开启慢查询监控</h3><p>我们可以先查看一下配置，直接执行下面的SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>得到效果如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/O1oh8f.png"><br>很明显，我还没有开启慢查询监控。</p>
<p>我们继续再修改配置，开启监控：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="keyword">ON</span>;</span><br></pre></td></tr></table></figure>

<p>在设置一下触发时间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;long%&#x27;</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>默认的慢查询的触发时间是10秒，太长了<br>我们配置成合适的触发时间， 我这里配置的是1秒。</p>
<p>Tip：配置好之后，需要重新打开新的session查看配置。</p>
<p>一切完成之后，如果我们再发生了慢查询，就会在对应的位置生成log啦。<br>我们再可以使用explain分析SQL</p>
<h3 id="使用EXPLAIN来分析SQL执行计划"><a href="#使用EXPLAIN来分析SQL执行计划" class="headerlink" title="使用EXPLAIN来分析SQL执行计划"></a>使用EXPLAIN来分析SQL执行计划</h3><p>首先上<a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">官方文档</a><br>最权威</p>
<p>explain SQL 是一个非常复杂的过程，里面的细节很多，<br>在这里只做一个简单的介绍，和常用的排查慢查询的方法。</p>
<h4 id="执行和字段解释"><a href="#执行和字段解释" class="headerlink" title="执行和字段解释"></a>执行和字段解释</h4><p>我们拿到了慢查询的SQL，直接再语句的前面加上一个<code>explain</code> 就行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> customer <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到一下结果：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/FZy098.png"></p>
<p>一共返回了12个字段，我来看一下每一个字段代表什么意思。</p>
<table>
<thead>
<tr>
<th>Column</th>
<th>JSON Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_id"><code>id</code></a></td>
<td><code>select_id</code></td>
<td>表示查询中执行select子句或者操作表的顺序，id的值越大，代表优先级越高，越先执行</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type"><code>select_type</code></a></td>
<td>None</td>
<td>表示 select 查询的类型，主要是用于区分各种复杂的查询，例如：普通查询、联合查询、子查询等</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_table"><code>table</code></a></td>
<td><code>table_name</code></td>
<td>查询的表名，并不一定是真实存在的表，有别名显示别名，也可能为临时表</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_partitions"><code>partitions</code></a></td>
<td><code>partitions</code></td>
<td>查询时匹配到的分区信息，对于非分区表值为NULL，当查询的是分区表时，partitions显示分区表命中的分区情况</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_type"><code>type</code></a></td>
<td><code>access_type</code></td>
<td>查询使用了何种类型，它在 SQL优化中是一个非常重要的指标</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td>
<td><code>possible_keys</code></td>
<td>表示在MySQL中通过哪些索引，能让我们在表中找到想要的记录，一旦查询涉及到的某个字段上存在索引，则索引将被列出，但这个索引并不定一会是最终查询数据时所被用到的索引</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key"><code>key</code></a></td>
<td><code>key</code></td>
<td>区别于possible_keys，key是查询中实际使用到的索引，若没有使用索引，显示为NULL</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key_len"><code>key_len</code></a></td>
<td><code>key_length</code></td>
<td>表示查询用到的索引长度（字节数），原则上长度越短越好</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_ref"><code>ref</code></a></td>
<td><code>ref</code></td>
<td>搜索关联字段，有可能是常数、多表关联字段、函数等</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_rows"><code>rows</code></a></td>
<td><code>rows</code></td>
<td>以表的统计信息和索引使用情况，估算要找到我们所需的记录，需要读取的行数。</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_filtered"><code>filtered</code></a></td>
<td><code>filtered</code></td>
<td>这个是一个百分比的值，表里符合条件的记录数的百分比。简单点说，这个字段表示存储引擎返回的数据在经过过滤后，剩下满足条件的记录数量的比例</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra"><code>Extra</code></a></td>
<td>None</td>
<td>不适合在其他列中显示的信息，Explain 中的很多额外的信息会在 Extra 字段显示</td>
</tr>
</tbody></table>
<h4 id="重点排查顺序"><a href="#重点排查顺序" class="headerlink" title="重点排查顺序"></a>重点排查顺序</h4><p>explain了一条SQL之后，我们的排查流程如下：</p>
<ul>
<li><p>type</p>
<ul>
<li>system &gt; const &gt; eq_ref &gt; ref &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</li>
<li>一般最少要达到range等级，最好达到ref等级</li>
</ul>
</li>
<li><p>key</p>
<ul>
<li>实际上用到的索引</li>
</ul>
</li>
<li><p>key_len</p>
<ul>
<li>使用到的索引长度，可以算出联合索引中走了几个索引</li>
<li>utf8中一个字符占3个字节， 允许null +1， not null +2</li>
</ul>
</li>
<li><p>Extra</p>
<ul>
<li>一些额外信息，表示使用了哪些操作</li>
<li>像使用了覆盖索引，索引下推，这都是比较好的</li>
<li>像使用了文件排序，需要优化下，尽量使用索引排序</li>
</ul>
</li>
</ul>
<h2 id="使用其他的组件来替代MySQL"><a href="#使用其他的组件来替代MySQL" class="headerlink" title="使用其他的组件来替代MySQL"></a>使用其他的组件来替代MySQL</h2><ul>
<li>一些经常查询，或者修改频次高的数据，我们尽量放到Redis里面</li>
<li>如果需要使用到全文索引，首推Elastic Search</li>
<li>如果是类似日志的数据，数据量大，不需要连表，不需要复杂的索引，可以使用MongoDB</li>
</ul>
<p>但是MySQL是一款非常成熟，非常稳定的数据库，在一般的条件下，我们还是会首选MySQL。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们学到了MySQL优化的一些相关知识。<br>我们从建表开始，选择合适的数据结构，索引的建立，<br>到生产中，遇到的慢查询的处理。</p>
<p>希望对大家有所帮助！！Peace～</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高级数据结构</title>
    <url>/2021/04/26/database/Redis%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这篇文章介绍一下高级Redis数据结构，及其用法。</p>
<p>在工作的使用频率很高。</p>
<ul>
<li>分布式锁</li>
<li>队列</li>
<li>位图</li>
<li>布隆过滤器</li>
<li>HyperLogLog</li>
<li>限流器</li>
<li>GeoHash</li>
</ul>
<span id="more"></span>

<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>大家都知道，线程安全在我们的系统当中，非常重要。<br>如果多个线程同时操作一笔订单，很可能造成数据不一致。</p>
<p>而在分布式系统中，<code>synchronized</code>就排不上用场了，需要使用分布式锁来解决线程安全的问题。</p>
<p>而使用redis就是一个很好的选择。</p>
<p>使用<code>Redisson</code>封装的分布式锁，非常简单，功能也相当强大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(<span class="string">&quot;my-lock&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do somethings</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了基础的分布式锁，Redisson还提供了：</p>
<ul>
<li>可重入锁</li>
<li>公平锁</li>
<li>自旋锁</li>
<li>读写锁</li>
<li>锁超时时间</li>
<li>获取锁的时间限制</li>
</ul>
<p>功能强大且使用方便，具体参考<a href="https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers">官方文档</a>。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是我们一种常用的数据结构。也有很多专业的中间件来实现。比如：Kafka，RabbitMQ，RocketMQ。。。<br>而redis也支持消息队列，而且功能还不少。有：</p>
<ul>
<li>简单的消息队列</li>
<li>延迟队列</li>
<li>阻塞队列</li>
<li>消息的多播</li>
</ul>
<p>Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用<code>rpush/lpush</code>操作入队列，使用 <code>lpop/rpop</code> 来出队列。</p>
<p>延时队列可以通过 Redis 的 zset(有序列表) 来实现。我们将消息序列化成一个字符串作为 zset 的 value，这个消息的到期处理时间作为 score。</p>
<p>Redisson对此都有很好的支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单队列</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simple</span><span class="params">()</span> &#123;</span><br><span class="line">    RQueue&lt;Object&gt; queue = redissonClient.getQueue(<span class="string">&quot;simple&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (poll == <span class="literal">null</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(poll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞队列</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blockQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    RBlockingQueue&lt;Object&gt; queue = redissonClient.getBlockingQueue(<span class="string">&quot;block&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                queue.put(i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 阻塞take</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">poll</span> <span class="operator">=</span> queue.take();</span><br><span class="line">        System.out.println(poll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟队列</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delayQueue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    RBlockingQueue&lt;Object&gt; blockingQueue = redissonClient.getBlockingQueue(<span class="string">&quot;delayQueue1&quot;</span>);</span><br><span class="line">    RDelayedQueue&lt;Object&gt; delayQueue = redissonClient</span><br><span class="line">            .getDelayedQueue(blockingQueue);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">        delayQueue.offerAsync(i, (<span class="number">500</span> - i * <span class="number">10</span>), TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blockingQueue = redissonClient.getBlockingQueue(<span class="string">&quot;delayQueue&quot;</span>);</span><br><span class="line">    System.out.println(blockingQueue.size());</span><br><span class="line">    redissonClient.getDelayedQueue(blockingQueue);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; blockingQueue.size(); i++) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">poll</span> <span class="operator">=</span> blockingQueue.take();</span><br><span class="line">        System.out.println(poll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上都是消息队列的<code>生产者-消费者模式</code>，而消息队列的另外一种模式<code>订阅模式</code>，redis也能实现。</p>
<p>有两种数据结构支持。</p>
<ul>
<li>PubSub</li>
<li>Stream</li>
</ul>
<h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>位图完全是为了节约空间而设计的，我们可以把它想象成一个巨大的List，而里面只存放<code>1/0</code>。</p>
<p>比如记录一个用户一年的签到记录，我们可以用位图来记录，签到的就是<code>1</code>，未签到的是<code>0</code>。</p>
<p>使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">RBitSet</span> <span class="variable">bitset</span> <span class="operator">=</span> redissonClient.getBitSet(<span class="string">&quot;bitset&quot;</span>);</span><br><span class="line">    bitset.set(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    System.out.println(bitset.get(<span class="number">0</span>));</span><br><span class="line">    System.out.println(bitset.get(<span class="number">1</span>));</span><br><span class="line">    System.out.println(bitset.incrementAndGetInteger(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>我们如何判断一个ID是否在我们的系统里。我们有两种基本的方法来判断：</p>
<ul>
<li>我们把这个ID拿到数据查询一下就知道来</li>
<li>我们把所有的ID保存的一个Set里面，判断这个新的ID在不在这个Set里面</li>
</ul>
<p>但是上面两种方法有一个致命的缺陷：<br>就是在数据量特别大的时候，非常消耗性能，不管是对数据库的IO，还是保存所有的ID。</p>
<p>这个是有个非常精妙的算法 - <code>布隆过滤器</code>。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/HeAOem.png"></p>
<p>它的原理非常简单：<br>底层是一个位图，并且有若干种Hash算法。<br>在新增ID的时候，对每一个ID做多种Hash运算，并在位图中得到若干位置，把对应的位置变成<code>1</code>。<br>而判断一个ID是否在系统中，也对这个ID做同样的Hash运算，得到若干位置，判断位图中的对应位置是否都是<code>1</code>。<br>如果都是<code>1</code>的话，表示大概率可能存在于系统中，如果有一个<code>0</code>，表示肯定不在系统中。</p>
<p>Redisson也做了封装，使用非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    RBloomFilter&lt;String&gt; bloom = redissonClient.getBloomFilter(<span class="string">&quot;bloom&quot;</span>);</span><br><span class="line">    bloom.tryInit(<span class="number">1000</span>, <span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        bloom.add(<span class="string">&quot;user_id_&quot;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">80</span>; i &lt; <span class="number">120</span>; i++) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">contains</span> <span class="operator">=</span> bloom.contains(<span class="string">&quot;user_id_&quot;</span> + i);</span><br><span class="line">        System.out.println(<span class="string">&quot;user_id_&quot;</span> + i + <span class="string">&quot;  -&gt;  &quot;</span> + contains);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><p>HyperLogLog是一个很神奇的数据结构。</p>
<p>我们先来说两个概念： PV 和 UV。<br>PV：简单来说就是流量。只要有一次访问，不管是不是同一个人，就记一个流量。<br>UV：独立访客，单位时间内，一个新的访客，就算一个UV。</p>
<p>在我们的统计中，PV很好统计，来一次访问，PV值就往上加1，顶多需要保持一下自增的原子性。<br>而计算UV，在互联网领域中一个是一个难题。</p>
<p>通常来说我们计算一个网站一天的UV，我们需要把每一个访客的ID给记录下来，计算时去重。<br>这样就导致一个问题，如果访问量非常大，就非常的消耗存储空间。</p>
<p>这个时候，HyperLogLog就能派上用场了。</p>
<p>我们先看下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">compareTest</span><span class="params">()</span> &#123;</span><br><span class="line">    RHyperLogLog&lt;String&gt; today = redisson.getHyperLogLog(<span class="string">&quot;UV_&quot;</span> + LocalDate.now());</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;id_&quot;</span> + random.nextInt(<span class="number">500</span>);</span><br><span class="line">        today.add(userId);</span><br><span class="line">        set.add(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;RHyperLogLog: &quot;</span> + today.count());</span><br><span class="line">    System.out.println(<span class="string">&quot;set count: &quot;</span> + set.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用的Set方法，和HyperLogLog，两个做一个比较。<br>从结果可以看出，两者的差距非常小，但是HyperLogLog并没有把每一个ID都记录下来，节约了大量存储空间。</p>
<p>HyperLogLog的原理相对复杂，具体可以参考这篇<a href="http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">论文</a>。</p>
<p>这里我来介绍一下它的思想：<br>假设我们有两个网站，需要比较一下他们的UV，看哪个网站的访问率高。<br>假设访问用户的ID使用手机号码表示，如：1xxxxxxxxxx<br>我们不想把每个访客的手机号码都记录下来，因为太浪费存储空间了。<br>我们可以定一个规则，我们只记录当天客户中，手机尾号为<code>0</code>位数最高的手机号码。<br>比如说，第一个网站记录下来的手机号码是：18322333000，末尾有3个0，<br>而第二的网站记录下来的手机号码是：18623000000，末尾有6个0。<br>我们就可以判断出，第二的网站的访问的人数更多。<br>大家体会一下。</p>
<p>HyperLogLog还有一个重要的概念，就是合并。<br>我们可以把连续7天的UV，合并成这一周的UV，并保证准确性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeTest</span><span class="params">()</span> &#123;</span><br><span class="line">    RHyperLogLog&lt;String&gt; today = redisson.getHyperLogLog(<span class="string">&quot;UV_&quot;</span> + LocalDate.now());</span><br><span class="line">    RHyperLogLog&lt;String&gt; nextDay = redisson.getHyperLogLog(<span class="string">&quot;UV_&quot;</span> + LocalDate.now().plusDays(<span class="number">1</span>));</span><br><span class="line">    HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;id_&quot;</span> + random.nextInt(<span class="number">1000</span>);</span><br><span class="line">        today.add(userId);</span><br><span class="line">        set.add(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> <span class="string">&quot;id_&quot;</span> + random.nextInt(<span class="number">2000</span>);</span><br><span class="line">        nextDay.add(userId);</span><br><span class="line">        set.add(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    today.mergeWith(nextDay.getName());</span><br><span class="line">    System.out.println(<span class="string">&quot;RHyperLogLog: &quot;</span> + today.count());</span><br><span class="line">    System.out.println(<span class="string">&quot;set count: &quot;</span> + set.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="限流器"><a href="#限流器" class="headerlink" title="限流器"></a>限流器</h2><p>限流器在我们的生产中非常重要，也很常用。Redis也有封装好的限流器。<br>实现了分布式限流器的功能。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// redisson用了zset来记录请求的信息，这样可以非常巧妙的通过比较score，也就是请求的时间戳，来判断当前请求距离上一个请求有没有超过一个令牌生产周期。</span></span><br><span class="line">    <span class="comment">// 如果超过了，则说明令牌桶中的令牌需要生产，之前用掉了多少个就生产多少个，而之前用掉了多少个令牌的信息也在zset中保存了。</span></span><br><span class="line">    <span class="type">RRateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> redissonClient.getRateLimiter(<span class="string">&quot;limiter_1&quot;</span>);</span><br><span class="line">    <span class="comment">// 1号限流器， 每一秒 允许一个请求</span></span><br><span class="line">    limiter.trySetRate(RateType.PER_CLIENT, <span class="number">1</span>, <span class="number">1</span>, RateIntervalUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 阻塞</span></span><br><span class="line"><span class="comment">//			limiter.acquire(1);</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> limiter.tryAcquire(<span class="number">1</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="comment">// 快速失败</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; failed !&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; -&gt; &quot;</span> + LocalDateTime.now());</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">12000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Redisson真好用！</p>
</blockquote>
<h2 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h2><p>Redis也提供了Geo功能，可以很方便实现附近的人，两坐标之间的距离等功能。<br>它的原理是把经纬度坐标，做Hash，得到一个分数，用zset做存储。<br>Hash算法的原理，是把整个地球当作一个平面，并把这个平面切割成很多很多的小块，并对每个方块做编码。<br>如果两个点所在的方块越接近，表示这两个点越接近。 当然，有一点点误差。<br>使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    RGeo&lt;Object&gt; geo = redissonClient.getGeo(<span class="string">&quot;geo&quot;</span>);</span><br><span class="line">    <span class="type">GeoEntry</span> <span class="variable">juejin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeoEntry</span>(<span class="number">116.48105</span>, <span class="number">39.996794</span>, <span class="string">&quot;juejin&quot;</span>);</span><br><span class="line">    geo.add(juejin);</span><br><span class="line">    geo.add(<span class="number">116.514203</span>, <span class="number">39.905409</span>, <span class="string">&quot;ireader&quot;</span>);</span><br><span class="line">    geo.add(<span class="number">116.489033</span>, <span class="number">40.007669</span>, <span class="string">&quot;meituan&quot;</span>);</span><br><span class="line">    geo.add(<span class="number">116.562108</span>, <span class="number">39.787602</span>, <span class="string">&quot;jd&quot;</span>);</span><br><span class="line">    geo.add(<span class="number">116.334255</span>, <span class="number">40.027400</span>, <span class="string">&quot;xiaomi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两点距离</span></span><br><span class="line">    System.out.println(geo.dist(<span class="string">&quot;meituan&quot;</span>, <span class="string">&quot;jd&quot;</span>, GeoUnit.METERS));</span><br><span class="line">    <span class="comment">// 坐标</span></span><br><span class="line">    System.out.println(geo.pos(<span class="string">&quot;xiaomi&quot;</span>));</span><br><span class="line">    <span class="comment">// hash</span></span><br><span class="line">    System.out.println(geo.hash(<span class="string">&quot;ireader&quot;</span>));</span><br><span class="line">    <span class="comment">// 附近</span></span><br><span class="line">    System.out.println(geo.radiusWithPositionAsync(<span class="string">&quot;jd&quot;</span>, <span class="number">20</span>, GeoUnit.KILOMETERS).get());</span><br><span class="line">    <span class="comment">// 附近</span></span><br><span class="line">    System.out.println(</span><br><span class="line">            geo.radiusWithPositionAsync(<span class="number">116.334255</span>, <span class="number">40.027400</span>, <span class="number">20</span>, GeoUnit.KILOMETERS).get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意： 在一个地图应用中，车的数据、餐馆的数据、人的数据可能会有百万千万条，<br>如果使用Redis 的 Geo 数据结构，它们将全部放在一个 zset 集合中。<br>在 Redis 的集群环境中，集合可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成较大的影响，<br>在集群环境中单个 key 对应的数据量不宜超过 1M，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。<br>所以，这里建议 Geo 的数据使用单独的 Redis 实例部署，不使用集群环境。<br>如果数据量过亿甚至更大，就需要对 Geo 数据进行拆分，按国家拆分、按省拆分，按市拆分，在人口特大城市甚至可以按区拆分。<br>这样就可以显著降低单个 zset 集合的大小。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天我们一起学习了7种高级结构</p>
<ul>
<li>分布式锁</li>
<li>队列</li>
<li>位图</li>
<li>布隆过滤器</li>
<li>HyperLogLog</li>
<li>限流器</li>
<li>GeoHash<br>希望以后大家能在工作中用到。</li>
</ul>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redisson</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch学习及原理浅析</title>
    <url>/2021/05/27/database/ElasticSearch%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这篇文章我们一起来学习一下最最流行的搜索引擎 - <code>ElasticSearch</code><br>我们将学习到：</p>
<ul>
<li>ES集群、节点类型、分片</li>
<li>服务发现机制</li>
<li>选举机制</li>
<li>Docker搭建集群环境</li>
<li>基础API操作</li>
<li>ES的数据结构及文件系统</li>
<li>存储文档的过程</li>
<li>索引及搜索</li>
</ul>
<span id="more"></span>

<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16448952278198.jpg"><br>重点特性有以下几条：</p>
<ul>
<li>存储、管理数据（文档）</li>
<li>快速搜索数据</li>
<li>对于多种数据格式的高效索引</li>
<li>分布式支持高扩展性</li>
<li>弹性伸缩支持高可用性</li>
<li>TA的好搭档-Kibana</li>
</ul>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="集群概述"><a href="#集群概述" class="headerlink" title="集群概述"></a>集群概述</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16448956295920.jpg"></p>
<p>单节点服务往往能干的很少，而且容错很低，特别是在大量数据的情况之下，所以为了提高服务的整体的高可用、高扩展性，一个服务往往都是一个集群。</p>
<p>而在ES的集群中，由若干个不同角色的节点组成（ES进程），一个集群有且只有一个master节点。</p>
<p>ES中的数据是由索引（Index）管理的，每一个索引相当于数据库中的表。</p>
<p>索引通过分片的方式，把数据横向分为若干分片，放在不同的节点上，进行分布式的存储。类似于数据库的分表操作。</p>
<p>分片可以设置副本，防止在宕机下的数据丢失。</p>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><ul>
<li>master # 主节点</li>
<li>data # 通用数据节点</li>
<li>data_content # 数据目录节点，数据不常变化</li>
<li>data_hot # 热点数据节点，数据的生命周期</li>
<li>data_warm # 中温数据节点</li>
<li>data_cold # 冷数据节点</li>
<li>data_frozen # 封存数据节点</li>
<li>ingest # 数据摄入节点， 只用于执行预处理管道</li>
<li>ml # 机器学习节点</li>
<li>remote_cluster_client # 远程集群节点</li>
<li>transform # 转换节点<ul>
<li>转换节点会进行一种特殊操作，通过特定聚集语句计算，然后将结果写到新的索引中。如果需要使用远成集群数据，请务必在转换节点中添加remote_cluster_client；转换节点设置方法</li>
</ul>
</li>
</ul>
<h4 id="Tips："><a href="#Tips：" class="headerlink" title="Tips："></a>Tips：</h4><ol>
<li>一个集群的简单配置，需要确保有<code>mater</code>节点和<code>data</code>节点。</li>
<li>如果生产环境，且有机器学习（machine learning）任务或转换（transform）任务（<strong>CPU密集型</strong>），建议将候选的主节点（Master-eligible node）与数据节点（<code>data node</code>）、机器学习节点（<code>machine learning node</code>）和转换节点（<code>transforming node</code>）分开是很有必要的。</li>
<li>每个节点都默认为协调节点（Coordinating node），如果<code>node.roles</code>设置为<code>[]</code>那么该节点将只执行协调节点功能。</li>
</ol>
<h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16448967886435.jpg"></p>
<blockquote>
<p>数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。</p>
</blockquote>
<ul>
<li>提升总体数据的存储量（通过分布式）</li>
<li>提升数据可用性（通过副本）</li>
<li>数据管理的复杂度会提升</li>
</ul>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449078323130.jpg"></p>
<p>假如有三个节点，那么他们应该达成共识，并全部都知道这个集群是个什么样子的。 图中是个反例。</p>
<h4 id="7-x之前之后的实现不同"><a href="#7-x之前之后的实现不同" class="headerlink" title="7.x之前之后的实现不同"></a>7.x之前之后的实现不同</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449067746885.jpg"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449077934455.jpg"><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449069256031.jpg"></p>
<ul>
<li>类gossip算法</li>
<li>与种子节点互相交换信息</li>
<li>达到最终的共识</li>
</ul>
<h3 id="选举选主"><a href="#选举选主" class="headerlink" title="选举选主"></a>选举选主</h3><h4 id="选举-Bully（7-x之前）"><a href="#选举-Bully（7-x之前）" class="headerlink" title="选举-Bully（7.x之前）"></a>选举-Bully（7.x之前）</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449089276566.jpg"></p>
<ol>
<li>节点1向节点，节点3发送选举，并且带上自己的序号1</li>
<li>节点2，3接收到消息之后，进行序号比较，发觉自己的序号更大，向节点1返回应答消息Answer (Alive) Message，告知节点1被踢出选主序列</li>
<li>节点2向节点3发送选举请求，节点3找不到更高序号的节点发送选举请求了</li>
<li>节点3向节点2返回应答消息，节点3收不到其他节点的应答消息了</li>
<li>节点3被认为是leader，向其他节点发送Coordinator Message，选举成功的请求，将自己是master节点广播到节点1，节点2</li>
</ol>
<h4 id="选举-类Raft（7-x之后）"><a href="#选举-类Raft（7-x之后）" class="headerlink" title="选举-类Raft（7.x之后）"></a>选举-类Raft（7.x之后）</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449090661855.jpg"><br>举例来说，如果node1，node2，node3进行选主</p>
<ul>
<li>如果node1当选leader，</li>
<li>但是node2发来了投票要求，那么node1无条件退出leader状态，node2选为主节点</li>
<li>但是node3也发来了投票要求，那么node2退出leader状态，node3当选主节点。<br>保证最后当选的leader为主leader</li>
</ul>
<p>相比于Raft算法，Es的选主算法有如下不同</p>
<ol>
<li>初始为 Candidate状态</li>
<li>允许多次投票，也就是每个有投票资格的节点可以投多票</li>
<li>候选人可以有投票的机会</li>
<li>可能会产生多个主节点</li>
</ol>
<h2 id="本地docker搭环境"><a href="#本地docker搭环境" class="headerlink" title="本地docker搭环境"></a>本地docker搭环境</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">cerebro:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">lmenezes/cerebro:0.9.4</span> </span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">cerebro</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">-Dhosts.0.host=http://es01:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">kibana:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/kibana/kibana:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">kibana</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ELASTICSEARCH_URL:</span> <span class="string">http://es01:9200</span></span><br><span class="line">      <span class="attr">ELASTICSEARCH_HOSTS:</span> <span class="string">http://es01:9200</span></span><br><span class="line">      <span class="attr">LOGGING_VERBOSE:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;5601:5601&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p><code>docker-compose up</code></p>
<ul>
<li>es: <a href="http://localhost:9200/">http://localhost:9200/</a></li>
<li>kinaba: <a href="http://localhost:5601/">http://localhost:5601/</a></li>
<li>cerebro: <a href="http://localhost:9000/">http://localhost:9000/</a></li>
</ul>
<h2 id="API操作"><a href="#API操作" class="headerlink" title="API操作"></a>API操作</h2><ul>
<li><p>创建索引</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT books</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot; : &#123;</span><br><span class="line">        &quot;number_of_shards&quot; : 4,</span><br><span class="line">        &quot;number_of_replicas&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">            &quot;properties&quot; : &#123;</span><br><span class="line">                &quot;name&quot; : &#123; &quot;type&quot; : &quot;text&quot; &#125;,</span><br><span class="line">                &quot;price&quot; : &#123;&quot;type&quot; : &quot;double&quot;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>新增数据</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT books/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot; : &quot; Effective Java&quot;,</span><br><span class="line">    &quot;price&quot; : 52.00,</span><br><span class="line">    &quot;message&quot; : &quot;本书介绍了在Java编程中78条极具实用价值的经验规则&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT books/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot; : &quot;Effective C&quot;,</span><br><span class="line">    &quot;price&quot; : 58.5,</span><br><span class="line">    &quot;message&quot; : &quot;An Introduction to Professional C Programming&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT books/_doc/3</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot; : &quot;Thinking in Java&quot;,</span><br><span class="line">    &quot;price&quot; : 66.5,</span><br><span class="line">    &quot;message&quot; : &quot;Thinking in Java should be read cover to cover by every Java programmer, then kept close at hand for frequent reference. &quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询数据</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET books/_search</span><br></pre></td></tr></table></figure></li>
<li><p>搜索</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /books/_search?q=name:java</span><br><span class="line"></span><br><span class="line">GET /books/_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123; &quot;message&quot;: &quot;java&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="ES的数据结构及文件系统"><a href="#ES的数据结构及文件系统" class="headerlink" title="ES的数据结构及文件系统"></a>ES的数据结构及文件系统</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449122545087.jpg"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/index/SegmentInfos.html">Segments File</a></td>
<td>segments_N</td>
<td>存储关于提交点的信息commit point</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50SegmentInfoFormat.html">Segment Info</a></td>
<td>.si</td>
<td>segment的元信息</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50CompoundFormat.html">Compound File</a></td>
<td>.cfs, .cfe</td>
<td>一些“虚拟”信息，少量的数据会存在这</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50FieldInfosFormat.html">Fields</a></td>
<td>.fnm</td>
<td>字段的信息</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50StoredFieldsFormat.html">Field Index</a></td>
<td>.fdx</td>
<td>字段索引的信息</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50StoredFieldsFormat.html">Field Data</a></td>
<td>.fdt</td>
<td>存储文档字段数据</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50PostingsFormat.html">Term Dictionary</a></td>
<td>.tim</td>
<td>术语词典</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50PostingsFormat.html">Term Index</a></td>
<td>.tip</td>
<td>术语索引</td>
</tr>
<tr>
<td><a href="https://lucene.apache.org/core/5_1_0/core/org/apache/lucene/codecs/lucene50/Lucene50LiveDocsFormat.html">Live Documents</a></td>
<td>.liv</td>
<td>文档存活的信息</td>
</tr>
</tbody></table>
<h2 id="存储文档的过程"><a href="#存储文档的过程" class="headerlink" title="存储文档的过程"></a>存储文档的过程</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449123445377.jpg"></p>
<ol>
<li>master节点接收请求</li>
<li>通过对_id的hash（或者路由）来盘点存储到哪一个分片</li>
<li>对应的分片本地存储数据</li>
<li>再同步给副本分片</li>
</ol>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449134143491.jpg"></p>
<ol>
<li>写入请求会将索引（Index）存放到内存区域，叫做 Index Buffer。此时的索引文件暂时是不能被ES搜索到的。</li>
<li>默认情况下 ES 每秒执行一次 Refresh 操作，将 Index Buffer 中的 index 写入到 Filesystem 中，这个也是一片内存区域。</li>
<li>ES 每次 refresh 都会生成一个 Segment，定期对 Segment 进行合并（Merge）操作，也就是将多个小 Segment 合并成一个 Segment</li>
<li>在合并完成后，会将新的 Segment 文件 Flush 写入磁盘。此时 ES 会创建一个 Commit Point 文件，该文件用来标识被 Flush 到磁盘上的 Segment。旧的 Segment 以及合并之前的小 Segment  会被从中移除</li>
</ol>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449134603831.jpg"></p>
<ol>
<li>在 ES 处理用户请求时追加 Translog，追加的内容就是对ES的请求操作。此时会根据配置同步或者异步的方式将操作记录追加信息保存到磁盘中</li>
</ol>
<h2 id="搜索（重点）"><a href="#搜索（重点）" class="headerlink" title="搜索（重点）"></a>搜索（重点）</h2><h3 id="常见索引结构"><a href="#常见索引结构" class="headerlink" title="常见索引结构"></a>常见索引结构</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449758531230.png"></p>
<h3 id="倒排索引结构"><a href="#倒排索引结构" class="headerlink" title="倒排索引结构"></a>倒排索引结构</h3><h4 id="比如我们现在有一个这样的表"><a href="#比如我们现在有一个这样的表" class="headerlink" title="比如我们现在有一个这样的表"></a>比如我们现在有一个这样的表</h4><table>
<thead>
<tr>
<th>id</th>
<th>Text</th>
<th>其他字段。。。</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Alan Alice</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Alan</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>Alan</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>Alan Brad</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>Alice</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>Alan</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>Alan</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>Alan Alice</td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>Brad</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>Brad</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="我们现在需要查询包含Alan的所有数据"><a href="#我们现在需要查询包含Alan的所有数据" class="headerlink" title="我们现在需要查询包含Alan的所有数据"></a>我们现在需要查询包含<code>Alan</code>的所有数据</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> text <span class="keyword">like</span> <span class="string">&#x27;%Alan%&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在Mysql中，这样的查询需要全表扫描，速度慢</p>
<h4 id="而在ES中"><a href="#而在ES中" class="headerlink" title="而在ES中"></a>而在ES中</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449760553786.png"></p>
<ul>
<li>通过分词，将这些关键词（<code>Term</code>）提前提取出来</li>
<li>这些关键词的集合就叫做<code>Term Dictionary</code></li>
<li>每一个关键词，都有一个对应文档的列表<code>Posting List</code></li>
<li>通过FST算法，构建一个Term的索引<code>Term dict index</code></li>
</ul>
<ol>
<li>Terms Dictionary 存储 Term 的索引文件叫做 Terms Index，存储的格式是 .tip</li>
<li>Terms Dictionary 的文件存储格式为 .tim，存储了Term和对应的Postings List指针。</li>
<li>Postings List 被拆成三个文件存储：</li>
<li>.doc后缀文件：记录 Postings 的 docId 信息和 Term 的词频</li>
<li>.pay后缀文件：记录 Payload 信息和偏移量信息</li>
<li>.pos后缀文件：记录位置信息</li>
</ol>
<h4 id="通过ID查找之SkipList"><a href="#通过ID查找之SkipList" class="headerlink" title="通过ID查找之SkipList"></a>通过ID查找之SkipList</h4><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449777126594.png"></p>
<ul>
<li>如果我们要查询id&#x3D;12的文档</li>
<li>正常链表通过遍历，一个一个查询，时间复杂度是 O(n)</li>
<li>跳跃表是通过跳跃分层， 时间复杂度可以达到 O(log n)<ul>
<li>第一层， 0～15</li>
<li>第二层， 8～15</li>
<li>第三层， 12</li>
</ul>
</li>
</ul>
<h3 id="搜索数据-BKDTree"><a href="#搜索数据-BKDTree" class="headerlink" title="搜索数据-BKDTree"></a>搜索数据-BKDTree</h3><p>对于索引一些多维数据，比如 坐标，使用的是BKD-Tree来索引<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449785200616.jpg"></p>
<ul>
<li>如图上的点，我们是怎么给他们做2D平面划分的。</li>
<li>我们需要一个鉴别器<code>discriminator</code></li>
<li>简单的鉴别器就是对层级取模<ul>
<li><code>discriminator = level % N</code></li>
</ul>
</li>
<li>会得到下面的树形结构<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16449787811410.jpg"></li>
<li>多维的就是 x y z 一次类推</li>
<li>构建BKD树，就可以更好的根据多维数据来查询对应的文档了</li>
</ul>
<h2 id="ES的优化"><a href="#ES的优化" class="headerlink" title="ES的优化"></a>ES的优化</h2><h2 id="ES相关问题"><a href="#ES相关问题" class="headerlink" title="ES相关问题"></a>ES相关问题</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/index.html">官方文档（7.x)</a></li>
<li><a href="https://github.com/elastic/elasticsearch">Github</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Elasticsearch">维基百科</a></li>
<li><a href="https://alibaba-cloud.medium.com/elasticsearch-distributed-consistency-principles-analysis-1-node-b512e2b839f8">Elasticsearch Distributed Consistency Principles Analysis (1) — Node</a></li>
<li><a href="https://juejin.cn/post/7038828692671299620">ES集群中各节点角色功能简介</a></li>
<li><a href="https://mincong.io/2020/08/22/discovery-in-elasticsearch/">Discovery in Elasticsearch</a></li>
<li><a href="https://yemilice.com/2021/06/16/elasticsearch-%E6%96%B0%E8%80%81%E9%80%89%E4%B8%BB%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/">ElasticSearch-新老选主算法对比</a></li>
<li><a href="https://blog.csdn.net/weixin_43902449/article/details/112449240">Elasticsearch数据结构存储流程</a></li>
<li><a href="https://elasticsearch.cn/question/5173">elasticsearch 每个shard对应的文件含义</a></li>
<li><a href="https://www.elastic.co/cn/blog/found-dive-into-elasticsearch-storage#lucene-index-files">A Dive into the Elasticsearch Storage</a></li>
<li><a href="https://mp.weixin.qq.com/s/wms9j22YcHfb8V9CBR65zQ">Elasticsearch写入原理，一看便知！</a></li>
<li><a href="https://yemilice.com/2021/05/14/elasticsearch%E6%A3%80%E7%B4%A2%E7%9A%84%E6%A0%B8%E5%BF%83-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E8%A7%A3%E8%AF%BB/">ElasticSearch检索的核心-倒排索引解读</a></li>
<li><a href="https://yemilice.com/2021/09/09/%E8%AE%BE%E8%AE%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84elasicsaerch%E7%B4%A2%E5%BC%95/">设计高可用的ElasicSearch索引</a></li>
<li><a href="https://medium.com/swlh/bkd-trees-used-in-elasticsearch-40e8afd2a1a4">BKD 树，用于 Elasticsearch</a></li>
</ul>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习及原理浅析</title>
    <url>/2021/08/13/database/MySQL%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>从今天开始，我们将学习目前最流行的一个数据库MySQL。</p>
<p>这篇文章，带大家走进Mysql的世界。</p>
<ul>
<li>MySQL的底层结构</li>
<li>MySQL的查询过程</li>
<li>索引结构</li>
<li>MySQL的三种Log</li>
<li>MySQL的存储引擎</li>
</ul>
<span id="more"></span>

<h2 id="MySQL的底层结构"><a href="#MySQL的底层结构" class="headerlink" title="MySQL的底层结构"></a>MySQL的底层结构</h2><p>MySQL我们可以主要分成三层：</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/v3Tr6K.png"></p>
<ol>
<li>客户端连接层。主要负责处理客户端的连接，用户的账号密码校验，权限等功能。</li>
<li>核心服务层。主要功能有缓存，对SQL语句的解析和优化，对底层API的调用。</li>
<li>存储引擎。 对数据对管理，存储，查询，事务，索引等等功能。</li>
</ol>
<h2 id="MySQL的查询过程"><a href="#MySQL的查询过程" class="headerlink" title="MySQL的查询过程"></a>MySQL的查询过程</h2><p>一个SQL的查询过程可以分成六步。 如图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/mkccLn.png"></p>
<ol>
<li>客户端和MySQL建立连接。</li>
<li>查询缓存，如果缓存命中，直接返回。但是不建议使用缓存，命中率低，弊大于利。</li>
<li>解析SQL，生成语法解析树。如果SQL写的有问题，这一步会报错。</li>
<li>查询优化，通过语法树，生成执行计划，计划可能不止一个，优化器会找到成本最小的一个执行计划。</li>
<li>执行计划，查询执行引擎拿到了执行计划，调用对应的存储引擎的接口，来执行查询，得到结果。</li>
<li>返回结果，缓存结果。如果结果集很大（1W条），不会等到全部结果出来再返回，会在第一条结果出来的时候，就开始返回结果。</li>
</ol>
<h2 id="MySQL的三种Log"><a href="#MySQL的三种Log" class="headerlink" title="MySQL的三种Log"></a>MySQL的三种Log</h2><p>MySQL有三种Log，各司其职。分别是binlog、redo log、undo log。</p>
<h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><p>binlog的主要作用是记录数据库的每一步变化。由MySQL核心服务层控制。</p>
<p>可以让别的服务来监听，实现数据同步。</p>
<p>或者再数据库损坏之后，恢复数据。</p>
<p>数据库的每一次变化，比如某一个表新增了一条数据，就会生成一个对应的binlog。<br>另外的服务监听到了之后，可以做出对应的操作，把数据同步一份。</p>
<p>可以做主备，可以做读写分离。</p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3><p>首先我们先要了解到一点，磁盘的IO昂贵，数据库再做数据变更的时候，都不会一有变更，就立即更新磁盘数据。</p>
<p>做法都是先在内存中进行操作，等到合适的时候（配置决定），再一次性的刷到磁盘当中。</p>
<p>但是如果数据在内存当中变更了之后，数据库崩溃了，这个时候内存中的数据就会丢失。</p>
<p>MySQL就会有一个redo log来保证上述情况的数据不丢失。</p>
<p>redo log由存储引擎控制。</p>
<p>当MySQL修改数据的做法如下：</p>
<ol>
<li>把对应数据的页，查询出来，并保存到内存中</li>
<li>修改内存中的数据，同时生成redo log（哪一页，修改了那些内容）。原子操作</li>
<li>如果这时MySQL崩溃，可以根据redo log恢复内存中的数据。</li>
<li>如果没有崩溃，会在合适的时候，把内存中的数据落到磁盘上，同时删除对应的redo log。</li>
</ol>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log和事务有关。InnoDB存储引擎特有。</p>
<p>在一个事务中，每一次操作，都会生成一个log，所有的log会组成一个数据链。</p>
<p>可以用来控制回滚，和在不同的事务级别下，所展示的数据的版本。</p>
<p>这就是MVCC，多版本并发控制。我们在事务那一章的时候，还会详细说明。</p>
<h2 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h2><p>MySQL的存储引擎的设计是MySQL的一大特点。<br>它可以让我们灵活的使用不同的存储引擎来应对不同的需求。</p>
<p>我们可以使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ENGINE, SUPPORT <span class="keyword">FROM</span> INFORMATION_SCHEMA.ENGINES;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br></pre></td></tr></table></figure>

<p>来查询存储引擎列表，和当前MySQL是否支持。</p>
<p>我们可以查看<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">官方文档</a><br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/8hRNsc.png"></p>
<p>我们在这里也做一下简单的介绍：</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>我们最常用的存储引擎当属InnoDB。</p>
<p>它支持事务，符合ACID，支持行级锁，<br>支持B树索引，新版版还支持全文索引，<br>使用MVCC多版本并发控制，支持崩溃恢复，<br>还支持外键。</p>
<p>它是我们一般情况下的首选。</p>
<p>在需要事务的场景中，我们更是无脑选择InnoDB。</p>
<h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM它的特点是不支持事务。当时它的优势是结构简单，比InnoDB稍快。</p>
<p>读效率比写更快。适合需要大量读的场景中。</p>
<p>支持B树索引和全文索引。如果小项目不想使用ES的话，可以考虑使用MyISAM做视图。</p>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>看名字就知道，它的特点是把数据存储在内存中的，<br>所以没有持久化，断电崩溃数据会丢失。</p>
<p>但是就是因为使用的内存，它的速度非常快。可以部分替代Redis的功能。</p>
<h3 id="Archive"><a href="#Archive" class="headerlink" title="Archive"></a>Archive</h3><p>如果你需要保存日志信息，存档信息等一些需要快速查询的场景。<br>你可以使用Archive。</p>
<p>它支持数据压缩，不支持事务、索引。</p>
<p>可以部分替代MongoDB的功能。</p>
<h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>CSV的结构很简单，它会生成一个<code>.cvs</code>的文件来存储数据。</p>
<p>我们可以使用Excel来打开它。一般很少使用。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了上述的存储引擎，剩下还有一些存储引擎。<br>比如说：Merge、Federated、Blackhole、NDB、Example<br>具体参考<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">官方文档</a></p>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><p>索引是为了提高查询效率的一种手段。</p>
<p>如果我们的数据一本新华字典的话，索引就是字典的目录。可以大大提高我们查询的效率。</p>
<p>但是索引是有代价的，它会提高修改数据的成本，也需要单独的空间来存放索引数据。</p>
<p>常见的索引结构有以下几种；</p>
<ul>
<li>Hash</li>
<li>B tree</li>
<li>全文索引</li>
</ul>
<p>本文，我们会重点说说B树这种结构。</p>
<h3 id="什么是B树"><a href="#什么是B树" class="headerlink" title="什么是B树"></a>什么是B树</h3><p>B树是一种多叉树，一个根节点下面一般有很多叶子节点，所以B树的高度一般不高。</p>
<p>使用B树存储的数据都是有序的。</p>
<p>如下图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/mwUrxI.png"></p>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B树的一种升级版。</p>
<p>它的特点是，只有叶子节点存储数据。非叶子节点只存储索引。</p>
<p>叶子节点（数据节点）同样也是有序的，并且相邻的两个叶子节点使用双向链表连接起来，这样范围查询的效率非常高。</p>
<p>可参考下图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/tu3yvP.png"></p>
<p>MySQL的InnoDB存储引擎使用的就是B+树作为索引结构。</p>
<p>每一个节点的大小固定，迎合一次磁盘IO，大小应该是16KB。</p>
<p>而非叶子上存储的都是索引，所以一个节点上可以存储非常多的索引数据。<br>再通过二分查找，来找到对应的数据地址。</p>
<h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>在InnoDB存储引擎中，表中的数据都是通过一个B+树来维护的，<br>同时表中所有的数据，都存放在B+树的叶子节点上。</p>
<p>而非聚簇索引，B+树的叶子节点上，存储的都是主键ID。<br>如果需要找到详情的数据信息，需要回表查询，即拿到主键ID，到主B+树（聚簇索引）上再查询。</p>
<h3 id="如何通过索引实现范围查询"><a href="#如何通过索引实现范围查询" class="headerlink" title="如何通过索引实现范围查询"></a>如何通过索引实现范围查询</h3><p>如果我们有一个这样的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询今年以来的订单</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> create_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为了加快查询效率，我们会在<code>create_time</code>字段上添加索引。<br>这样就有了一个按照时间排序好的索引B+树了。</p>
<p>我们的查询会从全表扫面，变成通过索引查询。</p>
<p>我们会先通过索引找到第一create_time为’2021-01-01 00:00:00’的订单索引，</p>
<p>再通过B+树叶子节点间的链表指针，往后扫描，找到满足条件的所有的订单索引。</p>
<p>再拿到满足条件的订单主键ID，去订单主聚簇索引中回表查询详细信息，返回结果。</p>
<h3 id="联合索引、索引下推、覆盖索引"><a href="#联合索引、索引下推、覆盖索引" class="headerlink" title="联合索引、索引下推、覆盖索引"></a>联合索引、索引下推、覆盖索引</h3><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>我们可以给一个字段添加索引，如上述的订单创建时间。</p>
<p>但是很多情况下的业务复杂，筛选条件众多，我们会为几个字段一起添加一个联合索引。</p>
<p>比如<code>订单的买家</code>、<code>订单创建时间</code>和<code>订单状态</code>可以作为一个联合索引。</p>
<p>这样在应用程序的客户端当中，买家查询自己的订单列表，并按照订单创建时间倒排，并可以通过订单状态做筛选条件。<br>这种情况下的查询效率会很高效。</p>
<h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>索引下推只会作用在联合索引上。并且会发生在范围查询上。</p>
<p>一句话说明：索引下推会尽量使用索引来判断where条件，而减少回表次数。</p>
<p>还是以订单表为列子，联合索引：客户姓名、订单时间</p>
<p>如果我们要查询：今年以来，姓王的客户的订单</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> create_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span> <span class="keyword">and</span> customer_name <span class="keyword">like</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>而我们都知道，范围查询会中断索引。</p>
<p>如果我们不使用索引下推的话：</p>
<p>我们会在<code>客户姓名、订单时间索引</code>B+树中找出满足客户姓名姓氏的所有订单ID</p>
<p>拿到所有订单ID去主键聚簇索引中回表查询数据，再判断今年以来的订单数据。</p>
<p>这种情况下，回表查询的订单ID会非常多。</p>
<p>而如果我们使用索引下推：</p>
<p>我们会在索引的B+树中，提前查询、筛选中满足姓氏和时间的订单ID。</p>
<p>再回表查询。</p>
<p>这种情况下，回表查询的订单ID是提前筛选好的，会少很多。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>还是上述情况，订单表的联合索引<code>客户姓名、订单时间</code>。有这样的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> create_time <span class="operator">&gt;</span> <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span> <span class="keyword">and</span> customer_name <span class="keyword">like</span> <span class="string">&#x27;王%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>SQL语句中的所有的查询条件和返回数据，在联合索引的B+树中都有，</p>
<p>我们只需要通过索引查询出来主键ID，就可以直接返回结果了，不需要再回表查询。</p>
<p>这就是覆盖索引。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次我们探讨了一种目前最流行的关系型数据库MySQL。</p>
<p>带大家了解了下MySQL的基本结构，它的查询过程。</p>
<p>通过三种Log来了解了一些MySQL的内部原理。</p>
<p>还有索引相关的一些内容。</p>
<p>希望大家都有所收获。</p>
<p>我们下次还会讲到MySQL的事务和MySQL调优相关的内容。</p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>ESL - Clean the house and relax</title>
    <url>/2021/07/18/english/clean-room/</url>
    <content><![CDATA[<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>使用下面的关键词，写一篇小短文。</p>
<blockquote>
<ul>
<li>energetic</li>
<li>dust&#x2F;dusting</li>
<li>lamp</li>
<li>furniture</li>
<li>wipe</li>
<li>rug&#x2F;carpet</li>
<li>filthy</li>
<li>vacuum</li>
<li>sucking</li>
<li>mop&#x2F;mopping</li>
<li>broom</li>
<li>scrub&#x2F;scrubbing</li>
<li>tub</li>
<li>closet</li>
<li>newscast</li>
<li>cable television</li>
<li>flip through&#x2F;thumb through</li>
<li>commercial</li>
<li>reality show</li>
<li>contest</li>
<li>There is nothing like …</li>
</ul>
</blockquote>
<span id="more"></span>

<p>Today is Sunday, so I am very energetic.<br>So I decide to clean up my house.<br>First, I dust the tables, lamps and anther furniture.<br>Then I wipe the kitchen table.<br>I saw the carpet is filthy.<br>I take out the vacuum to vacuum it.<br>It’s very convenient.<br>I clean floor in room by vacuum better than broom.<br>Next is the bathroom.<br>I mop the bathroom floor, and I scrub the sink.<br>So far, I finished all of this cleaning.<br>I’m very satisfy for it.</p>
<p>After lunch.<br>I go to watch my favorite reality show that the rap of china.<br>It’s a contest in 50 rappers.<br>I like rap song in it.</p>
<p>There is nothing like watch TV show after hardworking.</p>
]]></content>
      <categories>
        <category>english</category>
      </categories>
      <tags>
        <tag>english</tag>
        <tag>ESL</tag>
        <tag>write</tag>
        <tag>clean_room</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习-快速入门</title>
    <url>/2021/11/27/go/basic-grammar/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近觉得Go语言很有前途，语法灵活，容器化部署方便，资源消耗小。<br>而且还有强力的并发能力：Goroutines<br>所以决定从今天开始，学习Go语言。</p>
<p>这一次我们将学习到：</p>
<ul>
<li>Golang基本概念</li>
<li>基本数据类型</li>
<li>基本语法</li>
<li>复杂类型</li>
<li>方法与协程</li>
</ul>
<p>我们现在开始吧！</p>
<span id="more"></span>

<h2 id="Golang基本概念"><a href="#Golang基本概念" class="headerlink" title="Golang基本概念"></a>Golang基本概念</h2><p>Go， 他是一款Google开发的语言。<br>他是静态的<br>他是编译形语言<br>他拥有垃圾回收器<br>他有强大的并发机制</p>
<p>在容器越来越流行的今天，Go语言拥有着非常大的潜力。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>我们使用<code>var</code>来声明一个变量，用<code>const</code>来声明一个常量。<br>当然还有一个简便的写法，使用<code>:</code></p>
<h3 id="int类型"><a href="#int类型" class="headerlink" title="int类型"></a>int类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">		i1       = <span class="number">1</span></span><br><span class="line">		i2       = <span class="number">1000</span></span><br><span class="line">		i3 <span class="type">int8</span>  = <span class="number">127</span></span><br><span class="line">		i4 <span class="type">int16</span> = <span class="number">128</span></span><br><span class="line">		i5 <span class="type">uint</span>  = <span class="number">257</span></span><br><span class="line">		i6 <span class="type">int</span>   = <span class="number">0</span>b101</span><br><span class="line">		i7       = <span class="number">0</span>o77</span><br><span class="line">		i8       = <span class="number">0xAF</span></span><br><span class="line">	)</span><br><span class="line">	fmt.Println(i1, i2, i3, i4, i5, i6, i7, i8)</span><br></pre></td></tr></table></figure>
<p>上面的代码，展示了不同类型的int类型。大家酌情使用。</p>
<h3 id="float类型"><a href="#float类型" class="headerlink" title="float类型"></a>float类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	f1         = <span class="number">0.1</span></span><br><span class="line">	f2 <span class="type">float64</span> = <span class="number">0.0001</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(f1, f2)</span><br></pre></td></tr></table></figure>
<p>float类型有两种，对应Java中的Float和Double。</p>
<h3 id="byte类型"><a href="#byte类型" class="headerlink" title="byte类型"></a>byte类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	c1 <span class="type">byte</span></span><br><span class="line">	c2 = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">	c3 = <span class="string">&#x27;鹏&#x27;</span></span><br><span class="line">)</span><br><span class="line">fmt.Printf(<span class="string">&quot;\&quot;%v, %T; %v, %T; %v, %T \n&quot;</span>, c1, c1, c2, c2, c3, c3)</span><br><span class="line"></span><br><span class="line">c4 := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">c5 := <span class="string">&#x27;A&#x27;</span></span><br><span class="line">c6 := <span class="string">&#x27;x&#x27;</span> + c5 - c4</span><br><span class="line">fmt.Println(c6, <span class="type">string</span>(c6))</span><br></pre></td></tr></table></figure>
<p>为了节约内存，go使用了byte来做string的底层，所以中文可能会被截断。<br>Java在9之后，String的底层也从char变成了byte。</p>
<h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 <span class="type">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="literal">false</span></span><br><span class="line">b3 := b1 &amp;&amp; b2</span><br><span class="line">fmt.Println(b1, b2, b3)</span><br></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;世界&quot;</span></span><br><span class="line">fmt.Println(s1 + s2)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(s1), <span class="built_in">len</span>(s2))</span><br></pre></td></tr></table></figure>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h3><h4 id="变量声明的几种方式"><a href="#变量声明的几种方式" class="headerlink" title="变量声明的几种方式"></a>变量声明的几种方式</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="type">int</span></span><br><span class="line">v1 = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="type">int</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">3</span></span><br><span class="line">v4 := <span class="number">4</span></span><br><span class="line">fmt.Println(v1, v2, v3, v4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	v5 = <span class="number">5</span></span><br><span class="line">	v6 = <span class="number">6</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(v5, v6)</span><br><span class="line">fmt.Println(globalVariable)</span><br></pre></td></tr></table></figure>
<p>变量不会定义成特定的类型，他会进行类型推断。<br>还有比较有特色的声明方式是使用<code>:=</code></p>
<h4 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c1 = <span class="number">1</span> <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	c2 = <span class="number">2</span>    <span class="comment">//2</span></span><br><span class="line">	c3 = <span class="literal">iota</span> <span class="comment">//1 当前行数（从0开始）</span></span><br><span class="line">	c4 = <span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">	c5        <span class="comment">//3 默认值为上一行</span></span><br><span class="line">	c6        <span class="comment">//4</span></span><br><span class="line">	c7 = <span class="number">7</span>    <span class="comment">//7</span></span><br><span class="line">	c8        <span class="comment">//7 默认值为上一行</span></span><br><span class="line">	c9        <span class="comment">//7</span></span><br><span class="line">)</span><br><span class="line">fmt.Println(c1, c2, c3, c4, c5, c6, c7, c8, c9)</span><br><span class="line">fmt.Println(globalConstant)</span><br></pre></td></tr></table></figure>
<p>常量充当的是Java中final关键字的功能，还有枚举的功能。</p>
<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>我们通过<code>if else</code>， <code>for loop</code> 等来控制程序的执行流程。</p>
<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = rand.Int31n(<span class="number">100</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">if</span> s &gt; <span class="number">60</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;pass&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;fall&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">int32</span> = rand.Int31n(<span class="number">100</span>)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> s &lt; <span class="number">10</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;太差了&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> s &lt; <span class="number">60</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> s &lt; <span class="number">80</span>:</span><br><span class="line">	<span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> s &lt; <span class="number">100</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;good&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种条件的方式，更多的是使用if。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &gt;= <span class="number">10</span> &#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Print(i)</span><br><span class="line">	i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">	fmt.Print(i)</span><br><span class="line">	i++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	fmt.Print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不想Java有三种循环方式<code>while</code>、<code>do while</code>、<code>for</code>，<br>Go只有<code>for</code>这一种方式，当时功能依旧强大，有类似python的<code>range</code>关键字。<br>当然，依旧有<code>break</code>和<code>continue</code>的支持</p>
<h3 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h3><p>init()函数会在当前go文件加载前加载，<br>他的加载顺序是：<br>被依赖包的全局变量 -&gt; 被依赖包的init函数 -&gt; 当前包的全局变量 -&gt; 当前包的init函数 -&gt; 当前包的函数</p>
<p>这个方法可以在程序一开始的时候，创建一些数据连接什么的。</p>
<p>使用方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;this main init function&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常与错误"><a href="#异常与错误" class="headerlink" title="异常与错误"></a>异常与错误</h3><p>每一种程序都会有一场，在go语言种，使用panic机制来表示异常。<br>恐慌，很形象。</p>
<p>比如抛出一个异常可以这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">panic</span>(Error)</span><br></pre></td></tr></table></figure>

<p>我们可以生成一个error，来让panic抛出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lovelyError = errors.New(<span class="string">&quot;this is a lovely error&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> cuteError = fmt.Errorf(<span class="string">&quot;this is a cute error&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>有了异常和抛出异常，当然会有捕获异常，<br>在go里面是使用<code>defer</code>（延迟）和 <code>recover</code>（恢复）来做的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">errorOperation</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> e = <span class="built_in">recover</span>()</span><br><span class="line">		fmt.Println(<span class="string">&quot;recover:&quot;</span>, e)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">var</span> lovelyError = errors.New(<span class="string">&quot;this is a lovely error&quot;</span>)</span><br><span class="line">	<span class="keyword">var</span> cuteError = fmt.Errorf(<span class="string">&quot;this is a cute error&quot;</span>)</span><br><span class="line">	fmt.Println(lovelyError, <span class="string">&quot;;&quot;</span>, cuteError)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">panic</span>(cuteError)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数与接口"><a href="#函数与接口" class="headerlink" title="函数与接口"></a>函数与接口</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>go的函数声明类似Java的方法声明，但是又有所增强。</p>
<p>简单的函数声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回两个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumAndDiff</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">	sum := a + b</span><br><span class="line">	diff := a - b</span><br><span class="line">	<span class="keyword">return</span> sum, diff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">anonymousFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> f = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;I am anonymous function&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>闭包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="type">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        x++</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><blockquote>
<p>如果它看起来像鸭子、游泳像鸭子、叫声像鸭子，那么它可能就是只鸭子。</p>
</blockquote>
<p>go的接口和接口的实现，参考的是这种思想。</p>
<p>我们先声明一个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message <span class="keyword">interface</span> &#123;</span><br><span class="line">	getType() <span class="type">string</span></span><br><span class="line">	send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这个接口，定义了两个函数。</p>
<p>再来声明一个struct来实现这个接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TextMsg obj</span></span><br><span class="line"><span class="keyword">type</span> TextMsg <span class="keyword">struct</span> &#123;</span><br><span class="line">	text <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm *TextMsg)</span></span> getType() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;text&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tm *TextMsg)</span></span> send() &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;sendText -&gt; &quot;</span>, tm.text, <span class="string">&quot;; type is &quot;</span>, tm.getType())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>大家可以看到， TextMsg并没有直接声明 implement Message接口<br>但是 TextMsg 绑定了Message接口的两个函数，当然，还可以绑定自己的函数。</p>
<p>这样的话，程序就会认为，TextMsg就是Message的实现结构体。</p>
<h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>和Java中的数组一样，需要提前定义好数组的容量。<br>直接分配内存，效率高。</p>
<p>使用方式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">3</span>]<span class="type">int</span> = [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(array[<span class="number">1</span>], <span class="built_in">len</span>(array))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array1 = [...]<span class="type">int</span>&#123;<span class="number">4</span>,</span><br><span class="line">	<span class="number">5</span>,</span><br><span class="line">	<span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(array1[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> array1 &#123;</span><br><span class="line">	fmt.Println(i, <span class="string">&quot;的值是&quot;</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> points = [<span class="number">3</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line"><span class="keyword">for</span> _, point := <span class="keyword">range</span> points &#123;</span><br><span class="line">	fmt.Println(point)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>切片是Go中使用的最多的列表，类似Java中的ArrayList。</p>
<p>很多种方法可以创建一个切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// from array</span></span><br><span class="line">	array := [<span class="number">5</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> s1 = array[<span class="number">0</span> : <span class="built_in">len</span>(array)<span class="number">-1</span>]</span><br><span class="line">	fmt.Println(s1)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// from slice</span></span><br><span class="line">	<span class="keyword">var</span> s2 = s1[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">	fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// make</span></span><br><span class="line">	s3 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	fmt.Println(s3)</span><br><span class="line">	s3 = <span class="built_in">append</span>(s3, <span class="number">3</span>)</span><br><span class="line">	fmt.Println(s3)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sugar</span></span><br><span class="line">	s4 := []<span class="type">int</span>&#123;<span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(s4)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他是一种动态数组，支持自动扩容，底层当然是array。<br>可以参考Java中ArrayList的实现和扩容方式。<br>他有着长度和容量两个数值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lenAndCap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> slice = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br><span class="line">	fmt.Println(slice, <span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然还支持着拼接和copy</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">	s1 = <span class="built_in">append</span>(s1, <span class="number">4</span>)</span><br><span class="line">	fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">	s1 = <span class="built_in">append</span>(s1, []<span class="type">int</span>&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;...)</span><br><span class="line">	fmt.Println(s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copySlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s1 = []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> s2 = []<span class="type">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">	<span class="built_in">copy</span>(s1, s2)</span><br><span class="line">	fmt.Println(s1, s2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在go中没有栈和队列的数据结构，一般都是用slice来模拟的。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>go中的map类似与Java中的HashMap，基本操作如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createMap</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	m1[<span class="string">&quot;morning&quot;</span>] = <span class="string">&quot;eat breakfast&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;noon&quot;</span>] = <span class="string">&quot;have lunch&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m2 = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;evening&quot;</span>: <span class="string">&quot;get dinner&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m1, m2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(m1[<span class="string">&quot;noom&quot;</span>], m2[<span class="string">&quot;evening&quot;</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDeleteRange</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	m1[<span class="string">&quot;morning&quot;</span>] = <span class="string">&quot;eat breakfast&quot;</span></span><br><span class="line">	m1[<span class="string">&quot;noon&quot;</span>] = <span class="string">&quot;have lunch&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> v, ok = m1[<span class="string">&quot;noon&quot;</span>]</span><br><span class="line">	fmt.Println(v, ok)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(m1, <span class="string">&quot;noon&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> key, value := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">		fmt.Println(key, value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法与协程"><a href="#方法与协程" class="headerlink" title="方法与协程"></a>方法与协程</h2><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>Go语言的核心之一，最最重要的特点，就是goroutine。<br>就是Go语言原生帮我实现的协程，又成用户线程。<br>可以非常快速和方便的实现异步操作。</p>
<p>使用方法非常简单：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> function()</span><br></pre></td></tr></table></figure>
<p>这样就会表示，新开一个协程来调用<code>function()</code>函数。</p>
<p>在Java中需要这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; function()).start();</span><br></pre></td></tr></table></figure>
<p>当然还可以使用协程池来开启一个新线程。</p>
<p>但是不管那种方式，不管是在使用方便的程度，还是程序的运行效率。<br>Go 的 goroutine都更加优异。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">go</span> doWork1()</span><br><span class="line">	<span class="keyword">go</span> doWork2()</span><br><span class="line">	fmt.Println(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;WORK-2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;WORK-1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/2Ml3uc.png"></p>
<p>类似这个图，<code>END</code>,<code>WORK-1</code>,<code>WORK-2</code>的顺序是没办法保证的。</p>
<p>但是在实际的操作中，我们可能看不到<code>WORK-1</code>,<code>WORK-2</code>，<br>因为在协程执行完之前，整个程序的进程就结束了。</p>
<p>为了解决这个这个问题，我们需要<code>wait group</code>来同步结果。</p>
<h3 id="wait-group"><a href="#wait-group" class="headerlink" title="wait group"></a>wait group</h3><p>我们使用WG来保证所有协程都能够结束</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">go</span> doWork1(&amp;wg)</span><br><span class="line">	<span class="keyword">go</span> doWork2(&amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork2</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Println(<span class="string">&quot;WORK-2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork1</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Println(<span class="string">&quot;WORK-1&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>WaitGroup</code>，可以保证，在<code>END</code>之前，保证<code>WORK-1</code>,<code>WORK-2</code>执行完毕。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/OxRa4Q.png"></p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel类似一个管道，可以又缓存，可以往里面输入东西，可以从里面取出东西。<br>在Java中，有个很类似的东西，BlockingQueue。<br>两者都具备阻塞队列的功能。</p>
<p>但是他们核心不同点是，Go里面的channel使用的<a href="http://www.usingcsp.com/cspbook.pdf">CSP</a>模型。<br>channel的使用也更简洁，还支持select语法，和定向channel。</p>
<p>使用方法如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line">	<span class="keyword">go</span> doWork1(&amp;wg, &amp;c)</span><br><span class="line">	<span class="keyword">go</span> doWork2(&amp;wg, &amp;c)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork2</span><span class="params">(wg *sync.WaitGroup, c *<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	m := &lt;-*c</span><br><span class="line">	fmt.Println(<span class="string">&quot;WORK-2&quot;</span>)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork1</span><span class="params">(wg *sync.WaitGroup, c *<span class="keyword">chan</span> <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Println(<span class="string">&quot;WORK-1&quot;</span>)</span><br><span class="line">	*c &lt;- <span class="string">&quot;test message&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORK-1</span><br><span class="line">WORK-2</span><br><span class="line">test message</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>我们可以使用channel来把信息跨协程传输，<br>我们还可以保证<code>WORK-1</code>在<code>WORK-2</code>之前被打印。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/0peR0n.png"></p>
<h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>上下文，我们可以通过它，来控制协程的活动，比如中断一个协程。<br>我们来看段代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait group</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// channel</span></span><br><span class="line">	<span class="keyword">var</span> c = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// context</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> doWork1(&amp;wg, &amp;c, ctx)</span><br><span class="line">	<span class="keyword">go</span> doWork2(&amp;wg, &amp;c, ctx)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	<span class="comment">// 中断</span></span><br><span class="line">	cancel()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;END&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork2</span><span class="params">(wg *sync.WaitGroup, c *<span class="keyword">chan</span> <span class="type">string</span>, ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	m := &lt;-*c</span><br><span class="line">	fmt.Println(<span class="string">&quot;WORK-2&quot;</span>)</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork1</span><span class="params">(wg *sync.WaitGroup, c *<span class="keyword">chan</span> <span class="type">string</span>, ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Println(<span class="string">&quot;WORK-1&quot;</span>)</span><br><span class="line">	*c &lt;- <span class="string">&quot;test message&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;WORK-1&quot;</span>, i)</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(<span class="string">&quot;WORK-1 DONE&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在work1里面 我们有段逻辑，是打印 0～99，但是如果主线程通知我们中断，我们就会中断当前操作。</p>
<p>我们就会打印出这样的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORK-1</span><br><span class="line">WORK-2</span><br><span class="line">test message</span><br><span class="line">WORK-1 0</span><br><span class="line">WORK-1 1</span><br><span class="line">WORK-1 2</span><br><span class="line">WORK-1 3</span><br><span class="line">WORK-1 4</span><br><span class="line">WORK-1 DONE</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<p>我们的示意图，就会变成这样：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/rWNJKX.png"></p>
<p>我们除了<code>func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</code>之外，<br>还有</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span></span> (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key <span class="keyword">interface</span>&#123;&#125;, val <span class="keyword">interface</span>&#123;&#125;)</span></span> (Context)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大家如果感兴趣，可以自己尝试一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次，我们快速入门了Go，这是一种非常新的语言。<br>我相信它会在不久的未来会大展宏图。在市场上有自己的一席之地。</p>
<p>希望这片文章对大家有所帮助～</p>
<p>Bye！</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://go.dev/">https://go.dev/</a></li>
<li><a href="https://github.com/CPyeah/hello-go/tree/master/grammar">https://github.com/CPyeah/hello-go/tree/master/grammar</a></li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>basic-grammar</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之Netty.md</title>
    <url>/2021/12/25/java/Java%E4%B9%8BNetty/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Netty是一套支持NIO的客户端-服务器框架。<br>高性能、高并发。<br>支持异步通信。<br>他是使用Java编写的。<br>在Java领域中，他是IO界的老大，特别是网络IO。<br>很多项目都用它，比如Dubbo，RocketMQ，Cassandra等等。</p>
<p>在这片文章中，我们会学习到：</p>
<ol>
<li>常见的IO模型</li>
<li>Netty项目</li>
<li>Netty实战</li>
<li>Netty在我司生产中的应用</li>
</ol>
<p>那我们开始吧！</p>
<span id="more"></span>

<h2 id="常见的IO模型"><a href="#常见的IO模型" class="headerlink" title="常见的IO模型"></a>常见的IO模型</h2><h3 id="BIO，阻塞IO"><a href="#BIO，阻塞IO" class="headerlink" title="BIO，阻塞IO"></a>BIO，阻塞IO</h3><blockquote>
<p>排队</p>
</blockquote>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/PGtSwc.png"></p>
<p>当一个IO请求过来，客户端进入等待，服务端处理数据，并保持阻塞（其他的客户端访问不了）。</p>
<p>等到服务端处理完数据，返回给等待中的客户端。</p>
<p>很像我们排队买鸭子的过程（没错，我在南京）。一个一个来。</p>
<p>他的优点是，模型很简单，容易实现，且不容易出问题。<br>确定也很明显，在客户多了的时候，体验会很不好。</p>
<h3 id="NIO，非阻塞IO"><a href="#NIO，非阻塞IO" class="headerlink" title="NIO，非阻塞IO"></a>NIO，非阻塞IO</h3><blockquote>
<p>轮询</p>
</blockquote>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/F7rzu9.png"></p>
<p>客户端在执行了IO请求之后，会立刻返回结果，要不返回结果，要不还需等待。<br>如果还需要等待的话，客户会发起轮询，不断的请求服务端，直到返回结果。</p>
<p>比如我去买一个手抓饼，我下单了之后，需要等待，并且过一段时间，我会问一下老板，<br>我的手抓饼好了没，如果没有，再过一段时间，再问下老板，我的手抓饼好了没。<br>直到老板把手抓饼给我。</p>
<p>他的优势是它不会再阻塞了，不用排队等在那里。我可以干一些别的事情。</p>
<p>缺点也是有的，我需要不断的询问，这样也很消耗性能。<br>而且如果我需要的结果（手抓饼）已经准备好，但是我没有及时询问，<br>这种情况，客户端拿到数据的时间会晚于真实的数据时间。</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><blockquote>
<p>事件处理</p>
</blockquote>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/BqbARO.png"></p>
<p>IO多路复用，它是接受各种事件（比如连接、读取或写入、错误发生等)。<br>接受到各种事件消息后，记录下来，并返回一个描述符。</p>
<p>等到数据准备完成，再根据描述符找到是哪个客户端，并通知客户端来取数据。</p>
<p>打个比方，就像我们排队买奶茶，下单之后，拿到一个号码。<br>等到奶茶做好来之后，奶茶店会叫号，让我们去取奶茶。</p>
<p>它的优点是可以释放客户端，不需要阻塞。<br>因为仅仅是接受事件，一个线程就够了，不要很多线程来处理请求。</p>
<p>像Redis，Nginx都是使用的IO多路复用模型。</p>
<h3 id="AIO、异步IO模型"><a href="#AIO、异步IO模型" class="headerlink" title="AIO、异步IO模型"></a>AIO、异步IO模型</h3><blockquote>
<p>回调</p>
</blockquote>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/FZRyq2.png"></p>
<p>这种IO模型很像JS中的AJAX，发起一个请求之后，继续往下之后后续逻辑。<br>等到数据返回之后，走到回调方法，并发数据结果带过来。</p>
<p>这种就像点外卖，下单之后，等到外卖准备好，直接把外卖送到家。</p>
<p>优点就是，非常高效，客户端有着最佳的性能。<br>缺点就是，模型结构复杂，不是所有操作系统都能支持。</p>
<h2 id="Netty项目结构"><a href="#Netty项目结构" class="headerlink" title="Netty项目结构"></a>Netty项目结构</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/7qmm3O.png"></p>
<p>Netty是一个大而全的IO框架，它支持各种各样的协议。<br>对各种IO模型都有封装。<br>更友好的操作API。<br>更高效的性能。</p>
<p>接下来，我们自己看一下它。</p>
<h3 id="Netty-IO-模型"><a href="#Netty-IO-模型" class="headerlink" title="Netty IO 模型"></a>Netty IO 模型</h3><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/CqK8RW.png"></p>
<p>Netty使用的是反应模型的一种，有主线程组和工作线程组。<br>主线程组负责处理各种连接，并分发任务给工作线程组。<br>工作线程组就负责处理各种输入输出请求。并执行定义好的pipeline。</p>
<h3 id="三大核心"><a href="#三大核心" class="headerlink" title="三大核心"></a>三大核心</h3><h4 id="1、ChannelBuffer-缓冲区"><a href="#1、ChannelBuffer-缓冲区" class="headerlink" title="1、ChannelBuffer 缓冲区"></a>1、ChannelBuffer 缓冲区</h4><p>可以自定义的，多类型，API友好的缓冲区类型。</p>
<p>我们在使用IO的时候，都会使用到buffer，为解决速率不一致。<br>但是在操作系统层面和Java原生层面，只提供了ByteBuffer。字节缓冲区。<br>非常的单一，而且操作起来很不方便。</p>
<p>在Netty中，对缓冲区有了更好的封装。自动的装包和拆包。</p>
<p>而且ChannelBuffer支持zero-copy，这里的零拷贝，不是操作系统的零拷贝。<br>它的原理是在用户模式直接维护一个内核模式的buffer地址，直接进行操作。<br>不需要再进行内核模式切换，把buffer拷贝到用户模式里面来。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/lkHtRv.png"></p>
<h4 id="2、通用API"><a href="#2、通用API" class="headerlink" title="2、通用API"></a>2、通用API</h4><p>对BIO和NIO的通用抽象。<br>支持不同的通讯协议（TCP&#x2F;UDP）</p>
<p>如果我们使用Java原生的IO&#x2F;NIO接口编写，<br>会相当复杂繁琐。</p>
<p>更糟糕的是，如果我们需要把系统从BIO升级到NIO，<br>基本上需要重新开发一边</p>
<p>而如果我们一开始使用Netty开发，<br>IO模型、通讯协议都可以的切换得更加顺滑</p>
<h4 id="3、事件模型"><a href="#3、事件模型" class="headerlink" title="3、事件模型"></a>3、事件模型</h4><blockquote>
<p>基于拦截器链模式的事件模型</p>
</blockquote>
<p>Netty使用pipeline，实现了一个结构清晰得事件模型。</p>
<p>每当一个Channel被创建的时候，就会同时创建一个ChannelPipeline，<br>并永久的绑定到这个Channel上。</p>
<p>一个Event事件被加入到，触发一个pipeline，其中很多的Handler执行操作。</p>
<p>我们还可以实现自己的Handler来处理自己的业务逻辑。<br>而不会破坏代码。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/HgrHQm.png"></p>
<p>而对于我们开发Netty应用，我们只需要配置好Netty，<br>然后写好自己的业务逻辑Handler，并加入到Pipeline中。<br>其他的交给Netty就好了，非常的方便。</p>
<h3 id="传输服务"><a href="#传输服务" class="headerlink" title="传输服务"></a>传输服务</h3><blockquote>
<p>处理基于流的传输</p>
</blockquote>
<p>在基于TCP&#x2F;IP的基于流的协议中，数据包都是基于字节流的。<br>所以在一个数据包中，可能不是一个完整的我们需要的数据包。</p>
<p>所以在数据包的处理上，就会有很多繁琐的工作内容。<br>拆包、装包</p>
<p>所以Netty提供了一个可以扩展的类<code>ByteToMessageDecoder</code><br>里面提供很多开箱即用的编码、解码器。<br>初次之外，我们还可以编写自己的定制编码、解码器。</p>
<p>在TCP的世界中，所有的数据传输都是基于字节流的。<br>但是Netty提供了一种封装，<br>可以同时解决粘包、拆包的问题，还可以给转换成POJO对象。<br>这样解码器直接解出来的就是一个Java对象。更优雅。</p>
<h3 id="协议支持"><a href="#协议支持" class="headerlink" title="协议支持"></a>协议支持</h3><p>Netty实现了各种高级的传输协议。<br>比如：HTTP、SSL、WebSockets等等。<br>我们甚至可以编写自己的协议。</p>
<h2 id="Netty实战"><a href="#Netty实战" class="headerlink" title="Netty实战"></a>Netty实战</h2><p>接下来  我们简单写一个Netty的服务端和客户端的demo。<br>我们使用SpringBoot来快速架构项目。<br>使用Gradle构建<br>这里是使用的是Netty 4.1.77，比较稳定的版本。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="attr">group:</span> <span class="string">&#x27;io.netty&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;netty-all&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;4.1.77.Final&#x27;</span></span><br><span class="line">    compileOnly <span class="attr">group:</span> <span class="string">&#x27;org.projectlombok&#x27;</span>, <span class="attr">name:</span> <span class="string">&#x27;lombok&#x27;</span>, <span class="attr">version:</span> <span class="string">&#x27;1.18.24&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.24&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>我们写一个Netty服务，主要是以下几步：</p>
<ol>
<li>构建一个启动器</li>
<li>创建EventLoopGroup</li>
<li>构建ChildHandlers和Pipeline</li>
<li>编写自己的业务Handler并加入Pipeline</li>
<li>启动器绑定端口</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.cp.easychat.server.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ws://localhost:8080/chat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> NioEventLoopGroup boss;</span><br><span class="line">	<span class="keyword">private</span> NioEventLoopGroup workers;</span><br><span class="line">	<span class="keyword">private</span> ServerBootstrap serverBootstrap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.init();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">			log.info(<span class="string">&quot;server start success.&quot;</span>);</span><br><span class="line">			future.channel().closeFuture().sync();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			log.error(e.getMessage(), e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 配置启动器</span></span><br><span class="line">		serverBootstrap = <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">		serverBootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line">		serverBootstrap.option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>);</span><br><span class="line">		serverBootstrap.option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">		boss = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">		workers = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">		serverBootstrap.group(boss, workers)</span><br><span class="line">				.channel(NioServerSocketChannel.class)</span><br><span class="line">				.childHandler(getChildHandlers());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ChannelHandler <span class="title function_">getChildHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				<span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">				pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());<span class="comment">// http协议的编解码器</span></span><br><span class="line">				pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());<span class="comment">// 大数据流支持， 切成小块传输</span></span><br><span class="line">				pipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">64</span>*<span class="number">1024</span>));<span class="comment">// 聚合器，对应上面的切块</span></span><br><span class="line">				pipeline.addLast(<span class="keyword">new</span> <span class="title class_">WebSocketServerProtocolHandler</span>(<span class="string">&quot;/chat&quot;</span>));<span class="comment">// 握手 心跳处理</span></span><br><span class="line">				pipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyWebSocketHandler</span>());<span class="comment">// 我的业务处理Handler</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 我的业务处理逻辑</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyWebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 上线</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			log.info(<span class="string">&quot;⬆ new connection from &#123;&#125;&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 下线</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			log.info(<span class="string">&quot; ⬇️️ up connection close from &#123;&#125;&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 读取消息，并返回</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			log.info(<span class="string">&quot; 🆕 New Message: &#123;&#125;, from &#123;&#125;&quot;</span>, msg, ctx.channel().remoteAddress());</span><br><span class="line">			<span class="keyword">if</span> (! (msg <span class="keyword">instanceof</span> TextWebSocketFrame)) &#123;</span><br><span class="line">				log.error(<span class="string">&quot;message is not text, &#123;&#125;&quot;</span>, msg);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">TextWebSocketFrame</span> <span class="variable">request</span> <span class="operator">=</span> (TextWebSocketFrame) msg;</span><br><span class="line">			log.info(<span class="string">&quot;received text message : &#123;&#125;&quot;</span>, request);</span><br><span class="line"></span><br><span class="line">			ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;server send :&quot;</span> + request.text()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写完成之后，我们可以启动服务器，<br>并使用在线Websocket工具调用测试一下</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端的编写和服务端类似，<br>但是有些地方不一样。<br>需要服务端主动发起连接。</p>
<p>具体步骤如下：</p>
<ol>
<li>构建一个启动器</li>
<li>创建EventLoopGroup</li>
<li>构建ChildHandlers和Pipeline</li>
<li>在业务Handler中，需要添加发起握手操作</li>
<li>启动器发起连接</li>
</ol>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.cp.client.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelOption;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPromise;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.FullHttpResponse;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpClientCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.TextWebSocketFrame;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketClientHandshaker;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketClientHandshakerFactory;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.WebSocketVersion;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebsocketClient</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> URI uri;</span><br><span class="line">	<span class="keyword">private</span> Bootstrap bootstrap;</span><br><span class="line">	<span class="keyword">private</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">	<span class="keyword">private</span> ChannelPromise channelPromise;</span><br><span class="line">	<span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">WebsocketClient</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.uri = uri;</span><br><span class="line">		<span class="built_in">this</span>.init();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			channel = bootstrap.connect(uri.getHost(), uri.getPort()).sync().channel();</span><br><span class="line">			channelPromise.sync();</span><br><span class="line">			log.info(<span class="string">&quot;connect success and handshake complete.&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			log.error(<span class="string">&quot;connect error, &quot;</span> + e.getMessage(), e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">		bootstrap = <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">		bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>);</span><br><span class="line">		bootstrap.option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		eventLoopGroup = <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">		bootstrap.group(eventLoopGroup)</span><br><span class="line">				.channel(NioSocketChannel.class)</span><br><span class="line">				.handler(getHandlers());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ChannelHandler <span class="title function_">getHandlers</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				<span class="type">ChannelPipeline</span> <span class="variable">channelPipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">				channelPipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpClientCodec</span>());</span><br><span class="line">				channelPipeline.addLast(<span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">1048576</span>));</span><br><span class="line">				channelPipeline.addLast(<span class="keyword">new</span> <span class="title class_">MyWebSocketHandler</span>(getHandShaker(uri)));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">private</span> WebSocketClientHandshaker <span class="title function_">getHandShaker</span><span class="params">(URI uri)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> WebSocketClientHandshakerFactory</span><br><span class="line">						.newHandshaker(uri, WebSocketVersion.V13, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> WebSocketClientHandshaker handShaker;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">MyWebSocketHandler</span><span class="params">(WebSocketClientHandshaker handShaker)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.handShaker = handShaker;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			channelPromise = ctx.newPromise();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			log.info(<span class="string">&quot;handshake to : &#123;&#125;&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">			<span class="built_in">this</span>.handShaker.handshake(ctx.channel());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">			log.info(<span class="string">&quot;receive data &#123;&#125; from &#123;&#125;&quot;</span>, msg, ctx.channel().remoteAddress());</span><br><span class="line">			<span class="keyword">if</span> (handShaker.isHandshakeComplete()) &#123;</span><br><span class="line">				finishHandShaker(ctx, msg);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// handle business data</span></span><br><span class="line">			<span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> TextWebSocketFrame)) &#123;</span><br><span class="line">				log.warn(<span class="string">&quot;&#123;&#125; is not a text message.&quot;</span>, msg);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">TextWebSocketFrame</span> <span class="variable">textMsg</span> <span class="operator">=</span> (TextWebSocketFrame) msg;</span><br><span class="line">			log.info(<span class="string">&quot;client receive a message: &#123;&#125;&quot;</span>, textMsg.text());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishHandShaker</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				handShaker.finishHandshake(ctx.channel(), (FullHttpResponse) msg);</span><br><span class="line">				channelPromise.setSuccess();</span><br><span class="line">				log.info(<span class="string">&quot;handShake success.&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				log.error(e.getMessage(), e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完整代码请点击<a href="https://github.com/CPyeah/easy-chat">这里</a></p>
<h2 id="Netty在开放平台中的应用"><a href="#Netty在开放平台中的应用" class="headerlink" title="Netty在开放平台中的应用"></a>Netty在开放平台中的应用</h2><p>在我们的开放平台中，我们需要通过Websocket对客户端推送一下消息。<br>所以我们使用Netty搭建了一个Webscoket服务器。</p>
<p>具体搭建步骤跟上面差不多。</p>
<p>但是对于生产环境，权限的校验很重要。</p>
<p>所以在每一个链接建立之后，客户端会发起登录操作。<br>如果登录成功，服务端会把客户端的信息保存下来，维持会话。</p>
<p>在正常的业务逻辑中，我们首先监听业务中台的MQ消息。<br>如果消息有对应的客户端在线，我们把消息内容，<br>封装成<code>Message</code>对象，推送给客户端。</p>
<p>然后客户端接受到消息之后，会发起一个消息确认，以保证消息顺利被接收。</p>
<p>流程如下：</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/5cnd8k.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们学习了Netty的相关知识。并实操练习了一下。<br>我们知道了Netty是Java世界中最重要的NIO框架。<br>它对java.nio的封装，它的事件，反应模型都对我们开发NIO服务器非常有用。<br>它的多路复用的模型也非常重要。</p>
<p>我们还一起搭建了一个简单的Netty服务，<br>并使用Netty编写了一个简单的Netty客户端。<br>帮助大家上手入门。</p>
<p>还有我司在生产环境中是如何使用Netty搭建一个开放平台的消息推送系统的。<br>供大家参考。</p>
<p>希望这片文章能让大家有所收获！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://netty.io/">https://netty.io/</a></li>
<li><a href="http://www.kegel.com/c10k.html">http://www.kegel.com/c10k.html</a></li>
<li><a href="https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a></li>
<li><a href="https://github.com/netty/netty">https://github.com/netty/netty</a></li>
<li><a href="https://github.com/netty/netty/wiki/User-guide-for-4.x">https://github.com/netty/netty/wiki/User-guide-for-4.x</a></li>
<li><a href="https://netty.io/3.8/guide/#architecture">https://netty.io/3.8/guide/#architecture</a></li>
<li><a href="https://www.youtube.com/watch?v=I8yy2Cy7dDI">https://www.youtube.com/watch?v=I8yy2Cy7dDI</a></li>
<li><a href="https://alibaba-cloud.medium.com/essential-technologies-for-java-developers-i-o-and-netty-ec765676fd21">https://alibaba-cloud.medium.com/essential-technologies-for-java-developers-i-o-and-netty-ec765676fd21</a></li>
<li><a href="https://liakh-aliaksandr.medium.com/java-sockets-i-o-blocking-non-blocking-and-asynchronous-fb7f066e4ede">https://liakh-aliaksandr.medium.com/java-sockets-i-o-blocking-non-blocking-and-asynchronous-fb7f066e4ede</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Java操作ElasticSearch</title>
    <url>/2021/06/11/java/Java%E6%93%8D%E4%BD%9CElasticSearch/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天我们将使用Java来操作ElasticSearch。<br>我们将：</p>
<ul>
<li>使用Docker搭建ES集群环境</li>
<li>使用SpringBoot搭建Java环境</li>
<li>在Java模型中定义ES的索引</li>
<li>使用两种方式来操作ES（JPA和ElasticSearchTemplate）</li>
</ul>
<span id="more"></span>

<h2 id="搭建集群环境"><a href="#搭建集群环境" class="headerlink" title="搭建集群环境"></a>搭建集群环境</h2><p>今天我们继续使用docker来搭建环境。<br><code>docker-compose.yaml</code>奉上。<br>想必大家都很清楚docker compose的用法了，这里就不再赘述。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">es01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es01</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es01</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data01:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9200</span><span class="string">:9200</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es02</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data02:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line">  <span class="attr">es03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">docker.elastic.co/elasticsearch/elasticsearch:7.13.2</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">es03</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">node.name=es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.name=es-docker-cluster</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">discovery.seed_hosts=es01,es02</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cluster.initial_master_nodes=es01,es02,es03</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bootstrap.memory_lock=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;ES_JAVA_OPTS=-Xms128m -Xmx128m&quot;</span></span><br><span class="line">    <span class="attr">ulimits:</span></span><br><span class="line">      <span class="attr">memlock:</span></span><br><span class="line">        <span class="attr">soft:</span> <span class="number">-1</span></span><br><span class="line">        <span class="attr">hard:</span> <span class="number">-1</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/Users/chengpeng/docker_volume/elasticsearch/data03:/usr/share/elasticsearch/data</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">elastic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">data01:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data02:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line">  <span class="attr">data03:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">local</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">elastic:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br></pre></td></tr></table></figure>

<p>因为这里是集群，除了<code>volumes</code>需要注意之外，还需要注意<code>network</code>需要配置一下。<br>启动完成之后，浏览器访问:<br><a href="http://localhost:9200/">http://localhost:9200</a><br>如果展示：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/image.png"><br>表示ES集群启动成功。</p>
<h2 id="搭建Java环境"><a href="#搭建Java环境" class="headerlink" title="搭建Java环境"></a>搭建Java环境</h2><p>我们创建一个SpringBoot项目。<br>在<code>pom.xml</code>中引入elasticsearch的starter，即可。<br>不过要注意的是，因为ElasticSearch版本迭代很快，我们的版本要对应的上。<br>我们先查看一下ElasticSearch的版本： 7.13.2<br>再看一下<a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/">Spring文档</a>，找到对应的SpringData的版本。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/J73lBg.png"><br>在pom中我们添加上引用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>刷新下maven。 再继续在<code>application.properties</code>中配置:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.data.elasticsearch.cluster-name</span>=<span class="string">es-docker-cluster</span></span><br><span class="line"><span class="attr">spring.data.elasticsearch.cluster-nodes</span>=<span class="string">localhost:9200</span></span><br></pre></td></tr></table></figure>

<p>即完成环境搭建。</p>
<h2 id="在Java模型中定义ES的索引"><a href="#在Java模型中定义ES的索引" class="headerlink" title="在Java模型中定义ES的索引"></a>在Java模型中定义ES的索引</h2><p>好，接下来来到我们的重头戏，设计ES的索引。<br>在ES中，索引对应类似MySQL中的表，而Mapping，相当于MySQL中的表结构。<br>在一切开始之前，设计一个足够好的表结构尤为重要。可以直接影响到数据库的性能。</p>
<p>直接上结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Document(indexName = &quot;product&quot;)</span></span><br><span class="line"><span class="meta">@Setting(shards = 3, replicas = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Id</span></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Text, index = false)</span></span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Keyword, ignoreAbove = 128)</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Text, analyzer = &quot;ik_smart&quot;, searchAnalyzer = &quot;ik_smart&quot;)</span></span><br><span class="line">	<span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Keyword)</span></span><br><span class="line">	<span class="keyword">private</span> String brandName;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Long)</span></span><br><span class="line">	<span class="keyword">private</span> Long stock;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Double)</span></span><br><span class="line">	<span class="keyword">private</span> BigDecimal price;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Date, format = &#123;&#125;, pattern = &#123;&quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd&quot;,</span></span><br><span class="line"><span class="meta">			&quot;epoch_millis&quot;&#125;)</span></span><br><span class="line">	<span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Field(type = FieldType.Nested)</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Sku&gt; skuList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><p>我们首先定义了一个商品的Java模型<code>Product</code>，有各种Java类型（String、Long、BigDecimal、LocalDateTime、List）。<br>在类的上面添加<code>Document</code>注解，表示被Spring所管理。<br><code>org.springframework.data.elasticsearch.annotations.Document</code>中还有一些其他的属性。大家可以参考官方文档。</p>
<h3 id="定义Setting"><a href="#定义Setting" class="headerlink" title="定义Setting"></a>定义Setting</h3><p>定义好模型之后，我们再确定好索引的配置，<code>Setting</code>。<br>这里面主要配置，这个索引在ES中的分片数，和副本数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setting(shards = 3, replicas = 2)</span></span><br></pre></td></tr></table></figure>

<p>当然，除了分片数和副本数，还有其他的配置，大家参考官方文档。</p>
<h3 id="定义Mapping"><a href="#定义Mapping" class="headerlink" title="定义Mapping"></a>定义Mapping</h3><p>接下来，就到了定义最重要的Mapping。</p>
<h4 id="确定数据结构"><a href="#确定数据结构" class="headerlink" title="确定数据结构"></a>确定数据结构</h4><p>首先我们要知道，ES有着自己的数据结构，而且种类还很多。如图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/JtmYzS.png"><br>我们需要在每一个Java的数据结构中，对应上ES的数据结构。<br>比如<code>@Field(type = FieldType.Text)</code>表示它在ES中，是一个文本型的数据。<br>而文本型，是要被分词，生成倒排索引的。<br>这里提几点选择策略：</p>
<ul>
<li>文本类型分两种，需要分词，选text，不需要分词，选keyword</li>
<li>如果你未来不确定你到底有多少数据，将类型设置为long是比较合适的</li>
<li>keyword检索比较短的字符会更快，如果字符很大，那么会增加存储和检索成本，可以使用<code>ignoreAbove</code>属性</li>
</ul>
<h4 id="确定是否需要被索引"><a href="#确定是否需要被索引" class="headerlink" title="确定是否需要被索引"></a>确定是否需要被索引</h4><p>默认情况下，索引的字段都是需要被索引的，但是为了节省空间，我们可以把一些字段设置成不建索引。<br>比如ID一类的参数，不想被索引：<code>@Field(type = FieldType.Text, index = false)</code></p>
<h4 id="检索的方式"><a href="#检索的方式" class="headerlink" title="检索的方式"></a>检索的方式</h4><p>我们可以通过分词器，来定义我们的分词方式，比如<br><code>@Field(type = FieldType.Text, analyzer = &quot;ik_smart&quot;, searchAnalyzer = &quot;ik_smart&quot;)</code><br>这样，我们就可以使用中文的倒排索引啦。。。</p>
<h4 id="特殊的类型"><a href="#特殊的类型" class="headerlink" title="特殊的类型"></a>特殊的类型</h4><p>如果我们需要使用时间类型，在Java中，我们使用<code>LocalDateTime</code>,对应ES中是<code>Date</code>类型。<br>但是需要注意的是，我们需要定义格式化的方式，不然大概率时分秒要丢失。<br><code>@Field(type = FieldType.Date, format = &#123;&#125;, pattern = &#123;&quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd&quot;, &quot;epoch_millis&quot;&#125;)</code></p>
<p>嵌套类型，使用<code>Nested</code><br><code>@Field(type = FieldType.Nested)</code></p>
<h2 id="使用两种方式来操作ES"><a href="#使用两种方式来操作ES" class="headerlink" title="使用两种方式来操作ES"></a>使用两种方式来操作ES</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/MHdECp.png"></p>
<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>首先我们来看看如何来管理ES的索引</p>
<h4 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h4><p>如果使用JPA，我们只需保持默认配置，JPA就会替我们按照我们定义的Map来创建索引。<br>不需要我们操心。</p>
<p>我们可以使用<a href="http://localhost:9200/product/_mapping">http://localhost:9200/product/_mapping</a>来查看对应索引信息。</p>
<h4 id="ElasticsearchRestTemplate"><a href="#ElasticsearchRestTemplate" class="headerlink" title="ElasticsearchRestTemplate"></a>ElasticsearchRestTemplate</h4><p>template对应的Api如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">index</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到对应索引的操作引用</span></span><br><span class="line">    <span class="type">IndexOperations</span> <span class="variable">indexOperations</span> <span class="operator">=</span> elasticsearchRestTemplate.indexOps(Product.class);</span><br><span class="line">    <span class="comment">// 查看索引是否存在</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> indexOperations.exists();</span><br><span class="line">    <span class="keyword">if</span> (exists) &#123;</span><br><span class="line">        <span class="comment">// 删除索引（删除操作要慎重）</span></span><br><span class="line">        indexOperations.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建索引</span></span><br><span class="line"><span class="comment">//		indexOperations.create(); //这个没有配置mapping</span></span><br><span class="line">    indexOperations.createWithMapping();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 查看索引的Setting</span></span><br><span class="line">    <span class="type">Settings</span> <span class="variable">settings</span> <span class="operator">=</span> indexOperations.getSettings();</span><br><span class="line">    <span class="comment">// 查看索引的Mapping</span></span><br><span class="line">    Map&lt;String, Object&gt; mapping = indexOperations.getMapping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="增删改查操作"><a href="#增删改查操作" class="headerlink" title="增删改查操作"></a>增删改查操作</h3><h4 id="JPA-1"><a href="#JPA-1" class="headerlink" title="JPA"></a>JPA</h4><p>使用JPA非常方便，只需要定义好<code>Repository</code>，就可以方便快捷的操作Document了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;Product, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以这样使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CURDTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ProductRepository repository;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> repository.save(Product.get());</span><br><span class="line">		Assertions.assertNotNull(product);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMore</span><span class="params">()</span> &#123;</span><br><span class="line">		List&lt;Product&gt; products = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			products.add(Product.get());</span><br><span class="line">		&#125;</span><br><span class="line">		repository.saveAll(products);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listAll</span><span class="params">()</span> &#123;</span><br><span class="line">		Iterable&lt;Product&gt; all = repository.findAll();</span><br><span class="line">		all.forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">page</span><span class="params">()</span> &#123;</span><br><span class="line">		Page&lt;Product&gt; page = repository.findAll(Pageable.ofSize(<span class="number">4</span>).withPage(<span class="number">0</span>));</span><br><span class="line">		System.out.println(page);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getById</span><span class="params">()</span> &#123;</span><br><span class="line">		Page&lt;Product&gt; page = repository.findAll(Pageable.ofSize(<span class="number">1</span>).withPage(<span class="number">0</span>));</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> page.getContent().get(<span class="number">0</span>);</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product1</span> <span class="operator">=</span> repository.findById(product.getId()).orElse(<span class="literal">null</span>);</span><br><span class="line">		Assertions.assertNotNull(product1);</span><br><span class="line">		System.out.println(product1);</span><br><span class="line">		Assertions.assertEquals(product.getId(), product1.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">		Page&lt;Product&gt; page = repository.findAll(Pageable.ofSize(<span class="number">1</span>).withPage(<span class="number">0</span>));</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> page.getContent().get(<span class="number">0</span>);</span><br><span class="line">		<span class="type">Product</span> <span class="variable">newProduct</span> <span class="operator">=</span> Product.get();</span><br><span class="line">		newProduct.setId(product.getId());</span><br><span class="line">		<span class="type">Product</span> <span class="variable">save</span> <span class="operator">=</span> repository.save(newProduct);</span><br><span class="line">		Assertions.assertEquals(product.getId(), save.getId());</span><br><span class="line">		Assertions.assertNotEquals(product.getName(), save.getName());</span><br><span class="line">		System.out.println(product);</span><br><span class="line">		System.out.println(save);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">		Page&lt;Product&gt; page = repository.findAll(Pageable.ofSize(<span class="number">1</span>).withPage(<span class="number">0</span>));</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> page.getContent().get(<span class="number">0</span>);</span><br><span class="line">		repository.delete(product);</span><br><span class="line"></span><br><span class="line">		<span class="type">Product</span> <span class="variable">product1</span> <span class="operator">=</span> repository.findById(product.getId()).orElse(<span class="literal">null</span>);</span><br><span class="line">		Assertions.assertNull(product1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA的封装可以让我们无差别的操作任何数据库。 yyds</p>
<h4 id="ElasticsearchRestTemplate-1"><a href="#ElasticsearchRestTemplate-1" class="headerlink" title="ElasticsearchRestTemplate"></a>ElasticsearchRestTemplate</h4><p>使用ElasticsearchRestTemplate操作文档相对麻烦一些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CURDTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ElasticsearchRestTemplate elasticsearchRestTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> elasticsearchRestTemplate.save(Product.get());</span><br><span class="line">		Assertions.assertNotNull(product);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMore</span><span class="params">()</span> &#123;</span><br><span class="line">		List&lt;Product&gt; products = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			products.add(Product.get());</span><br><span class="line">		&#125;</span><br><span class="line">		elasticsearchRestTemplate.save(products);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listAll</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> elasticsearchRestTemplate.matchAllQuery();</span><br><span class="line">		SearchHits&lt;Product&gt; search = elasticsearchRestTemplate.search(query, Product.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getById</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> elasticsearchRestTemplate.get(<span class="string">&quot;ID&quot;</span>, Product.class);</span><br><span class="line">		Assertions.assertNotNull(product);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">Product</span> <span class="variable">oldProduct</span> <span class="operator">=</span> elasticsearchRestTemplate.get(<span class="string">&quot;ID&quot;</span>, Product.class);</span><br><span class="line">		Assertions.assertNotNull(oldProduct);</span><br><span class="line"></span><br><span class="line">		<span class="type">Product</span> <span class="variable">newProduct</span> <span class="operator">=</span> Product.get();</span><br><span class="line">		<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> newProduct.toDocument();</span><br><span class="line">		<span class="type">UpdateQuery</span> <span class="variable">updateQuery</span> <span class="operator">=</span> UpdateQuery.builder(<span class="string">&quot;ID&quot;</span>).withDocument(document).build();</span><br><span class="line">		<span class="type">UpdateResponse</span> <span class="variable">product</span> <span class="operator">=</span> elasticsearchRestTemplate</span><br><span class="line">				.update(updateQuery, IndexCoordinates.of(<span class="string">&quot;product&quot;</span>));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> elasticsearchRestTemplate.delete(<span class="string">&quot;ID&quot;</span>, Product.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><h4 id="JPA-2"><a href="#JPA-2" class="headerlink" title="JPA"></a>JPA</h4><p>JPA的搜索很简单，就把当成一个普通的数据库搜索就行。<br>我们只需要在repository中定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProductRepository</span> <span class="keyword">extends</span> <span class="title class_">ElasticsearchRepository</span>&lt;Product, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">	List&lt;Product&gt; <span class="title function_">findAllByNameContaining</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我没就可以在所有名称中包含莫个字段了。<br>在调用这个方法的时候，可以在控制台看到，本质上是JPA帮我我们发了一个<code>_search</code>的POST请求。<br>其他更复杂的方法，可以参考JPA的文档。</p>
<h4 id="ElasticsearchRestTemplate-2"><a href="#ElasticsearchRestTemplate-2" class="headerlink" title="ElasticsearchRestTemplate"></a>ElasticsearchRestTemplate</h4><p>使用ElasticsearchRestTemplate操作search，也很不错。<br>我们可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">searchTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询所有</span></span><br><span class="line">    <span class="type">Query</span> <span class="variable">searchQuery</span> <span class="operator">=</span> Query.findAll();</span><br><span class="line">    <span class="type">IndexCoordinates</span> <span class="variable">indexCoordinates</span> <span class="operator">=</span> IndexCoordinates.of(<span class="string">&quot;product&quot;</span>);</span><br><span class="line">    SearchHits&lt;Product&gt; result = elasticsearchRestTemplate</span><br><span class="line">            .search(searchQuery, Product.class, indexCoordinates);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按名称 搜索</span></span><br><span class="line">    <span class="type">MatchQueryBuilder</span> <span class="variable">matchQueryBuilder</span> <span class="operator">=</span> QueryBuilders.matchQuery(<span class="string">&quot;spuName&quot;</span>, <span class="string">&quot;473&quot;</span>);</span><br><span class="line">    searchQuery = <span class="keyword">new</span> <span class="title class_">NativeSearchQueryBuilder</span>()</span><br><span class="line">            .withQuery(matchQueryBuilder)</span><br><span class="line">            .build();</span><br><span class="line">    result = elasticsearchRestTemplate</span><br><span class="line">            .search(searchQuery, Product.class, indexCoordinates);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按价格搜索</span></span><br><span class="line">    <span class="type">Criteria</span> <span class="variable">criteria</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Criteria</span>(<span class="string">&quot;price&quot;</span>)</span><br><span class="line">            .greaterThan(<span class="number">500.0</span>)</span><br><span class="line">            .lessThan(<span class="number">800.0</span>);</span><br><span class="line"></span><br><span class="line">    searchQuery = <span class="keyword">new</span> <span class="title class_">CriteriaQuery</span>(criteria);</span><br><span class="line"></span><br><span class="line">    result = elasticsearchRestTemplate</span><br><span class="line">            .search(searchQuery, Product.class, indexCoordinates);</span><br><span class="line">    System.out.println(result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写有一个好处，就是在返回结果数据的同时，还会返回命中率，这个有时候也是会用到的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们已经学会了如何把ES操作引入到我们到Java项目中，<br>还知道了如何设计并建立一个索引，<br>还有使用两种方法来操作ES。<br>希望大家都能够在工作当中用上哦！！</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elasticsearch</tag>
        <tag>springboot</tag>
        <tag>jpa</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java操作Redis</title>
    <url>/2021/03/25/java/Java%E6%93%8D%E4%BD%9CRedis/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis是目前最流行的缓存数据库，完全基于内存操作，速度非常快。<br>它是我们互联网公司高性能，高并发的基石。<br>它的功能包括但不限于：提供中央缓存功能，分布式锁，还有特殊数据结构的特殊应用。<br>本篇文章都会一一说到。</p>
<p>接下来我们会：</p>
<ul>
<li>使用Docker搭建redis环境</li>
<li>搭建springboot服务</li>
<li>使用redisson来操作redis</li>
<li>熟悉redis的五大基本数据类型</li>
<li>熟悉使用redis的高级数据结构及其应用</li>
</ul>
<span id="more"></span>

<h2 id="使用Docker搭建redis环境"><a href="#使用Docker搭建redis环境" class="headerlink" title="使用Docker搭建redis环境"></a>使用Docker搭建redis环境</h2><p>使用Docker搭建环境非常方便。 在本地安装好Docker后，使用<code>docker compose</code>可以方便快捷但搭好环境。</p>
<p>只需要创建<code>docker-compose.yaml</code>文件，内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.9&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;6379:6379&#x27;</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span> <span class="string">--save</span> <span class="number">20</span> <span class="number">1</span> <span class="string">--loglevel</span> <span class="string">warning</span> <span class="string">--requirepass</span> <span class="string">eYVX7EwVmmxKPCDmwMtyKVge8oLd2t81</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/docker_volume/redis:/data</span></span><br></pre></td></tr></table></figure>

<p>注意： command里面的password和volumes映射，按照自己需要配置</p>
<p>再使用命令行，cd到yaml的目录下，运行<code>docker-compose up</code>命令。</p>
<p>非常简单。</p>
<p>等启动好了之后，可以用redis工具连接，看下效果。</p>
<h2 id="搭建springboot服务"><a href="#搭建springboot服务" class="headerlink" title="搭建springboot服务"></a>搭建springboot服务</h2><p>IDEA启动等一个Springboot的项目。我这里使用的是gradle。maven当让也可以。</p>
<p>我的引用如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-web&#x27;</span></span><br><span class="line">    implementation <span class="string">&#x27;org.redisson:redisson-spring-boot-starter:3.15.6&#x27;</span></span><br><span class="line">    implementation <span class="keyword">group</span>: <span class="string">&#x27;de.ruedigermoeller&#x27;</span>, name: <span class="string">&#x27;fst&#x27;</span>, version: <span class="string">&#x27;2.57&#x27;</span></span><br><span class="line">    compileOnly <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">    annotationProcessor <span class="string">&#x27;org.projectlombok:lombok&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;org.springframework.boot:spring-boot-starter-test&#x27;</span></span><br><span class="line">    testImplementation <span class="string">&#x27;io.projectreactor:reactor-test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我这里使用的官方推荐的redis客户端<code>Redisson</code>,相关的依赖是<code>org.redisson:redisson-spring-boot-starter:3.15.6</code>和<code>de.ruedigermoeller&#39;, name: &#39;fst&#39;, version: &#39;2.57</code>。这样我们就可以在我们的代码中使用<code>RedissonClient</code>了。</p>
<blockquote>
<p>干净又卫生</p>
</blockquote>
<h2 id="使用redisson来操作redis"><a href="#使用redisson来操作redis" class="headerlink" title="使用redisson来操作redis"></a>使用redisson来操作redis</h2><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p>因为redis是键值对，大家可以把redis当成一个大的<code>HashMap</code>，所以知道它的所有的key很有必要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">keysTest</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">RKeys</span> <span class="variable">keys</span> <span class="operator">=</span> redissonClient.getKeys();</span><br><span class="line">	System.out.println(keys.count());<span class="comment">// org.redisson.client.protocol.RedisCommands.DBSIZE 命令</span></span><br><span class="line">	Iterable&lt;String&gt; keysByPattern = keys</span><br><span class="line">			.getKeysByPattern(<span class="string">&quot;*&quot;</span>); <span class="comment">// org.redisson.client.protocol.RedisCommands.SCAN</span></span><br><span class="line">	keys.getKeysStream()</span><br><span class="line">			.forEach(System.out::println);<span class="comment">// org.redisson.client.protocol.RedisCommands.SCAN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redisson中使用<code>RKeys</code>类来对redis中的keys做封装。</p>
<p>我们可以</p>
<ul>
<li>拿到所有key的数量</li>
<li>把所有的key列出来</li>
<li>按照正则匹配key</li>
</ul>
<p>注意，在redisson中，使用的不是redis提供的<code>keys</code>命令，而是<code>scan</code>命令。原因是因为，redis是单线程服务，如果key的量特别大，一次keys操作会消耗很长时间，整体拖慢服务性能。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p><code>String</code>是redis的最基础的数据结构。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">	RBucket&lt;String&gt; hello = redissonClient.getBucket(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">	System.out.println(hello.get());<span class="comment">// org.redisson.client.protocol.RedisCommands.GET</span></span><br><span class="line">	hello.set(<span class="string">&quot;world ! &quot;</span>, <span class="number">5</span>,</span><br><span class="line">			TimeUnit.MINUTES);<span class="comment">// org.redisson.client.protocol.RedisCommands.PSETEX</span></span><br><span class="line">	System.out.println(hello.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis中所有的key都是String类型，而一些对象的存储，都是把对象序列化成为字符串进行存储。</p>
<p>string作为redis中的最基础的数据类型，redis做了极致的优化，这个我们后面再说。</p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是redis中列表的数据结构。说实话，在工作中使用的比较少。可以用来做一个简单的消息队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// List</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span> &#123;</span><br><span class="line">	RedissonList&lt;Person&gt; list = (RedissonList) redissonClient.getList(<span class="string">&quot;list&quot;</span>);</span><br><span class="line">	<span class="type">Person</span> <span class="variable">tom</span> <span class="operator">=</span> Person.tom();</span><br><span class="line">	list.add(tom);<span class="comment">// RPUSH</span></span><br><span class="line">	list.addBefore(tom, <span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">	list.readAll(); <span class="comment">// LRANGE</span></span><br><span class="line">	list.fastSet(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">	System.out.println(list.size());</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把redis中的list，在Java中，当成LinkedList操作（插入、删除快；查找慢）。 使用简单方便。</p>
<p>list的底层是一个叫快速列表的数据结构（quick list）。</p>
<p>如果所示，它是由ziplist组成，ziplist是压缩列表，是紧凑的，再用link给串起来。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/image.png"></p>
<h3 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h3><p>hash，map，dict，说的都是一个东西，在Java中，我们叫做<code>HashMap</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span> &#123;</span><br><span class="line">	RedissonMap&lt;String, Object&gt; myMap = (RedissonMap) redissonClient.getMap(<span class="string">&quot;myMap&quot;</span>);</span><br><span class="line">	myMap.put(<span class="string">&quot;Tom&quot;</span>, Person.tom());</span><br><span class="line">	RedissonMap&lt;String, Object&gt; map = (RedissonMap) redissonClient.getMap(<span class="string">&quot;myMap&quot;</span>);</span><br><span class="line">	System.out.println(map.get(<span class="string">&quot;Tom&quot;</span>)); <span class="comment">// HGET</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用和Java无二。 当我们使用Map缓存数据时候，我们可以部分的获取一些字段，不用把整个对象都拿出来。</p>
<p>注意：一整个Map能设置过期删除。Map中单独的key-value是设置不了过期删除的。</p>
<p>和Java中<code>HashMap</code>不同的是，扩容rehash的过程中，redis当中是渐进式的，可能同时出现两个map。</p>
<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>redis中的set和Java中的HashSet类型。使用方法也类似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSet</span><span class="params">()</span> &#123;</span><br><span class="line">	RSet&lt;Object&gt; set = redissonClient.getSet(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">	set.add(<span class="number">1</span>);</span><br><span class="line">	set.add(<span class="number">2</span>);</span><br><span class="line">	set = redissonClient.getSet(<span class="string">&quot;set&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (Object o : set) &#123;</span><br><span class="line">		System.out.println(o);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工作中使用的也不错，可以计算一些UV。</p>
<h3 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h3><p>sort set，排序集合，redis特色结构。</p>
<p>在set的基础上，给每个value加上了分数，在zset中的值都是按照分数排好序的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ZSet</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testZSet</span><span class="params">()</span> &#123;</span><br><span class="line">	RSortedSet&lt;Object&gt; zset = redissonClient.getSortedSet(<span class="string">&quot;zset&quot;</span>);</span><br><span class="line">	zset.add(<span class="number">1</span>);</span><br><span class="line">	zset.add(<span class="number">2</span>);</span><br><span class="line">	zset.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">	RScoredSortedSet&lt;Object&gt; szset = redissonClient.getScoredSortedSet(<span class="string">&quot;szset&quot;</span>);</span><br><span class="line">	szset.add(<span class="number">11.1</span>, <span class="number">1</span>);<span class="comment">// ZADD</span></span><br><span class="line">	szset.add(<span class="number">1.1</span>, <span class="number">2</span>);</span><br><span class="line">	szset.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>zset底层使用的跳跃表（skip list），具体后面再说。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/1653463112036-image.png"></p>
<p>主要的作用是可以做一些排行榜，像微博热搜。</p>
<hr>
<p>这篇文章我们讲到了如果搭建一个redis环境，并使用<code>redisson</code>对redis做一些基本操作。</p>
<p>在下一篇文章中，我们将讲到redis中的一些高级数据结构。</p>
<ul>
<li>位图</li>
<li>布隆过滤器</li>
<li>队列</li>
<li>分布式锁</li>
<li>限流器</li>
<li>HyperLogLog</li>
<li>Geo</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>redisson</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>十大排序算法</title>
    <url>/2021/07/06/algorithm/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天开启我们的算法系列，争取说简单➕通俗易懂。<br>我们从经典的排序算法开始。学习十大排序算法。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/zoOH3H.png"></p>
<p>排序算法可以分为两大类：基于比较的排序 and 不基于比较的排序。<br>基于比较的排序，是通过元素间的两两比较，来判断大小，继而排序。<br>不基于比较的排序，就是通过各种其他的方法，来让元素排序。</p>
<p>在表格中，上面的7种都是基于比较的排序算法。下3种是不基于比较的排序。</p>
<p>接下来我们一个一个的来仔细看。</p>
<span id="more"></span>

<h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><p>首先，我们来说说最简单的冒泡排序。</p>
<p>大家可以想象一下，在小学的时候，第一节体育课，老师给我们按照身高排成一列。</p>
<p>就是相邻的两个同学比较一下身高，让后把高的放右边，矮的站左边。</p>
<p>冒泡排序就是这样，从左往右遍历，相邻的两个元素进行比较，大的放右边，小的放左边。</p>
<p>这样一次遍历之后，最右边的元素肯定是最大的。</p>
<p>再进行n次遍历，就可以把整个队列排好序了。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015223238449-2146169197.gif"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 两次循环，相邻的两个元素比较，小的往前</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * O(n2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="comment">// 注意边界， 不用到最后一个</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">						SortUtil.swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h2><p>选择排序思路也很简单，我们把队列分成两个部分。</p>
<p>一部分是乱序的，就是我们一开始的样子。</p>
<p>一部分是有序的。</p>
<p>我们先在乱序的队列里面找到一个最小的元素，放到有序的队列里面。</p>
<p>再在乱序的队列里面找一个最小的元素，依次放到有序队列里面。</p>
<p>直到乱序的队列里面一个元素都没有了。</p>
<p>这样，有序的队列就是我们最终的结果。</p>
<p>为了节省空间，我们可以在一个数组里面，存下这两个队列。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015223238449-2146169197.gif"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序， 每次循环找出最小值，往前面换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="type">int</span> minIndex;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				minIndex = i;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (nums[j] &lt; nums[minIndex]) &#123;</span><br><span class="line">						minIndex = j;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				SortUtil.swap(nums, i, minIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h2><p>插入排序也很好理解。</p>
<p>相信大家都打过扑克牌，每次我们一开始摸牌都时候，都是一次插入排序都过程。</p>
<p>同样有两个队列，一个乱序，一个有序。</p>
<p>每次我们从乱序都队列里面拿出一张牌，再插入到有序队列里面合适到地方。</p>
<p>这就是插入排序。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015225645277-1151100000-2.gif"></p>
<p>请看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序， 找到一个元素，向前扫描，前面但往后移动，在合适但地方插入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> nums;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 1   3   2</span></span><br><span class="line">			<span class="comment">//     j   i</span></span><br><span class="line">			<span class="comment">// 1   2   3</span></span><br><span class="line">			<span class="comment">// j       i</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">indexValue</span> <span class="operator">=</span> nums[i];</span><br><span class="line">				<span class="comment">// 往左扫描</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">					<span class="comment">// 如果indexValue比较小，j往右移动</span></span><br><span class="line">					<span class="comment">// 同时把 i的值填充进去</span></span><br><span class="line">					<span class="keyword">if</span> (indexValue &lt; nums[j]) &#123;</span><br><span class="line">						nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">						nums[j] = indexValue;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 已经找到比当前小的了， 跳出此轮循环</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><p>希尔排序，顾名思义，它是一个名叫希尔的人发明的，第一个个时间复杂的图片O(n2)排序。</p>
<p>它是插入排序的一个变种，但是它的实现相对复杂。</p>
<p>为了帮助大家理解，我们先看一下<strong>插入排序</strong>的动图。</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015225645277-1151100000-2.gif"></p>
<p>大家有没有发现，每一次插入的过程，基本上都要移动好几个元素。大小相似的元素往往相隔的比较远。</p>
<p>为了优化这个过程，希尔选择了先把整个队列按照间隔分组，分别进行插入排序。</p>
<p>然后间隔原来越小，当间隔为1的时候，就是一次正常的插入排序。</p>
<p>这样在前期的准备中，大小相似的元素，相邻的都比较近了，可以提高最终排序的效率。</p>
<p>动图如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20180331170017421-364506073.gif"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序：</span></span><br><span class="line"><span class="comment"> * 1 按照间隔分组（初始间隔一般是数组长度的一半）</span></span><br><span class="line"><span class="comment"> * 2 排序每个组（插入排序法）</span></span><br><span class="line"><span class="comment"> * 3 间隔减小，重新分组（新的间隔一般为原间隔的一般，最后为1）</span></span><br><span class="line"><span class="comment"> * 4 再排序每个组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">interval</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">while</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				insertSortByInterval(nums, interval);</span><br><span class="line">				interval = interval / <span class="number">2</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSortByInterval</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> interval)</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; interval; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + interval; j &lt; nums.length; j += interval) &#123;</span><br><span class="line">					insertSortByInterval(nums, j, interval);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//  0  x  x  2  x  x  3  x  x  1  x  x</span></span><br><span class="line">		<span class="comment">//                    i        s</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insertSortByInterval</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startIndex, <span class="type">int</span> interval)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> nums[startIndex];</span><br><span class="line">			<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex - interval;</span><br><span class="line">			<span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt; value) &#123;</span><br><span class="line">				nums[i + interval] = nums[i];</span><br><span class="line">				nums[i] = value;</span><br><span class="line">				i -= interval;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h2><p>如果你是程序员的化，归并排序也很好理解。</p>
<p>它主要采用分治的思想，使用递归。 化繁为简。</p>
<p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="keyword">return</span> mergeSort(nums);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 递归方法</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="comment">// 递归出口</span></span><br><span class="line">			<span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> nums;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 分成两个数组</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line">			<span class="type">int</span>[] left = Arrays.copyOfRange(nums, <span class="number">0</span>, m);</span><br><span class="line">			<span class="type">int</span>[] right = Arrays.copyOfRange(nums, m, nums.length);</span><br><span class="line">			<span class="comment">// 对这两个数组做排序</span></span><br><span class="line">			left = mergeSort(left);</span><br><span class="line">			right = mergeSort(right);</span><br><span class="line">			<span class="comment">// 合并这两个排序好的数组</span></span><br><span class="line">			<span class="keyword">return</span> mergeSort(left, right);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 对两个排序好的数组做合并</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span>[] mergeSort(<span class="type">int</span>[] left, <span class="type">int</span>[] right) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> left.length + right.length;</span><br><span class="line">			<span class="type">int</span>[] merged = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">			<span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> <span class="number">0</span>, rightIndex = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">leftValue</span> <span class="operator">=</span> left[leftIndex];</span><br><span class="line">					<span class="type">int</span> <span class="variable">rightValue</span> <span class="operator">=</span> right[rightIndex];</span><br><span class="line">					<span class="keyword">if</span> (leftValue &lt; rightValue) &#123;</span><br><span class="line">						merged[i] = leftValue;</span><br><span class="line">						leftIndex++;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						merged[i] = rightValue;</span><br><span class="line">						rightIndex++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftIndex &gt;= left.length) &#123;</span><br><span class="line">					merged[i] = right[rightIndex];</span><br><span class="line">					rightIndex++;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					merged[i] = left[leftIndex];</span><br><span class="line">					leftIndex++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> merged;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>动图如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015230557043-37375010.gif"></p>
<h2 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h2><p>重点！ 重点～ 重点。。。<br>快速排序非常重要‼️</p>
<p>它的思想是：设立一个基准，把小于基准的移动到左边，把大于基准的移动到右边。</p>
<p>在把左边小于基准的子队列，再设立一个基准，再移动，右边同理。</p>
<p>使用递归，直至子队列的长度小于2。</p>
<p>先来个带辅助空间的快速排序的实现，很简单，大家体会下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用List，带辅助空间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">		List&lt;Integer&gt; list = quickSort(</span><br><span class="line">				Arrays.stream(nums).boxed().collect(Collectors.toList()));</span><br><span class="line">		<span class="keyword">return</span> list.stream().mapToInt(i -&gt; i).toArray();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 快速排序递归方法</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">quickSort</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">		<span class="comment">// 递归出口</span></span><br><span class="line">		<span class="keyword">if</span> (list.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> list;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 随便找一个基准，这里取的是第一个元素</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">pivot</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 辅助空间</span></span><br><span class="line">		List&lt;Integer&gt; low = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; high = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; equal = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 结果集合</span></span><br><span class="line">		List&lt;Integer&gt; sorted = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 大于基准的集合；小于基准的集合；等于基准的集合</span></span><br><span class="line">		<span class="keyword">for</span> (Integer item : list) &#123;</span><br><span class="line">			<span class="keyword">if</span> (item.equals(pivot)) &#123;</span><br><span class="line">				equal.add(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item &lt; pivot) &#123;</span><br><span class="line">				low.add(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				high.add(item);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 递归</span></span><br><span class="line">		low = quickSort(low);</span><br><span class="line">		high = quickSort(high);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 合并</span></span><br><span class="line">		sorted.addAll(low);</span><br><span class="line">		sorted.addAll(equal);</span><br><span class="line">		sorted.addAll(high);</span><br><span class="line">		<span class="keyword">return</span> sorted;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不带辅助空间的算法实现起来比较复杂，但是思想一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in-place</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">		sort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> nums;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> pivotDivision(nums, left, right);</span><br><span class="line"></span><br><span class="line">		sort(nums, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">		sort(nums, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照基准  左右划分</span></span><br><span class="line">	<span class="comment">// 3  2  6  5  4</span></span><br><span class="line">	<span class="comment">// 3  2  4  6  5</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pivotDivision</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">		<span class="comment">// 默认给最右边的值 为基准</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[right];</span><br><span class="line">		<span class="comment">// 初始化，基准Index</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> left;</span><br><span class="line">		<span class="comment">// 把子数组遍历一遍</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">			<span class="comment">// 如果比 基准小  替换到前面  基准Index++</span></span><br><span class="line">			<span class="keyword">if</span> (nums[i] &lt;= pivot) &#123;</span><br><span class="line">				SortUtil.swap(nums, i, pivotIndex);</span><br><span class="line">				pivotIndex++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 最后再把 基准放到中间来</span></span><br><span class="line">		SortUtil.swap(nums, right, pivotIndex);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> pivotIndex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后我们看下动图：<br>黄色的元素是基准<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015230936371-1413523412.gif"></p>
<h2 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h2><p>堆排序，就比较不好想了，它的思路是把数组转换成二叉树。对，没错。</p>
<p>把数组当成一个二叉树。</p>
<p>然后对二叉树进行递归比较，把较大对元素放到根节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1. 把数组抽象成二叉树</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * 2. 每个子树做堆化操作，比较根元素和子元素，交换位置，保持根元素最大</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * 3. 循环，保持整棵树的根元素最大</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;</span></span><br><span class="line"><span class="comment">	 * 4. 把根元素放到最后</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 7  6  5  2  3  4  1</span></span><br><span class="line">		<span class="comment">//          7</span></span><br><span class="line">		<span class="comment">//         /  \</span></span><br><span class="line">		<span class="comment">//        5    2</span></span><br><span class="line">		<span class="comment">//       / \  /</span></span><br><span class="line">		<span class="comment">//      3  4  1</span></span><br><span class="line">		<span class="comment">//  左边叶子节点的位置 = 根节点的位置 * 2 + 1</span></span><br><span class="line">		<span class="comment">//  右边叶子节点的位置 = 根节点的位置 * 2 + 2</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">				<span class="comment">// 堆化</span></span><br><span class="line">				heapify(nums, i);</span><br><span class="line">				<span class="comment">// 此时root已经最大，把root移动到后面</span></span><br><span class="line">				SortUtil.swap(nums, <span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从后往前比较每一个节点</span></span><br><span class="line">		<span class="comment">// 类似一个冒泡的过程，把最大的值给冒上来</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				checkRootValueBeMax(nums, j, i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 保证根节点 元素最大  左边节点，第二大   右边节点最小</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">checkRootValueBeMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> rootIndex, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">leftIndex</span> <span class="operator">=</span> rootIndex * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> <span class="variable">rightIndex</span> <span class="operator">=</span> rootIndex * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (leftIndex &lt; limit &amp;&amp; nums[leftIndex] &gt; nums[rootIndex]) &#123;</span><br><span class="line">				SortUtil.swap(nums, leftIndex, rootIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (rightIndex &lt; limit &amp;&amp; nums[rightIndex] &gt; nums[rootIndex]) &#123;</span><br><span class="line">				SortUtil.swap(nums, rightIndex, rootIndex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (leftIndex &lt; nums.length &amp;&amp;</span><br><span class="line">					rightIndex &lt; nums.length &amp;&amp;</span><br><span class="line">					nums[leftIndex] &gt; nums[rightIndex]) &#123;</span><br><span class="line">				SortUtil.swap(nums, leftIndex, rightIndex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>动图如下：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015231308699-356134237.gif"></p>
<h2 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h2><p>从这种排序算法开始，后面3种算法，就都是不依靠比较的排序算法了。</p>
<p>计数排序就是其中之一。</p>
<p>计数排序的核心，就是定义一个计数数组，记录每个数出现的次数。</p>
<p>如果有一个待排序的数组如：[ 5, 3, 3, 2, 6, 7, 8, 9, 0, 4 ]，最大值为10。</p>
<p>那么我们的计数数组填充完毕后的样子就是：[ 1, 0, 1, 2, 1, 1, 1, 1, 1, 1 ]</p>
<p>最后再通过计数数组，生成一个排好序的数组作为结果。</p>
<p>大家发现没有，这里面并没有想之前一样，元素之间两两比较大小。</p>
<p>在看下动图：<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015231740840-6968181.gif"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计数排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountingSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// [ 5, 3, 3, 2, 6, 7, 8, 9, 0, 4 ]   , 10</span></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums, <span class="type">int</span> maxValue) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 定义计数数组</span></span><br><span class="line">			<span class="type">int</span>[] countingArray = <span class="keyword">new</span> <span class="title class_">int</span>[maxValue];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 把 nums 存放到计数数组中</span></span><br><span class="line">			<span class="comment">// [ 1, 0, 1, 2, 1, 1, 1, 1, 1, 1 ]</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> value : nums) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> countingArray[value];</span><br><span class="line">				countingArray[value] = count + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="type">int</span> <span class="variable">numsIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 再把计数数组中的数据 反哺到nums中</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; countingArray.length; i++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> countingArray[i];</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">					nums[numsIndex] = i;</span><br><span class="line">					numsIndex++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h2><p>大家学过了计数排序，有没有发现一个问题，如果数组中元素的大小跨越的过大的化，所需要的计数数组的大小就越大。非常浪费空间。</p>
<p>为了优化这个问题，随之诞生的桶排序可以很好的解决这个问题。</p>
<p>它的数据结构类似与Java中的HashMap，图解如下：</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/uK7jwj.png"></p>
<p>它的思想也是定义一个数组，数组的每一个位置当成一个桶，</p>
<p>但是每一个位置里面可以有很多元素。</p>
<p>再对每一个桶进行排序。</p>
<p>最后，通过这个桶数组，生成一个排好序的数组作为结果。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 桶排序</span></span><br><span class="line"><span class="comment">// 1、 定义桶</span></span><br><span class="line"><span class="comment">// 2、 按桶，对数组分组</span></span><br><span class="line"><span class="comment">// 3、 对每个桶进行排序</span></span><br><span class="line"><span class="comment">// 4、 组合每个桶</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 1、 定义桶</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> nums[<span class="number">0</span>], minValue = nums[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> v : nums) &#123;</span><br><span class="line">				maxValue = Math.max(maxValue, v); <span class="comment">// 47</span></span><br><span class="line">				minValue = Math.min(minValue, v); <span class="comment">// 1</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 桶对数量（不重要，大概就行）</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(nums.length); <span class="comment">// 8</span></span><br><span class="line">			List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">List</span>[bucketCount];</span><br><span class="line">			<span class="comment">// 2、 按桶，对数组分组</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> v : nums) &#123; <span class="comment">// v =15</span></span><br><span class="line">				<span class="comment">// 找到对应对桶，这点要注意</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">bucketIndex</span> <span class="operator">=</span> v * (bucketCount - <span class="number">1</span>) / maxValue;</span><br><span class="line">				List&lt;Integer&gt; bucket = buckets[bucketIndex];</span><br><span class="line">				<span class="keyword">if</span> (bucket == <span class="literal">null</span>) &#123;</span><br><span class="line">					bucket = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">					bucket.add(v);</span><br><span class="line">					buckets[bucketIndex] = bucket;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					bucket.add(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3、 对每个桶进行排序</span></span><br><span class="line">			<span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">				Collections.sort(bucket);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 4、 组合每个桶</span></span><br><span class="line">			<span class="keyword">return</span> Arrays.stream(buckets).flatMap(Collection::stream)</span><br><span class="line">					.mapToInt(Integer::intValue).toArray();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h2><p>基数排序对于桶排序来说，也是换汤不换药。</p>
<p>同样有一个桶数组，但是这个数组的长度固定，只有10。</p>
<p>通过从低位到最高位的循环，每次循环都做一次桶排序。</p>
<p>最终就会得到一个排序好的数组。</p>
<p>这种算法占用的额外空间更小，也更可控。</p>
<p>动图如下：</p>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015232453668-1397662527.gif"></p>
<p>思想很简单。</p>
<p>请看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 取得数组中的最大数，并取得位数；</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * arr为原始数组，从最低位开始取每个位组成radix数组；</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 对radix进行计数排序（利用计数排序适用于小范围数的特点）；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] nums) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//取得数组中的最大数，并取得位数</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> getBiggestDigit(nums);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// i=1表示个位； i=2表示十位 ......</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= digit; i++) &#123;</span><br><span class="line">				<span class="comment">// 每一个位置都过一下桶数组</span></span><br><span class="line">				bucket(nums, i);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> nums;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// i=1表示个位； i=2表示十位 ......</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bucket</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">			List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">10</span>];</span><br><span class="line">			<span class="comment">// 把数组，放置到桶中</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">				<span class="comment">// 获取对应位数的数值</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> getPosition(n, i);</span><br><span class="line">				List&lt;Integer&gt; list = buckets[pos];</span><br><span class="line">				<span class="keyword">if</span> (list == <span class="literal">null</span>) &#123;</span><br><span class="line">					list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">					buckets[pos] = list;</span><br><span class="line">				&#125;</span><br><span class="line">				list.add(n);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 再把桶中到数据，恢复到原数组中</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">				<span class="keyword">if</span> (CollectionUtils.isNotEmpty(bucket)) &#123;</span><br><span class="line">					<span class="keyword">for</span> (Integer v : bucket) &#123;</span><br><span class="line">						nums[index] = v;</span><br><span class="line">						index++;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取对应位数的数值</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getPosition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> digit)</span> &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(n);</span><br><span class="line">			<span class="comment">// 33   2</span></span><br><span class="line">			<span class="keyword">if</span> (s.length() &lt; digit) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> Integer.parseInt(s.substring(s.length() - digit, s.length() - digit + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 取得数组中的最大数，并取得位数</span></span><br><span class="line">		<span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getBiggestDigit</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> String.valueOf(num).length();</span><br><span class="line">				maxDigit = Math.max(maxDigit, d);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> maxDigit;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们的十大排序算法就学习完了。</p>
<p>希望大家都有所收获。</p>
<p>其中最重要的当属 快速排序 了，两种快速排序算法，大家一定要好好掌握。</p>
<p>还有希尔排序，也比较难想，需要大家好好理解。</p>
<p>结束！！！</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemDesign:开放平台</title>
    <url>/2021/10/18/system_design/open_platform/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>客户端注册管理</li>
<li>客户端权限验证</li>
<li>客户端调用内部接口</li>
<li>消息接收</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>MVP</p>
<ul>
<li>用户注册app使用权限</li>
<li>后台管理系统</li>
<li>用户调用接口</li>
<li>消息回调</li>
<li>用户Oauth2权限验证</li>
<li>接口文档展示</li>
</ul>
<p>目标：</p>
<ul>
<li>系统高可用</li>
<li>消息不丢失</li>
<li>数据持久化</li>
</ul>
<p>加分项：</p>
<ul>
<li>Error Trace</li>
<li>统计分析</li>
<li>mock invoke in document</li>
<li>沙箱</li>
</ul>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul>
<li>用户：10万 不需要partition</li>
<li>RPS：5k &#x2F;user&#x2F;day &#x3D; 5K</li>
<li>Message 1K&#x2F;user&#x2F;day &#x3D; 1K</li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li>apply appKey&#x2F;appSecret<br>console server</li>
<li>getToken<ul>
<li>OAuth2 server</li>
</ul>
</li>
<li>invoke interface<ul>
<li>api server</li>
</ul>
</li>
<li>message server</li>
<li>doc server</li>
</ul>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/openplatformsystem.png"></p>
<h3 id="后台管理服务（console-server）"><a href="#后台管理服务（console-server）" class="headerlink" title="后台管理服务（console server）"></a>后台管理服务（console server）</h3><p>内部管理员操作</p>
<ul>
<li>用户管理</li>
<li>appId、appSecret管理</li>
<li>token管理</li>
<li>内部系统用户与client绑定管理<h3 id="权限认证服务（OAuth2-server）"><a href="#权限认证服务（OAuth2-server）" class="headerlink" title="权限认证服务（OAuth2 server）"></a>权限认证服务（OAuth2 server）</h3></li>
<li>客户端获取token</li>
<li>token校验<h3 id="接口服务（API-server）"><a href="#接口服务（API-server）" class="headerlink" title="接口服务（API server）"></a>接口服务（API server）</h3></li>
<li>类似一个网关</li>
<li>客户端参照文档，调用接口（同步）</li>
<li>校验token，验证签名</li>
<li>调用内部系统的接口</li>
<li>消息订阅</li>
<li>请求返回信息给分析服务（异步）<h3 id="分析服务（analysis-server）"><a href="#分析服务（analysis-server）" class="headerlink" title="分析服务（analysis server）"></a>分析服务（analysis server）</h3></li>
<li>接受所有的请求、消息</li>
<li>记录分析、生成仪表板</li>
<li>大数据<h3 id="消息服务（message-server）"><a href="#消息服务（message-server）" class="headerlink" title="消息服务（message server）"></a>消息服务（message server）</h3></li>
<li>监听内部系统消息</li>
<li>消息记录（状态：Queue｜Sent｜Fail）</li>
<li>客户端消息订阅查看</li>
<li>异步发送已订阅的消息（Rabbit Queue）</li>
<li>消息给分析服务（异步）</li>
</ul>
<h2 id="数据库选择"><a href="#数据库选择" class="headerlink" title="数据库选择"></a>数据库选择</h2><h3 id="后台管理服务"><a href="#后台管理服务" class="headerlink" title="后台管理服务"></a>后台管理服务</h3><p>变化少 - 关系型数据库MySQL</p>
<h3 id="认证服务"><a href="#认证服务" class="headerlink" title="认证服务"></a>认证服务</h3><p>调用频繁，过期，读多写少 - redis</p>
<h3 id="消息服务"><a href="#消息服务" class="headerlink" title="消息服务"></a>消息服务</h3><p>消息metaData保存，消息状态，事务 - MySQL<br>异步发送消息，消息队列 - Rabbit&#x2F;Kafka</p>
<h3 id="统计分析服务"><a href="#统计分析服务" class="headerlink" title="统计分析服务"></a>统计分析服务</h3><p>数据量大，实时分析 - Mongo&#x2F;KafKa&#x2F;Flink</p>
<h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><h3 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h3><p>createUser(innerId)  appId,appSecret<br>dashboard()<br>CRUD(userInfo)<br>triggerGenerateDocWebSite()</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>token &#x3D; generateToken(appId, appKey)<br>token &#x3D; refreshToken(token, appId, appKey)<br>result &#x3D; invokeInterface(data, appId, token, sign)</p>
<p>listenMessage(netty&#x2F;socket)</p>
<h3 id="内部接口"><a href="#内部接口" class="headerlink" title="内部接口"></a>内部接口</h3><h4 id="API-server"><a href="#API-server" class="headerlink" title="API server"></a>API server</h4><p>innerId &#x3D; verityTokenAndSign(appId, token, sign)<br>invokeInnerInterface(data, innerId)<br>sendRequestToAnalysis(requestInfo, metaData)</p>
<h4 id="Message-server"><a href="#Message-server" class="headerlink" title="Message server"></a>Message server</h4><p>listenInnerSystemMessage</p>
<p>filterAndSaveAndQueueMessage(message)</p>
<p>sendMessageAndChangeState(message)</p>
<p>sendMessageToAnalysis(messageInfo, metaData)</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>Client:</p>
<ul>
<li>id</li>
<li>innerId</li>
<li>appKey</li>
<li>appSecret</li>
<li>token</li>
<li>token overtime</li>
<li>client info</li>
<li>subscribe topic list</li>
</ul>
<p>Message:</p>
<ul>
<li>id</li>
<li>type</li>
<li>status(Queue｜Sent｜Fail)</li>
<li>create_time</li>
<li>finish_time</li>
</ul>
<p>Analysis Model</p>
<ul>
<li>id</li>
<li>appId (partition key)</li>
<li>clientInfo</li>
<li>type (request&#x2F;message)</li>
<li>interfaceName</li>
<li>messageTopic</li>
<li>cost</li>
<li>requestResult(success&#x2F;fail)</li>
<li>requestBody(json)</li>
<li>createTime</li>
<li>invokeTime</li>
</ul>
]]></content>
      <categories>
        <category>system_design</category>
      </categories>
      <tags>
        <tag>system_design</tag>
        <tag>open_platform</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机</title>
    <url>/2022/03/05/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这边文章我们深入了解一下Java虚拟机。<br>我会了解到：</p>
<ul>
<li>虚拟机的种类大概有哪些？</li>
<li>JVM的内存管理模型是什么样子的？</li>
<li>Java对象的创建过程是什么样子的？</li>
<li>Java对象的内存布局是什么样子的？</li>
<li>如何判断对象是垃圾？</li>
<li>Java中引用的类型有哪些？</li>
<li>垃圾收集算法有哪些？</li>
<li>HopSpot的垃圾收器是怎么实现的？</li>
<li>经典的垃圾收集器有哪些？</li>
<li>低延迟的垃圾收集器有哪些？</li>
<li>如何选择垃圾收集器？</li>
<li>JVM提供了哪些监控工具？</li>
<li>市面上有哪些可视化的工具？</li>
<li>JVM是怎么调优的？</li>
<li>Class文件结构是什么样子的？</li>
<li>常见的字节码指令有哪些？</li>
<li>Java编译的流程是什么样子的？</li>
<li>后端编译的过程是什么样子的？</li>
<li>Java内存模型是什么样子的？</li>
<li>volatile关键字有什么用？</li>
<li>Java的多线程是怎么实现的？</li>
<li>Java中有哪些锁优化？</li>
</ul>
<p>希望对你有所帮助～</p>
<span id="more"></span>

<h2 id="虚拟机的种类大概有哪些？"><a href="#虚拟机的种类大概有哪些？" class="headerlink" title="虚拟机的种类大概有哪些？"></a>虚拟机的种类大概有哪些？</h2><h3 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h3><p>首当其冲的就是使用最广泛的 <code>HotSpot</code> 虚拟机，它最重要的功能就是和它的名字一样，有<code>热点探测</code>的功能。<br>它的原理是通过方法计数器，找到多次调用的方法，和多次循环的方法，然后以方法为单位，进行二次编译成机器码，物理硬件可以直接执行。<br>还有就是它的准确式的内存管理。以前的虚拟机，都是通过句柄来操作对象的，而HotSpot可以直接识别栈上的地址是不是一个对象的引用。</p>
<h3 id="Sun-Classic"><a href="#Sun-Classic" class="headerlink" title="Sun Classic"></a>Sun Classic</h3><p>还有<code>Sun Classic</code>是Java的第一款虚拟机，能编译一起，到处运行。这是Java一开始的口号。 但是有很多缺点。<br>性能慢，不支持即时编译，需要进行外挂。</p>
<h3 id="Mobile-x2F-Embedded-VM"><a href="#Mobile-x2F-Embedded-VM" class="headerlink" title="Mobile&#x2F;Embedded VM"></a>Mobile&#x2F;Embedded VM</h3><p>还有一种就是运行在一些嵌入式设备，老年机上的Java虚拟机。它的特点就是需要的硬件资源少。</p>
<p>还有一些其他公司的虚拟机，各有各的特点。。。</p>
<h2 id="实战1：自己编译JDK"><a href="#实战1：自己编译JDK" class="headerlink" title="实战1：自己编译JDK"></a>实战1：自己编译JDK</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/Users/chengpeng/Library/Java/JavaVirtualMachines/liberica-1.8.0_322/bin/java -version</span><br><span class="line"></span><br><span class="line">brew install autoconf</span><br><span class="line">brew install freetype ccache</span><br><span class="line"></span><br><span class="line">bash configure --enable-debug --with-jvm-variants=server</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="JVM的内存管理模型是什么样子的？"><a href="#JVM的内存管理模型是什么样子的？" class="headerlink" title="JVM的内存管理模型是什么样子的？"></a>JVM的内存管理模型是什么样子的？</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16455236088988.jpg"></p>
<p>在java虚拟机中，最重要的两个分区就是堆和栈</p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆空间就是我们一般放对象的地方，在栈里面放的都是基本数据类型和对象的引用。<br>堆也是会被垃圾收集的一块内存空间。可以在物理上不连续，但是在逻辑上连续。<br>通过JVM的版本不同（G1为分界），对堆的分区也有不同。</p>
<h3 id="栈（虚拟机栈）"><a href="#栈（虚拟机栈）" class="headerlink" title="栈（虚拟机栈）"></a>栈（虚拟机栈）</h3><p>栈是属于线程的，每一个线程在开始的时候，都会同步创建一个栈空间，每一次方法调用的时候，都会创建一个栈帧，放到这个栈里面，方法调用结束的时候，栈帧就会出栈。栈帧是和方法向对应的，里面有：</p>
<ul>
<li>局部变量表，放一些方法里面的局部变量</li>
<li>操作数栈，在做运算的时候需要的一种数据结构</li>
<li>动态链接</li>
<li>方法出口</li>
<li>等等</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和操作数栈类似，只不过本地方法栈是给一个native方法服务的。</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是<code>线程隔离</code>的，每一个线程都有一个程序计数器。我们的程序本质上是一个一个的字节码指令，像<code>LOP</code>什么的，我们的程序（线程）就是一条指令一条指令的往下执行，程序计数器就是记录的<code>当前程序执行的位置</code>，就是当前命令的<code>行号</code>。<br>因为在多线程 线程切换的时候，会记录下当前执行命令的行号，再当线程回来继续执行的时候。就会按照程序计数器中的行号继续往下执行。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区和堆一样，也是所有线程共用的。在逻辑上，它是数据堆空间的一部分，但是实际上是不同的实现。里面主要放一些：</p>
<ul>
<li>类的信息</li>
<li>静态变量的信息</li>
<li>常量</li>
<li>即时编译后的一些缓存的代码</li>
</ul>
<p>以JDK8为分界，以前有个永久代，来完成现在方法区的工作，几乎不做垃圾收集（除非一些类的卸载）。因为和堆共用空间，可能会导致内存溢出。<br>所以现在通过元空间来实现方法区。使用本地内存来实现，不会占用堆空间的大小。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>它是属于方法区的一部分。主要保存一些类在编译期的常量，还有运行时动态生成的一些常量。</p>
<h3 id="其他内存"><a href="#其他内存" class="headerlink" title="其他内存"></a>其他内存</h3><p>堆外内存，不被GC，可以通过NIO直接分配堆外内存，通过堆里面的一个引用来操作堆外内存。在一些场景中可以提高效率。</p>
<h2 id="Java对象的创建过程是什么样子的？"><a href="#Java对象的创建过程是什么样子的？" class="headerlink" title="Java对象的创建过程是什么样子的？"></a>Java对象的创建过程是什么样子的？</h2><ul>
<li>通过字节码中的NEW命令来创建对象</li>
<li>看类的字面量在常量池中有没有类的引用</li>
<li>判断这个类有没有被加载，如果没有的话，执行类加载</li>
<li>通过类，来判断对象多需要内存的大小</li>
<li>在堆空间中（eden）占用内存空间，有两种方式<ul>
<li>指针碰撞（Serial、ParNew等带压缩整理，需要对齐的堆空间，把判断空闲的指针向后移动特定距离）</li>
<li>空闲列表（CMS中，维护了一个表，来判断哪些内存是空闲的）</li>
</ul>
</li>
<li>占内存的并发问题<ul>
<li>CAS（如果发现冲突，重试）</li>
<li>本地线程分配缓冲（TLAB，-XX：+&#x2F;-UseTLAB配置开启。    每一个线程提前分配一定的堆内存大小，每个线程在自己的缓存中创建对象，如果自己的内存满了，分配新缓存时，使用同步锁）</li>
</ul>
</li>
<li>对象初始化为0（在对象体中，实例数据）</li>
<li>设置对象（对象头）。比如：来自于那个类，对象的Hash，偏向锁，存活年龄等。</li>
<li>再执行构造函数，完成程序员对对象的初始化。</li>
</ul>
<h2 id="Java对象的内存布局是什么样子的？"><a href="#Java对象的内存布局是什么样子的？" class="headerlink" title="Java对象的内存布局是什么样子的？"></a>Java对象的内存布局是什么样子的？</h2><ul>
<li>对象头<ul>
<li>MarkWord：Hash，年龄，锁信息，偏向线程ID等</li>
<li>类型指针、（数组长度）</li>
</ul>
</li>
<li>实例数据<ul>
<li>对象属性字段</li>
<li>对象和方法的引用</li>
</ul>
</li>
<li>数据填充<ul>
<li>占位，8的整数倍</li>
</ul>
</li>
<li>对象访问的两种方式<ul>
<li>句柄</li>
<li>直接指针引用</li>
</ul>
</li>
</ul>
<h2 id="实战2：OutOfMemoryError异常"><a href="#实战2：OutOfMemoryError异常" class="headerlink" title="实战2：OutOfMemoryError异常"></a>实战2：OutOfMemoryError异常</h2><ul>
<li>堆内存溢出</li>
<li>栈空间溢出（深度、内存大小）</li>
<li>方法区溢出（永久代、元空间）</li>
<li>直接内存溢出</li>
</ul>
<hr>
<h2 id="如何判断对象是垃圾？"><a href="#如何判断对象是垃圾？" class="headerlink" title="如何判断对象是垃圾？"></a>如何判断对象是垃圾？</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>开辟一块空间来维护对象被引用的个数，如果为0，就表示该对象没有被引用。<br>优点：简单，判定效率高<br>缺点：没法解决循环引用的问题</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>从GC Root为根节点，往下开始遍历、引用，搜索到的对象都是被引用的对象，其他的就是没有被引用的对象，需要被清理。<br>GCRoot包括：</p>
<ul>
<li>栈空间（包括虚拟机栈、本地方法栈）</li>
<li>方法区（静态变量，常量）</li>
<li>JVM内部引用（Class对象，常驻异常，空指针，内存溢出的异常，类加载器）</li>
<li>被synchronized锁住的对象</li>
<li>等等</li>
</ul>
<p>会有两次标记的过程<br>没有被GCRoot调用链的对象，先回被标记一次，再做一次筛选，看需不需要执行finalize()方法。如果需要执行，会放到队列里面执行。<br>执行finalize()方法有时间限制，不会永久的等待。但是在finalize()方法中，可以把当前对象重新给引用上，以逃离被清除的命运。<br>队列中执行完了之后，会进行第二次标记，其中对象有可能被重新引用上了（把this赋值给了别的对象）<br>第二次还是被标记上是垃圾的对象，就真的会被执行清除。</p>
<h3 id="对方法区的回收"><a href="#对方法区的回收" class="headerlink" title="对方法区的回收"></a>对方法区的回收</h3><ul>
<li>字符串常量的回收</li>
<li>类的卸载、回收（字节码创建的类）</li>
</ul>
<h2 id="Java中引用的类型有哪些？"><a href="#Java中引用的类型有哪些？" class="headerlink" title="Java中引用的类型有哪些？"></a>Java中引用的类型有哪些？</h2><h3 id="强引用-Strongly-Reference"><a href="#强引用-Strongly-Reference" class="headerlink" title="强引用 (Strongly Reference)"></a>强引用 (Strongly Reference)</h3><p>一般口中的引用，对象被强引用，就不会被回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<h3 id="软引用-（Soft-Reference）"><a href="#软引用-（Soft-Reference）" class="headerlink" title="软引用 （Soft Reference）"></a>软引用 （Soft Reference）</h3><p>还有用，但是非必需的对象。一般GC不会清理，但是内存溢出前会清理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>

<h3 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h3><p>被弱引用关联的对象只 能生存到下一次垃圾收集发生为止.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br></pre></td></tr></table></figure>

<h3 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h3><p>不能被访问，没啥用，唯一的用处，就是对象在被回收的时候，得到一个系统通知。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>

<h2 id="垃圾收集算法有哪些？介绍一下。"><a href="#垃圾收集算法有哪些？介绍一下。" class="headerlink" title="垃圾收集算法有哪些？介绍一下。"></a>垃圾收集算法有哪些？介绍一下。</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>基础GC算法，先标记，后清除。</p>
<p>问题：</p>
<ul>
<li>对象多，垃圾对象多的时候，效率不稳定，需要一个个的清除</li>
<li>会产生内存碎片</li>
</ul>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>把内存分为大小相等的两块，每次只使用一块。每次做完标记之后，把存活的对象（新生代中存活的对象往往都是少数），全部移动到另外一块空白的内存上去，再把之前的这块内存全部清除。</p>
<p>好处：</p>
<ul>
<li>一次性的清除一块区域，效率高</li>
<li>每次复制的时候做整理，没有内存碎片</li>
<li>实现简单</li>
<li>缺点：</li>
<li>内存空间利用率低，每次只能用到一半的内存。</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>先标记，在进行整理，把存活的对象都整理到一边，再把边界之外的对象一次性全部清理掉。</p>
<p>优点：</p>
<ul>
<li>没有内存碎片</li>
<li>执行清理掉效率比较高</li>
<li>缺点：</li>
<li>移动对象的时候需要更长时间的Stop the world</li>
</ul>
<h2 id="HopSpot的垃圾收器是怎么实现的？"><a href="#HopSpot的垃圾收器是怎么实现的？" class="headerlink" title="HopSpot的垃圾收器是怎么实现的？"></a>HopSpot的垃圾收器是怎么实现的？</h2><ol>
<li>通过<code>OopMap</code>，在栈、方法区找到引用类型的GCRoot枚举</li>
<li>线程在<code>安全点</code>时，才会可能发生GC。比如一些方法调用、循环跳转、异常跳转等</li>
<li>如何在需要GC时，让所有线程都停在安全点上。<ol>
<li><code>主动式中断</code>，设置标志位，让线程轮训，自行中断</li>
<li><code>抢先式中断</code>，先全部强制中断，再把没有到安全点点线程，让它运行到安全点。</li>
</ol>
</li>
<li>对于挂起或者sleep中的线程，它可能永远不会走到安全点上，所以对于这样的线程，把它设为<code>安全区域</code>，随时可以做GC。</li>
<li>处理跨代的收集-&gt;<code>记忆集</code>和它的实现 <code>卡表</code><ol>
<li>卡表是记忆集的一种实现</li>
<li>卡表维护的其他年龄代的一块Page</li>
<li>如果有其他代的对象引用了当前代，对应卡表的元素变脏</li>
<li>在GC中，会把变脏的其他代内存对象当成GCRoot来扫描</li>
<li>在每次赋值操作是，会有个<code>写屏障</code>的过程，对赋值操作的AOP，会同时维护卡表元素</li>
</ol>
</li>
<li>可达性分析，如何标记对象。 三色标记法<ul>
<li>白色：未被扫描过，如果扫描结束了还是白色，说明这个对象就是垃圾</li>
<li>黑色：不是垃圾，被扫描过，而且它所有引用的对象也被扫描过</li>
<li>灰色：不是垃圾，但是它又被没有扫过的引用</li>
<li>等到没有灰色的时候，表示一次扫描结束。这时候，清除所有白色的垃圾</li>
<li>并发扫描的时候，对象消失的问题（本来应该被标记的对象，没有被标记上。<ul>
<li>黑色对象获取了白色对象的引用</li>
<li>灰色对象失去了所有对白色对象的引用</li>
<li>增量更新 and 原始快照</li>
<li>当扫描时，做赋值操作的时候，记录下来，在扫描结束的时候，再扫一次</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16458666178983.jpg"></p>
<h2 id="经典的垃圾收集器有哪些？"><a href="#经典的垃圾收集器有哪些？" class="headerlink" title="经典的垃圾收集器有哪些？"></a>经典的垃圾收集器有哪些？</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16467271742313.jpg"></p>
<h3 id="Serial收集器（年轻代）"><a href="#Serial收集器（年轻代）" class="headerlink" title="Serial收集器（年轻代）"></a>Serial收集器（年轻代）</h3><p>它需要把所有的用户线程全部停下来（Stop the world），然后专心的做垃圾清理。<br>缺点很明显，就是长时间的STW，影响用户体验，现在已经很少用了。<br>但是它也有优点，就是简单，单线程，使用的额外内存很少很少。有些场景可能回适用。</p>
<h3 id="ParNew收集器（年轻代）"><a href="#ParNew收集器（年轻代）" class="headerlink" title="ParNew收集器（年轻代）"></a>ParNew收集器（年轻代）</h3><p>他几乎和Serial一样，就是加入了多线程的功能，可以多个线程同时进行GC，但是这样就会增加了线程间切换的开销。<br>但是它有个优势，就是它可以和CMS搭配使用。在java9之前，这都是官方默认配置。</p>
<h3 id="Parallel-Scavenge收集器（年轻代）"><a href="#Parallel-Scavenge收集器（年轻代）" class="headerlink" title="Parallel Scavenge收集器（年轻代）"></a>Parallel Scavenge收集器（年轻代）</h3><p>他和ParNew收集器类似，但他有两个重要的特性：</p>
<ol>
<li>第一点就是它可以控制每次GC时STW的时间，和吞吐量的比率，但是如果配置的过小，它GC的就会更加频繁。</li>
<li>第二点就是，它有个自适应开关，打开了之后，我们就不用配置年轻代的大小了，它会根据监控数据，自动适应。<h3 id="Serial-Old收集器（老年代）"><a href="#Serial-Old收集器（老年代）" class="headerlink" title="Serial Old收集器（老年代）"></a>Serial Old收集器（老年代）</h3>老年代，单线程，串型收集器， 标记-整理。<br>主要是为了和Parallel Scavenge收集器搭配使用。  还有个用途，就是做CMS的后备收集器。<h3 id="Parallel-Old收集器（老年代）"><a href="#Parallel-Old收集器（老年代）" class="headerlink" title="Parallel Old收集器（老年代）"></a>Parallel Old收集器（老年代）</h3>Parallel Scavenge收集器的老年代版本， 标记-整理，注重吞吐量和单次GC时间。和Parallel Scavenge搭配使用。<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3>java9之前最经典的收集器，STW的时间非常短。它的特点就是可以GC线程和用户线程的并发。<br>它在一次GC的过程中共有四个阶段：</li>
<li>找到所有的GCRoot（STW）</li>
<li>并发标记</li>
<li>二次标记（STW）</li>
<li>并发清除<br>优点：它只需要很短的时间STW来做一些标记工作，标记-清理算法，快。<br>缺点：需要额外的内存，来存放在并发期间的新对象。内存不足会抛异常。会执行Serial Old收集。    需要间隔的执行内存整理，防止内存碎片。<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3>它是在java9之后主要的收集器，在以后也会慢慢的替换掉CMS。它的内存模型有一个比较大的改变，它是把整个的JVM内存分成一个一个的region来管理。每个region可以有不同的角色，比如edian、surivior、老年代和大对象区域。<br>然后每次回收都会选择性的清理一部分的region，根据配置，来选择清理效率最高的一些region。<br>它的GC过程主要分成四步：</li>
<li>初始标记（STW）<br>这一步主要是找GCRoot，耗时会比较短，因为会跨区域收集，所以每个region里面都会维护一个记忆集，是用来找到持有该region引用的内存区域。</li>
<li>并发标记<br>这一步是和用户线程并发执行了，耗时会比较长。<br>会维护两个区域，一个是在此过程中，新new出对象存放的区域，这次GC不会被清理。  还有一个就是在此过程中，指针有变换的对象，通过写屏障，就是对赋值操作的切面。会在下一步最终标记里面，再检查一次。</li>
<li>最终标记（STW）<br>这一步就是对在并发标记过程中，指针有变化的对象，再做一次确定操作，这一步也是需要STW的，保证不会把不是垃圾的对象收集掉。</li>
<li>筛选清除（STW）<br>这一步的时候，就能确定region里面的垃圾了，也可以计算出清理region所需要的时间，大概，然后对清理的成本和价值做个排序，根据配置的清理时间，确定要清理哪一些region。 再做复制-清除操作，因为涉及到了复制对象，所以需要用户线程是STW的。</li>
</ol>
<p>相比CMS，它需要更多内存空间来维护一些东西，比如region的管理，每个region都会有一份的卡表（跨区域指针），而CMS只需要在年轻代维护一份卡表就行了。  它的主要优势是它把整个JVM内存化整为零，不会一次性清理全部的区域，而是根据配置，可控的清理一部分region。  还有一点就是，每次清理实际上是标记-复制法，所以不会有内存碎片，而CMS是标记-清除法，会有内存碎片的问题。   目前在大内存的服务器上，G1的性能会更好。</p>
<h2 id="低延迟的垃圾收集器有哪些？"><a href="#低延迟的垃圾收集器有哪些？" class="headerlink" title="低延迟的垃圾收集器有哪些？"></a>低延迟的垃圾收集器有哪些？</h2><h3 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h3><p>它不是Oracle官方出的GC，是redhat搞的，所以不受官方的支持，只能在openJDK上使用。<br>它的内存分布和G1差不多，都是使用region把内存分成一个一个的小块，再进行收集。<br>它的收集过程</p>
<ol>
<li>GCRoot标记</li>
<li>并发标记</li>
<li>最终标记</li>
<li>并发清理（清理全部是垃圾的region）</li>
<li>并发回收（把region中存活的对象，移到新的region中）</li>
<li>初始引用更新（这里把老对象的地址，和对应新对象的地址找出来，并做成一个Map映射， 短暂的STW）</li>
<li>并发引用更新（按物理顺序扫描，按照映射修改引用地址）</li>
<li>最终引用更新（更改GCTRoot的引用，短暂STW）</li>
<li>最终并发清理（这时候老的region应该都是垃圾对象了，再并发清理掉）</li>
</ol>
<p>它的特点就是停顿时间很短，基本上大的操作都是并发执行的，但是就是因为是并发，会有很多线程竞争的场景，所以总体吞吐量不大。整体性能一般。</p>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>它是目前最先进的一款收集器，参考的是Azul公司的PGC和C4收集器。 它最大的特点，就是在对象在region间复制的过程中，不需要STW，而且复制过去了之后，立马生效，不同再等到全堆扫描更新引用。<br>它主要的技术是：</p>
<ul>
<li>染色指针（就是在指针上面打Flag，而不用存在对象头，或者单独维护）</li>
<li>读屏障（在对象内存寻址的时候，可以重定向）</li>
<li>内存多种映射（这是为了解决不同底层硬件，操作系统对染色指针的不支持）<br>它的主要GC过程：</li>
</ul>
<ol>
<li>标记（初始、并发、最终）</li>
<li>并发准备重分配（扫描所有的region，找到这次需要清理的region）</li>
<li>并发重分配（就是把region里面不是垃圾的对象做复制转移，并在当前region里面，维护一个转发表，这个时候，就可以把老的对象给删了）     如果这个时候有新的寻址过来，通过读屏障，会在转发表里面，找到对象的新地址，并更新引用。</li>
<li>并发重映射（就是扫描所有的对象，把引用全部更新成新的地址，在转发表里面找），因为这一步不需要立刻执行，所有它把这一步合并到下一次GC的标记操作中了。</li>
</ol>
<h2 id="如何选择垃圾收集器？"><a href="#如何选择垃圾收集器？" class="headerlink" title="如何选择垃圾收集器？"></a>如何选择垃圾收集器？</h2><p>场景：</p>
<ol>
<li>桌面程序，占用内存</li>
<li>服务，注重停顿时间</li>
<li>计算密集性服务，吞吐量</li>
<li>老版本的JDK</li>
<li>有充足预算，直接上Azul公司的C4</li>
</ol>
<h2 id="实战3：内存分配与回收策略"><a href="#实战3：内存分配与回收策略" class="headerlink" title="实战3：内存分配与回收策略"></a>实战3：内存分配与回收策略</h2><hr>
<h2 id="JVM提供了哪些监控工具？"><a href="#JVM提供了哪些监控工具？" class="headerlink" title="JVM提供了哪些监控工具？"></a>JVM提供了哪些监控工具？</h2><ul>
<li>jps [-lv]  查看所有jvm进程</li>
<li>jstat [-option] pid  查看jvm状态</li>
<li>jinfo [-option] pid 查看jvm配置信息</li>
<li>jmap  查看内存信息<ul>
<li><code>jmap -dump:format=b,file=eclipse.bin 3500</code></li>
</ul>
</li>
<li>jstack pid  查看堆栈信息</li>
</ul>
<h2 id="市面上有哪些可视化的工具？"><a href="#市面上有哪些可视化的工具？" class="headerlink" title="市面上有哪些可视化的工具？"></a>市面上有哪些可视化的工具？</h2><ul>
<li>JConsole</li>
<li>VisualVM</li>
<li>·Eclipse的Memory Analyzer Tool[5]（MAT）</li>
</ul>
<h2 id="JVM是怎么调优的？举例说明一下。"><a href="#JVM是怎么调优的？举例说明一下。" class="headerlink" title="JVM是怎么调优的？举例说明一下。"></a>JVM是怎么调优的？举例说明一下。</h2><h4 id="大内存大对象的优化"><a href="#大内存大对象的优化" class="headerlink" title="大内存大对象的优化"></a>大内存大对象的优化</h4><p>方案：</p>
<ol>
<li>用Shenandoah、ZGC等可控延迟的GC</li>
<li>使用Full GC 时，控制频率</li>
<li>拆分虚拟机，一个大内存的JVM变成多个小内存的JVM</li>
</ol>
<h4 id="缓存溢出"><a href="#缓存溢出" class="headerlink" title="缓存溢出"></a>缓存溢出</h4><p>因为某些原因，导致缓存一直没有被消除</p>
<h4 id="堆外内存溢出"><a href="#堆外内存溢出" class="headerlink" title="堆外内存溢出"></a>堆外内存溢出</h4><p>使用NIO操作文件，可直接只用堆外内存。 需要注意堆外内存大小。</p>
<h4 id="调用shell脚本导致内存溢出"><a href="#调用shell脚本导致内存溢出" class="headerlink" title="调用shell脚本导致内存溢出"></a>调用shell脚本导致内存溢出</h4><p>通过Java的Runtime.getRuntime().exec()，这个非常消耗资源，频繁调用，会导致内存溢出。</p>
<h4 id="socket链接长时间等待"><a href="#socket链接长时间等待" class="headerlink" title="socket链接长时间等待"></a>socket链接长时间等待</h4><p>链接服务慢，导致本机长时间等待，socket链接堆积，导致内存溢出。<br>可更换链接方式。</p>
<h4 id="数据分析，大批量数据存活"><a href="#数据分析，大批量数据存活" class="headerlink" title="数据分析，大批量数据存活"></a>数据分析，大批量数据存活</h4><p>大匹量对象在Eden中存活，在Surivor中来回复制，导致停顿时间长。</p>
<h4 id="某线程到达安全点时间长"><a href="#某线程到达安全点时间长" class="headerlink" title="某线程到达安全点时间长"></a>某线程到达安全点时间长</h4><p>某线程使用int使用循环，是不会进入安全点的。导致该线程需要长时间到达安全点，其他线程只能等待。<br>方案：找到长时间运转的线程，把int-&gt;long</p>
<h2 id="Class文件结构是什么样子的？"><a href="#Class文件结构是什么样子的？" class="headerlink" title="Class文件结构是什么样子的？"></a>Class文件结构是什么样子的？</h2><ol>
<li>Magic Number</li>
<li>版本号</li>
<li>常量池（字面量+引用符号）</li>
<li>类描述符、父类、接口列表</li>
<li>字段集合</li>
<li>方法集合</li>
<li>属性集合（类的源文件、方法体）</li>
</ol>
<h2 id="你知道的字节码指令有哪些？"><a href="#你知道的字节码指令有哪些？" class="headerlink" title="你知道的字节码指令有哪些？"></a>你知道的字节码指令有哪些？</h2><h4 id="加载、存储指令"><a href="#加载、存储指令" class="headerlink" title="加载、存储指令"></a>加载、存储指令</h4><ul>
<li>load：从局部变量表 加载 到操作数栈（入栈）</li>
<li>store：从操作数栈 存储数据到局部变量表（出栈）</li>
<li>const：加载一个常量到操作数栈（入栈）<h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4></li>
<li>加：add</li>
<li>减：sub</li>
<li>乘：mul</li>
<li>除：div</li>
<li>取余：rem</li>
<li>取反：neg</li>
<li>位移：shl、shr</li>
<li>按位与、或：and、or</li>
<li>按位异或：xor</li>
<li>局部变量自增：inc</li>
<li>比较：cmpg、cmpl<h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4></li>
<li>创建对象：new</li>
<li>创建数组：newarray</li>
<li>访问对象属性：getfield、putfield、getstatic、putstatic</li>
<li>数组操作：aload、astore<h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4></li>
<li>出栈：pop、pop2</li>
<li>复制栈顶的值：dup、dup2</li>
<li>栈顶两个元素交换位置：swap<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4></li>
<li>if</li>
<li>switch</li>
<li>goto<h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4></li>
<li><strong>invokevirtual</strong></li>
<li>invokeinterface</li>
<li>invokespecial</li>
<li><strong>invokedynamic</strong><h4 id="异常指令"><a href="#异常指令" class="headerlink" title="异常指令"></a>异常指令</h4></li>
<li>athrow<h4 id="同步指令（synchronized）"><a href="#同步指令（synchronized）" class="headerlink" title="同步指令（synchronized）"></a>同步指令（synchronized）</h4></li>
<li>monitor enter</li>
<li>monitor exit</li>
</ul>
<h2 id="Java的类加载过程是什么样子的？"><a href="#Java的类加载过程是什么样子的？" class="headerlink" title="Java的类加载过程是什么样子的？"></a>Java的类加载过程是什么样子的？</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16478477164166.jpg"></p>
<ol>
<li>加载（加载字节码）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 通过全限定类名找到改类的二进制流（字节码）</span><br><span class="line">2. 将字节码流转化成方法区的存储结构</span><br><span class="line">3. 在内存中生成一个Class对象，来作为这个类的访问入口</span><br></pre></td></tr></table></figure></li>
<li>验证（验证字节码格式）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对字节码的格式、语义做校验，要是不符合规范的，抛出VerifyException。</span><br></pre></td></tr></table></figure></li>
<li>准备（基础数据类型的准备）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为一些静态变量赋值，static修饰的变量，赋成 0 。</span><br><span class="line">但是使用final修饰的常量，直接赋成定义的值。</span><br></pre></td></tr></table></figure></li>
<li>解析（引用类型的解析，找到对应的类，并做一些校验）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将符号引用转换成直接引用。</span><br><span class="line">就是将字符串、字面量转换成其他类真正的引用。</span><br><span class="line">如果其他的类还没有加载，就先加载其他的类。</span><br></pre></td></tr></table></figure></li>
<li>初始化（走一些静态语句脚本）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JVM会汇总一个clinit方法，里面会包含所有变量的赋值操作，和静态代码块的内容。</span><br><span class="line">然后会对它们按顺序执行。</span><br><span class="line">如果它的父类有clinit方法，会先执行父类的。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="有几种类加载器？双亲委派是什么？"><a href="#有几种类加载器？双亲委派是什么？" class="headerlink" title="有几种类加载器？双亲委派是什么？"></a>有几种类加载器？双亲委派是什么？</h2><p><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16478551695468.jpg"></p>
<ul>
<li>启动类加载器（bootstrap）<ul>
<li>加载java核心代码（lib目录下），比如rt.jar tools.jar</li>
<li>C语言编写，我们没法使用</li>
</ul>
</li>
<li>扩展类加载器（extension）<ul>
<li>加载java扩展代码，ext目录下</li>
<li>Java编写，可以获取到使用</li>
</ul>
</li>
<li>应用程序类加载器（application）<ul>
<li>加载我们自己编写的代码</li>
<li>一般Class默认的类加载器</li>
</ul>
</li>
<li>自定义类加载器<ul>
<li>实现 <code>ClassLoader</code>接口</li>
</ul>
</li>
</ul>
<h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p>当我们得到一个全限定类名，并尝试加载它的时候，会先让当前Classloader的父加载器去加载，如果该类不在父加载器的加载范围，再使用当前加载器加载。<br>这样的目的是保证一些核心类的安全。一些基础的类，比如Object，只能使用bootstrap加载器加载。<br>以为在Java中，判断一个类的唯一性，是通过 类加载器+全限定类名 来判断的，如果使用两个类加载器加载Object，会导致程序错乱。</p>
<h4 id="打破双亲委派"><a href="#打破双亲委派" class="headerlink" title="打破双亲委派"></a>打破双亲委派</h4><ol>
<li>java1.2以前</li>
<li>热部署、osgi</li>
</ol>
<h4 id="在java9之后的双亲委派"><a href="#在java9之后的双亲委派" class="headerlink" title="在java9之后的双亲委派"></a>在java9之后的双亲委派</h4><p>在java9之后，引入了模块系统，每个模块是隔离的，所以在ApplicationClassLoader和PlatfromClassLoader中，在向上委派之前，会现在其他的module中找一下这个类的归属，如果属于别的module，就让别的module的classloader加载。</p>
<h2 id="Java运行时候的栈帧是什么样子的？"><a href="#Java运行时候的栈帧是什么样子的？" class="headerlink" title="Java运行时候的栈帧是什么样子的？"></a>Java运行时候的栈帧是什么样子的？</h2><ul>
<li>局部变量表（变量保存）<ul>
<li>它主要存储在当前作用域中的一些局部变量，存储单元是变量槽，0号变量槽是this，其他的变量（方法参数，定义的变量）从1开始往后。</li>
<li>变量槽可以复用，但是不会主动擦除数据。</li>
</ul>
</li>
<li>操作数栈（函数、方法的参数传递）<ul>
<li>栈结构，用来做运算和方法调用</li>
</ul>
</li>
<li>动态链接（找调用方法的入口）<ul>
<li>在多态的情况下，只有在运行时才能知道，到底是调用的哪个类的方法，所以要保存一个动态链接。</li>
</ul>
</li>
<li>方法返回地址（当前方法的出口）</li>
</ul>
<h2 id="Java运行时，方法调用的过程是什么样子的？"><a href="#Java运行时，方法调用的过程是什么样子的？" class="headerlink" title="Java运行时，方法调用的过程是什么样子的？"></a>Java运行时，方法调用的过程是什么样子的？</h2><p>方法调用主要分为两种，静态的和动态的。</p>
<ul>
<li>invoke字节码命令</li>
<li>静态分配<ul>
<li>在编译期间就能够去定需要调用的是哪个方法</li>
<li>在一些static方法调用，无继承的（finial修饰）方法调用</li>
</ul>
</li>
<li>动态分配<ul>
<li>在运行期间才能够确定，到底调用的是哪个方法</li>
<li>典型的就是多态，在运行的时候，才能确定调用的是哪个子类对象</li>
</ul>
</li>
<li>在方法区中，虚拟机会对每个类维护一个虚方法表，来记录它调用地址的入口，如果是继承的方法且没有重写，就会指向父类的对应方法入口。</li>
<li>接口同理（接口方法表）</li>
<li>没有别final修饰的方法，都是虚方法</li>
</ul>
<h2 id="Java的动态语言类型支持是什么样子的？"><a href="#Java的动态语言类型支持是什么样子的？" class="headerlink" title="Java的动态语言类型支持是什么样子的？"></a>Java的动态语言类型支持是什么样子的？</h2><p>通过<code>invokedynamic</code>字节码命令实现。<br>在别的动态类型语言里面，类似JavaScript、Grvooy，通过<code>var</code>来定义对象，这个时候就不能确定引用的类型，所以在实际运行时方法调用的时候，需要找到真正执行方法，就有一个lookup的过程。</p>
<h2 id="实战4：掌控方法分派规则"><a href="#实战4：掌控方法分派规则" class="headerlink" title="实战4：掌控方法分派规则"></a>实战4：掌控方法分派规则</h2><h2 id="字节码解释执行的过程是什么样子的？"><a href="#字节码解释执行的过程是什么样子的？" class="headerlink" title="字节码解释执行的过程是什么样子的？"></a>字节码解释执行的过程是什么样子的？</h2><p>我们编写的Java源代码，本质上就是一堆字符串，计算机肯定不认识，所以我们把这段字符串交给JVM编译，编译的结果有两种：<br>一种是字节码，JVM认识，物理机不认识，只能通过JVM解释执行。<br>还有一种就是CPU的指令集，汇编，本质上就是0101，物理机能直接执行。</p>
<p>在JVM的解释执行字节码的过程中，是通过操作数栈进行指令执行的，它是基于内存的，所以速度理论上会慢一点，但是它不会依赖物理机器，可移植。 而物理机执行的话，是基于寄存器的，速度会很快，但是不同架构的CPU的寄存器和指令集都是不同的，就没有可移植性。</p>
<h2 id="你了解的字节码生成技术是什么样子的？"><a href="#你了解的字节码生成技术是什么样子的？" class="headerlink" title="你了解的字节码生成技术是什么样子的？"></a>你了解的字节码生成技术是什么样子的？</h2><h2 id="实战5：自己动手实现远程执行功能"><a href="#实战5：自己动手实现远程执行功能" class="headerlink" title="实战5：自己动手实现远程执行功能"></a>实战5：自己动手实现远程执行功能</h2><h2 id="Java编译的流程是什么样子的？"><a href="#Java编译的流程是什么样子的？" class="headerlink" title="Java编译的流程是什么样子的？"></a>Java编译的流程是什么样子的？</h2><p>Java的编译主要依靠javac工具来执行的，他的任务就是把java源代码，编译成 .class的字节码。<br>主要通过<code>JavaCompiler</code>类来实现的。<br>有4个过程：</p>
<ul>
<li>准备过程<ul>
<li>准备插入式注解处理器（<code>initProcessAnnotations</code>）</li>
</ul>
</li>
<li>语法解析 and 填充符号表 -&gt; 生成抽象语法树<ul>
<li>语法、词法解析。（<code>parseFiles</code>）<ul>
<li>有点像ES中的分词，生成抽象语法树（AST）。</li>
<li>后续的操作都基于这个抽象语法树了。</li>
<li>有插件可以查看。</li>
</ul>
</li>
<li>填充符号表。 产生符号地址和符号信息内容（<code>enterTrees</code>）</li>
</ul>
</li>
<li>注解处理器的处理过程。 （<code>processAnnotations</code>）<ul>
<li>通过注解，在编译期间对抽象语法树做出处理。 著名的案例就是Lombok。</li>
</ul>
</li>
<li>分析语法树 and 字节码生成（<code>compile2()</code>）<ul>
<li>标注检查分析（静态）（<code>attribute()</code>）</li>
<li>控制流检查分析（动态）（<code>flow()</code>）</li>
<li>解语法糖（<code>desugar()</code>）</li>
<li>字节码生成（<code>generate()</code>）</li>
</ul>
</li>
</ul>
<h2 id="实战6：插入式注解处理器"><a href="#实战6：插入式注解处理器" class="headerlink" title="实战6：插入式注解处理器"></a>实战6：插入式注解处理器</h2><h2 id="后端编译的过程是什么样子的？"><a href="#后端编译的过程是什么样子的？" class="headerlink" title="后端编译的过程是什么样子的？"></a>后端编译的过程是什么样子的？</h2><p>后端编译就是java的字节码编译成机器码的过程。在机器上直接跑机器码，速度和性能就会更快。<br>后端编译就是即时编译，是HotSpot虚拟机有的一个主要的功能，其他虚拟机有的也有。<br>它主要的作用，就是在运行期间，对代码的热度，进行统计分析，针对的是方法级别和循环体级别，然后把热点的字节码编译成机器码，让计算机原生之行。</p>
<p>热点统计方式主要有两种：<br>1、采样。  定时在所有栈的顶部采集栈帧，统计方法调用的次数。<br>2、方法计数器。 每个方法、代码块，维护一个调用计数器。到达一定的阈值，就会成为热点代码，会被即时编译期异步的编译成为原生的机器码。</p>
<p>在HotSpot虚拟机中，主要有三种即时编译器，C1、C2和Java10才出来的Graal。 其中Graal的作用是C2的升级版。</p>
<p>在JVM中，使用的是分层编译的方式。<br>第0层，就是纯解释执行<br>第1层，是使用C1编译器，简单快速的编译，并不做统计。<br>第2层，使用C1编译器编译，并做有限的性能监控。<br>第3层，使用C1编译器，并开启全部都性能监控<br>第4层，使用C2编译器，做激进的性能优化<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16487127229876.jpg"></p>
<h2 id="编译的优化方法有哪些？"><a href="#编译的优化方法有哪些？" class="headerlink" title="编译的优化方法有哪些？"></a>编译的优化方法有哪些？</h2><ul>
<li>方法内联（多态方法内联缓存）</li>
<li>逃逸分析（看这个对象有没有超过方法的范围（栈帧），有没有超过线程的范围（方法栈））<ul>
<li>栈上分配（把对象直接在栈上创建，不在堆内存创建）</li>
<li>标量替换（不new出对象，用几个局部变量来代替）</li>
<li>同步消除（如果有锁，而这个对象并没有超出线程的范围，就把锁的过程给优化掉）</li>
</ul>
</li>
<li>无效代码消除</li>
<li>公共子表达式消除（在一个表达式中，如果有重复计算的地方，给他做合并消除，即只需要计算一次）</li>
<li>代数化简（数学操作）</li>
<li>数组边界检查、隐式异常处理、自动装箱消除</li>
</ul>
<h4 id="客户端编译器-C1"><a href="#客户端编译器-C1" class="headerlink" title="客户端编译器  C1"></a>客户端编译器  C1</h4><p>在整体的编译过程一共有几个阶段。</p>
<p>第一个就是从 <code>字节码</code>  编译成  <code>HIR</code>（高级的中间表示编码，与硬件指令集无关）<br>这个时候，会做一些优化。如：<code>方法内联</code>、<code>常数传播</code></p>
<p>第二阶段就是 对  <code>HIR</code>编码做优化<br>会做一些 <code>范围检查消除</code>、<code>空值检查消除</code>等优化</p>
<p>第三阶段就是 把 <code>HIR</code>  编译成  <code>LIR</code>（低等级的中间表示，与硬件指令集有关）</p>
<p>最后一阶段，就是在<code>LIR</code>上做<code>线性算法扫描</code>，<code>分配寄存器</code>，做<code>窥孔</code>（Peephole）优化， 最后生成<code>机器码</code>。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16487136001857.jpg"></p>
<h4 id="服务端编译器-C2"><a href="#服务端编译器-C2" class="headerlink" title="服务端编译器  C2"></a>服务端编译器  C2</h4><p>服务端编译器的优化会更加的激进。</p>
<p>无用代码消除（Dead Code Elimination）、<br>循环展开 （Loop Unrolling）、<br>循环表达式外提（Loop Expression Hoisting）、<br>消除公共子表达式（Common Subexpression Elimination）、<br>常量传播（Constant Propagation）、<br>基本块重排序（Basic Block Reordering）等</p>
<p>范围检查消除（Range Check Elimination）、<br>空值检查消除（Null Check Elimination）</p>
<p>如守护内联（Guarded Inlining）、<br>分支频率预测 （Branch Frequency Prediction）</p>
<h2 id="提前编译-和-即时编译-各有什么优缺点？"><a href="#提前编译-和-即时编译-各有什么优缺点？" class="headerlink" title="提前编译 和 即时编译 各有什么优缺点？"></a>提前编译 和 即时编译 各有什么优缺点？</h2><p>提前编译的优点：</p>
<ol>
<li>独立的资源，在程序运行之前编译，可以享受大量的资源。</li>
<li>一开始运行时的程序的速度就会非常快，不会有预热的过程。<br>及时编译的优点：</li>
<li>实时监控，编译需要编译的代码，并且按层级编译，最高效的使用资源。</li>
<li>可以执行激进的编译优化策略，也是根据性能监控。</li>
<li>动态链接时优化，在运行时，可以确定动态链接库，可以做一些优化，比如方法内联。</li>
</ol>
<h2 id="实战6：深入理解Graal编译器"><a href="#实战6：深入理解Graal编译器" class="headerlink" title="实战6：深入理解Graal编译器"></a>实战6：深入理解Graal编译器</h2><p>字节码 -&gt; 理想图 -&gt; 优化 -&gt; 机器码</p>
<h2 id="Java内存模型是什么样子的？"><a href="#Java内存模型是什么样子的？" class="headerlink" title="Java内存模型是什么样子的？"></a>Java内存模型是什么样子的？</h2><p>首先要从计算机的发展说起，摩尔定律慢慢的失效，硬件发展到了一个瓶颈，而在这种情况下，并行化的发展越来越被看重。 所以就CPU的核心数就越来越多。<br>而有一个客观问题的存在，CPU的速度实在太快了，跟内存的IO不是一个数量级的，我们为了能更加的压榨CPU的性能，就在CPU的每个核心中设立了高速缓存，一般是三层。<br>而这样就会出现一个问题，在多个核心同时对主内存中的数据做操作的时候，会先把内存中的数据缓存一份到自己的高速缓存中，再进行操作。这样就会有了一个数据不一致的并发的问题。  解决这个问题的方法，就是设定一个缓存一致性协议。<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16493208068770.jpg"></p>
<p>而JAVA在这样的基础上，对CPU、高速缓存、主内存这样的硬件结构的基础上，做了一个抽象。就成了JMM（JAVA内存模型）<br><img src="https://cp-images.oss-cn-hangzhou.aliyuncs.com/16493208196376.jpg"></p>
<h2 id="volatile关键字有什么用？"><a href="#volatile关键字有什么用？" class="headerlink" title="volatile关键字有什么用？"></a>volatile关键字有什么用？</h2><ol>
<li>保证变量的可见性<ul>
<li>线程1和线程2，同时操作主内存里面的一个数据。</li>
<li>两个线程都会把数据缓存到自己的工作内存中（高速缓存或寄存器）</li>
<li>如果线程1操作了这个数据，会立刻把更新过后的数据同步到主内存之中</li>
<li>线程2在操作这个数据之前，会先从主内存中拉取最新的数据，再进行操作。</li>
</ul>
</li>
<li>阻止指令重排序<ul>
<li>CPU在执行程序的时候，不一定会按照我们代码编写的顺序执行</li>
<li>CPU为了优化，在编译成汇编语言的时候，会对程序进行各种优化</li>
<li>在赋值操作的时候，顺序的变化可能会导致意想不到的问题</li>
<li>volatile会防止指令的重排序，会添加一个<code>lock add</code>的指令，内存屏障</li>
<li>指令重排的意义在于，CPU把不同的指令，同时分配给不同的电路单元，以提高性能</li>
</ul>
</li>
</ol>
<h2 id="Java的多线程是怎么实现的？"><a href="#Java的多线程是怎么实现的？" class="headerlink" title="Java的多线程是怎么实现的？"></a>Java的多线程是怎么实现的？</h2><p>在主流的操作系统中，线程一般有三种实现方式：</p>
<ol>
<li>内核线程，操作系统自己实现</li>
<li>用户线程，应用程序实现</li>
<li>混合模式，内核线程+用户线程  在一个核心线程上，再扩展N个用户线程</li>
</ol>
<p>JAVA中，主流的JVM都是使用的内核线程，具体的调度由操作系统控制。<br>在GO中，主要使用的是用户线程</p>
<p>核心线程的重要的性能消耗是操作系统在内核态与用户态之间的转换，但是它的优点就是实现起来方便，调操作系统的接口就行了， 上下文的保持工作也是由操作系统实现。<br>而用户线程的有点就是实现起来非常复杂，线程的调度，线程上下文的保持都需要代码实现。而它的优点就是运行效率更高一些。<br>在新版本的JAVA中，也引入的用户线程的实现，fiber，纤程&#x2F;协程。 JAVA可以同时支持核心线程和用户线程</p>
<h2 id="Java中线程安全是怎么保证的？"><a href="#Java中线程安全是怎么保证的？" class="headerlink" title="Java中线程安全是怎么保证的？"></a>Java中线程安全是怎么保证的？</h2><ol>
<li>synchronized关键字</li>
<li>concurrent包， ReentrantLock</li>
<li>分布式锁  redis&#x2F;zk</li>
</ol>
<h2 id="Java中有哪些锁优化？"><a href="#Java中有哪些锁优化？" class="headerlink" title="Java中有哪些锁优化？"></a>Java中有哪些锁优化？</h2><ul>
<li>自旋锁 CAS 忙循环，不会进入线程阻塞  JVM监控子系统还会推算忙循环的次数</li>
<li>锁消除  如果JVM发现没有共享内存变量，即不需要锁，就会把锁给去了</li>
<li>锁粗化  如果检测到一连串的锁，比如StringBuffer连续append，会粗化成一个锁</li>
<li>轻量级锁   由对象头的MarkWord中的标志位 标记。<ul>
<li>如果对象的标志位为<code>01</code>，表示未上锁，线程会通过CSA把标志位改成<code>00</code>，并持有这个锁对象</li>
<li>如果这时候有另外的线程来抢占这个锁，会把锁升级成重量级锁，标志位<code>10</code></li>
</ul>
</li>
<li>偏向锁  在无锁状态下的优化<ul>
<li>在一个线程占用了一个锁对象，又释放了，这时候这个对象是无锁的状态，还会把偏向模式设成1，并记录这个线程的ID</li>
<li>如果这个线程再次获取锁，且在无并发竞争的情况下，不需要上锁了</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
</search>
