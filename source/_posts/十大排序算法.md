---
title: 十大排序算法
date: 2021-07-06 09:52:41
tags: 
- 算法 
- 排序算法
- java
categories: 算法
---
> https://www.cnblogs.com/onepixel/p/7674659.html

## 介绍

今天开启我们的算法系列，争取说简单➕通俗易懂。
我们从经典的排序算法开始。学习十大排序算法。
![](https://cp-images.oss-cn-hangzhou.aliyuncs.com/zoOH3H.png)

排序算法可以分为两大类：基于比较的排序 and 不基于比较的排序。
基于比较的排序，是通过元素间的两两比较，来判断大小，继而排序。
不基于比较的排序，就是通过各种其他的方法，来让元素排序。

在表格中，上面的7种都是基于比较的排序算法。下3种是不基于比较的排序。

接下来我们一个一个的来仔细看。

<!--more-->

## 1、冒泡排序（Bubble Sort）

首先，我们来说说最简单的冒泡排序。

大家可以想象一下，在小学的时候，第一节体育课，老师给我们按照身高排成一列。

就是相邻的两个同学比较一下身高，让后把高的放右边，矮的站左边。

冒泡排序就是这样，从左往右遍历，相邻的两个元素进行比较，大的放右边，小的放左边。

这样一次遍历之后，最右边的元素肯定是最大的。

再进行n次遍历，就可以把整个队列排好序了。

![](https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015223238449-2146169197.gif)

代码如下：

```java
/**
 * 冒泡排序
 * <p>
 * 两次循环，相邻的两个元素比较，小的往前
 * <p>
 * O(n2)
 */
public class BubbleSort {

	public static class Solution {

		public int[] sort(int[] nums) {
			// 注意边界， 不用到最后一个
			for (int i = 0; i < nums.length - 1; i++) {
				for (int j = 0; j < nums.length - i - 1; j++) {
					if (nums[j] > nums[j + 1]) {
						SortUtil.swap(nums, j, j + 1);
					}
				}
			}
			return nums;
		}
	}

}
```

## 2、选择排序（Selection Sort）

选择排序思路也很简单，我们把队列分成两个部分。

一部分是乱序的，就是我们一开始的样子。

一部分是有序的。

我们先在乱序的队列里面找到一个最小的元素，放到有序的队列里面。

再在乱序的队列里面找一个最小的元素，依次放到有序队列里面。

直到乱序的队列里面一个元素都没有了。

这样，有序的队列就是我们最终的结果。

为了节省空间，我们可以在一个数组里面，存下这两个队列。
![](https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015223238449-2146169197.gif)

代码如下：

```java
/**
 * 选择排序， 每次循环找出最小值，往前面换
 */
public class SelectionSort {

	public static class Solution {

		public int[] sort(int[] nums) {
			int minIndex;
			for (int i = 0; i < nums.length - 1; i++) {
				minIndex = i;
				for (int j = i; j < nums.length; j++) {
					if (nums[j] < nums[minIndex]) {
						minIndex = j;
					}
				}
				SortUtil.swap(nums, i, minIndex);
			}
			return nums;
		}
	}

}
```

## 3、插入排序（Insertion Sort）

插入排序也很好理解。

相信大家都打过扑克牌，每次我们一开始摸牌都时候，都是一次插入排序都过程。

同样有两个队列，一个乱序，一个有序。

每次我们从乱序都队列里面拿出一张牌，再插入到有序队列里面合适到地方。

这就是插入排序。

![](https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015223238449-2146169197.gif)

请看代码：

```java
/**
 * 插入排序， 找到一个元素，向前扫描，前面但往后移动，在合适但地方插入
 */
public class InsertionSort {

	public static class Solution {

		public int[] sort(int[] nums) {
			if (nums.length < 2) {
				return nums;
			}
			// 1   3   2
			//     j   i
			// 1   2   3
			// j       i
			for (int i = 1; i < nums.length; i++) {
				int indexValue = nums[i];
				// 往左扫描
				for (int j = i - 1; j >= 0; j--) {
					// 如果indexValue比较小，j往右移动
					// 同时把 i的值填充进去
					if (indexValue < nums[j]) {
						nums[j + 1] = nums[j];
						nums[j] = indexValue;
					} else {
						// 已经找到比当前小的了， 跳出此轮循环
						break;
					}
				}
			}
			return nums;
		}
	}

}

```

## 4、希尔排序（Shell Sort）

希尔排序，顾名思义，它是一个名叫希尔的人发明的，第一个个时间复杂的图片O(n2)排序。

它是插入排序的一个变种，但是它的实现相对复杂。

为了帮助大家理解，我们先看一下**插入排序**的动图。

![插入排序](https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015223238449-2146169197.gif)

大家有没有发现，每一次插入的过程，基本上都要移动好几个元素。大小相似的元素往往相隔的比较远。

为了优化这个过程，希尔选择了先把整个队列按照间隔分组，分别进行插入排序。

然后间隔原来越小，当间隔为1的时候，就是一次正常的插入排序。

这样在前期的准备中，大小相似的元素，相邻的都比较近了，可以提高最终排序的效率。

动图如下：
![](https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20180331170017421-364506073.gif)

代码如下：

```java
/**
 * 希尔排序：
 * 1 按照间隔分组（初始间隔一般是数组长度的一半）
 * 2 排序每个组（插入排序法）
 * 3 间隔减小，重新分组（新的间隔一般为原间隔的一般，最后为1）
 * 4 再排序每个组
 */
public class ShellSort {

	public static class Solution {

		public int[] sort(int[] nums) {
			int interval = nums.length / 2;
			while (interval > 0) {
				insertSortByInterval(nums, interval);
				interval = interval / 2;
			}
			return nums;
		}

		private void insertSortByInterval(int[] nums, int interval) {
			for (int i = 0; i < interval; i++) {
				for (int j = i + interval; j < nums.length; j += interval) {
					insertSortByInterval(nums, j, interval);
				}
			}
		}

		//  0  x  x  2  x  x  3  x  x  1  x  x
		//                    i        s
		private void insertSortByInterval(int[] nums, int startIndex, int interval) {
			int value = nums[startIndex];
			int i = startIndex - interval;
			while (i >= 0 && nums[i] > value) {
				nums[i + interval] = nums[i];
				nums[i] = value;
				i -= interval;
			}
		}
	}

}
```

## 5、归并排序（Merge Sort）
如果你是程序员的化，归并排序也很好理解。

它主要采用分治的思想，使用递归。 化繁为简。

直接上代码：
```java
/**
 * 归并排序
 */
public class MergeSort {

	public static class Solution {

		public int[] sort(int[] nums) {
			return mergeSort(nums);
		}

		// 递归方法
		private int[] mergeSort(int[] nums) {
			// 递归出口
			if (nums.length < 2) {
				return nums;
			}
			// 分成两个数组
			int m = nums.length / 2;
			int[] left = Arrays.copyOfRange(nums, 0, m);
			int[] right = Arrays.copyOfRange(nums, m, nums.length);
			// 对这两个数组做排序
			left = mergeSort(left);
			right = mergeSort(right);
			// 合并这两个排序好的数组
			return mergeSort(left, right);
		}

		// 对两个排序好的数组做合并
		private int[] mergeSort(int[] left, int[] right) {
			int length = left.length + right.length;
			int[] merged = new int[length];
			int leftIndex = 0, rightIndex = 0;
			for (int i = 0; i < length; i++) {
				if (leftIndex < left.length && rightIndex < right.length) {
					int leftValue = left[leftIndex];
					int rightValue = right[rightIndex];
					if (leftValue < rightValue) {
						merged[i] = leftValue;
						leftIndex++;
					} else {
						merged[i] = rightValue;
						rightIndex++;
					}
				} else if (leftIndex >= left.length) {
					merged[i] = right[rightIndex];
					rightIndex++;
				} else {
					merged[i] = left[leftIndex];
					leftIndex++;
				}
			}
			return merged;
		}
	}

}

```
动图如下：
![](https://cp-images.oss-cn-hangzhou.aliyuncs.com/849589-20171015230557043-37375010.gif)


## 6、快速排序（Quick Sort）

## 7、堆排序（Heap Sort）

## 8、计数排序（Counting Sort）

## 9、桶排序（Bucket Sort）

## 10、基数排序（Radix Sort）
